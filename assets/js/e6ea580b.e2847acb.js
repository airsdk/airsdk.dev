"use strict";(self.webpackChunkairsdk_dev=self.webpackChunkairsdk_dev||[]).push([[10369],{28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>o});var a=t(96540);const s={},i=a.createContext(s);function r(e){const n=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),a.createElement(i.Provider,{value:n},e.children)}},30356:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"development/appendixes/sql-support-in-local-databases/data-type-support","title":"Data type support","description":"Unlike most SQL databases, the Adobe AIR SQL database engine does not require or","source":"@site/docs/development/appendixes/sql-support-in-local-databases/data-type-support.md","sourceDirName":"development/appendixes/sql-support-in-local-databases","slug":"/development/appendixes/sql-support-in-local-databases/data-type-support","permalink":"/docs/development/appendixes/sql-support-in-local-databases/data-type-support","draft":false,"unlisted":false,"editUrl":"https://github.com/airsdk/airsdk.dev/edit/main/docs/development/appendixes/sql-support-in-local-databases/data-type-support.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"mainSidebar","previous":{"title":"Supported SQL syntax","permalink":"/docs/development/appendixes/sql-support-in-local-databases/supported-sql-syntax"},"next":{"title":"SQL error detail messages, ids, and arguments","permalink":"/docs/development/appendixes/sql-support-in-local-databases/sql-error-detail-messages-ids-and-arguments"}}');var s=t(74848),i=t(28453);const r={sidebar_position:2},o="Data type support",l={},c=[{value:"Storage classes",id:"storage-classes",level:2},{value:"Column affinity",id:"column-affinity",level:2},{value:"Determining affinity",id:"determining-affinity",level:4},{value:"Data types and comparison operators",id:"data-types-and-comparison-operators",level:2},{value:"Data types and mathematical operators",id:"data-types-and-mathematical-operators",level:2},{value:"Data types and sorting",id:"data-types-and-sorting",level:2},{value:"Data types and grouping",id:"data-types-and-grouping",level:2},{value:"Data types and compound SELECT statements",id:"data-types-and-compound-select-statements",level:2}];function d(e){const n={br:"br",em:"em",h1:"h1",h2:"h2",h4:"h4",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"data-type-support",children:"Data type support"})}),"\n",(0,s.jsx)(n.p,{children:"Unlike most SQL databases, the Adobe AIR SQL database engine does not require or\nenforce that table columns contain values of a certain type. Instead, the\nruntime uses two concepts, storage classes and column affinity, to control data\ntypes. This section describes storage classes and column affinity, as well as\nhow data type differences are resolved under various conditions."}),"\n",(0,s.jsx)(n.h2,{id:"storage-classes",children:"Storage classes"}),"\n",(0,s.jsx)(n.p,{children:"Storage classes represent the actual data types that are used to store values in\na database. The following storage classes are used by the database:"}),"\n",(0,s.jsxs)(n.p,{children:["NULL",(0,s.jsx)(n.br,{}),"\n","The value is a NULL value."]}),"\n",(0,s.jsxs)(n.p,{children:["INTEGER",(0,s.jsx)(n.br,{}),"\n","The value is a signed integer."]}),"\n",(0,s.jsxs)(n.p,{children:["REAL",(0,s.jsx)(n.br,{}),"\n","The value is a floating-point number value."]}),"\n",(0,s.jsxs)(n.p,{children:["TEXT",(0,s.jsx)(n.br,{}),"\n","The value is a text string (limited to 256 MB)."]}),"\n",(0,s.jsxs)(n.p,{children:["BLOB",(0,s.jsx)(n.br,{}),"\n","The value is a Binary Large Object (BLOB); in other words, raw binary data\n(limited to 256 MB)."]}),"\n",(0,s.jsx)(n.p,{children:"All values supplied to the database as literals embedded in a SQL statement or\nvalues bound using parameters to a prepared SQL statement are assigned a storage\nclass before the SQL statement is executed."}),"\n",(0,s.jsx)(n.p,{children:"Literals that are part of a SQL statement are assigned storage class TEXT if\nthey are enclosed by single or double quotes, INTEGER if the literal is\nspecified as an unquoted number with no decimal point or exponent, REAL if the\nliteral is an unquoted number with a decimal point or exponent and NULL if the\nvalue is a NULL. Literals with storage class BLOB are specified using the\nX'ABCD' notation. For more information, see Literal values in expressions."}),"\n",(0,s.jsx)(n.p,{children:"Values supplied as parameters using the SQLStatement.parameters associative\narray are assigned the storage class that most closely matches the native data\ntype bound. For example, int values are bound as INTEGER storage class, Number\nvalues are given the REAL storage class, String values are given the TEXT\nstorage class, and ByteArray objects are given the BLOB storage class."}),"\n",(0,s.jsx)(n.h2,{id:"column-affinity",children:"Column affinity"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.em,{children:"affinity"})," of a column is the recommended type for data stored in that\ncolumn. When a value is stored in a column (through an INSERT or UPDATE\nstatement), the runtime attempts to convert that value from its data type to the\nspecified affinity. For example, if a Date value (an ActionScript or JavaScript\nDate instance) is inserted into a column whose affinity is TEXT, the Date value\nis converted to the String representation (equivalent to calling the object's\ntoString() method) before being stored in the database. If the value cannot be\nconverted to the specified affinity an error occurs and the operation is not\nperformed. When a value is retrieved from the database using a SELECT statement,\nit is returned as an instance of the class corresponding to the affinity,\nregardless of whether it was converted from a different data type when it was\nstored."]}),"\n",(0,s.jsx)(n.p,{children:"If a column accepts NULL values, the ActionScript or JavaScript value null can\nbe used as a parameter value to store NULL in the column. When a NULL storage\nclass value is retrieved in a SELECT statement, it is always returned as the\nActionScript or JavaScript value null, regardless of the column's affinity. If a\ncolumn accepts NULL values, always check values retrieved from that column to\ndetermine if they're null before attempting to cast the values to a non-nullable\ntype (such as Number or Boolean)."}),"\n",(0,s.jsx)(n.p,{children:"Each column in the database is assigned one of the following type affinities:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"TEXT (or String)"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"NUMERIC"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"INTEGER (or int)"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"REAL (or Number)"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Boolean"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Date"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"XML"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"XMLLIST"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Object"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"NONE"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"TEXT (or String)"})}),"\n",(0,s.jsx)(n.p,{children:"A column with TEXT or String affinity stores all data using storage classes\nNULL, TEXT, or BLOB. If numerical data is inserted into a column with TEXT\naffinity it is converted to text form before being stored."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"NUMERIC"})}),"\n",(0,s.jsx)(n.p,{children:"A column with NUMERIC affinity contains values using storage classes NULL, REAL,\nor INTEGER. When text data is inserted into a NUMERIC column, an attempt is made\nto convert it to an integer or real number before it is stored. If the\nconversion is successful, then the value is stored using the INTEGER or REAL\nstorage class (for example, a value of '10.05' is converted to REAL storage\nclass before being stored). If the conversion cannot be performed an error\noccurs. No attempt is made to convert a NULL value. A value that's retrieved\nfrom a NUMERIC column is returned as an instance of the most specific numeric\ntype into which the value fits. In other words, if the value is a positive\ninteger or 0, it's returned as a uint instance. If it\u2019s a negative integer, it\u2019s\nreturned as an int instance. Finally, if it has a floating-point component (it's\nnot an integer) it's returned as a Number instance."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"INTEGER (or int)"})}),"\n",(0,s.jsx)(n.p,{children:"A column that uses INTEGER affinity behaves in the same way as a column with\nNUMERIC affinity, with one exception. If the value to be stored is a real value\n(such as a Number instance) with no floating point component or if the value is\na text value that can be converted to a real value with no floating point\ncomponent, it is converted to an integer and stored using the INTEGER storage\nclass. If an attempt is made to store a real value with a floating point\ncomponent an error occurs."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"REAL (or Number)"})}),"\n",(0,s.jsx)(n.p,{children:"A column with REAL or NUMBER affinity behaves like a column with NUMERIC\naffinity except that it forces integer values into floating point\nrepresentation. A value in a REAL column is always returned from the database as\na Number instance."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Boolean"})}),"\n",(0,s.jsx)(n.p,{children:"A column with Boolean affinity stores true or false values. A Boolean column\naccepts a value that is an ActionScript or JavaScript Boolean instance. If code\nattempts to store a String value, a String with a length greater than zero is\nconsidered true, and an empty String is false. If code attempts to store numeric\ndata, any non-zero value is stored as true and 0 is stored as false. When a\nBoolean value is retrieved using a SELECT statement, it is returned as a Boolean\ninstance. Non-NULL values are stored using the INTEGER storage class (0 for\nfalse and 1 for true) and are converted to Boolean objects when data is\nretrieved."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Date"})}),"\n",(0,s.jsx)(n.p,{children:"A column with Date affinity stores date and time values. A Date column is\ndesigned to accept values that are ActionScript or JavaScript Date instances. If\nan attempt is made to store a String value in a Date column, the runtime\nattempts to convert it to a Julian date. If the conversion fails an error\noccurs. If code attempts to store a Number, int, or uint value, no attempt is\nmade to validate the data and it is assumed to be a valid Julian date value. A\nDate value that's retrieved using a SELECT statement is automatically converted\nto a Date instance. Date values are stored as Julian date values using the REAL\nstorage class, so sorting and comparing operations work as you would expect them\nto."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"XML or XMLList"})}),"\n",(0,s.jsx)(n.p,{children:"A column that uses XML or XMLList affinity stores XML structures. When code\nattempts to store data in an XML column using a SQLStatement parameter the\nruntime attempts to convert and validate the value using the ActionScript XML()\nor XMLList() function. If the value cannot be converted to valid XML an error\noccurs. If the attempt to store the data uses a literal SQL text value (for\nexample INSERT INTO (col1) VALUES ('Invalid XML (no closing tag)'), the value is\nnot parsed or validated \u2014 it is assumed to be well-formed. If an invalid value\nis stored, when it is retrieved it is returned as an empty XML object. XML and\nXMLList Data is stored using the TEXT storage class or the NULL storage class."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Object"})}),"\n",(0,s.jsx)(n.p,{children:"A column with Object affinity stores ActionScript or JavaScript complex objects,\nincluding Object class instances as well as instances of Object subclasses such\nas Array instances and even custom class instances. Object column data is\nserialized in AMF3 format and stored using the BLOB storage class. When a value\nis retrieved, it is deserialized from AMF3 and returned as an instance of the\nclass as it was stored. Note that some ActionScript classes, notably display\nobjects, cannot be deserialized as instances of their original data type. Before\nstoring a custom class instance, you must register an alias for the class using\nthe flash.net.registerClassAlias() method (or in Flex by adding [RemoteObject]\nmetadata to the class declaration). Also, before retrieving that data you must\nregister the same alias for the class. Any data that can't be deserialized\nproperly, either because the class inherently can't be deserialized or because\nof a missing or mismatched class alias, is returned as an anonymous object (an\nObject class instance) with properties and values corresponding to the original\ninstance as stored."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"NONE"})}),"\n",(0,s.jsx)(n.p,{children:"A column with affinity NONE does not prefer one storage class over another. It\nmakes no attempt to convert data before it is inserted."}),"\n",(0,s.jsx)(n.h4,{id:"determining-affinity",children:"Determining affinity"}),"\n",(0,s.jsx)(n.p,{children:"The type affinity of a column is determined by the declared type of the column\nin the CREATE TABLE statement. When determining the type the following rules\n(not case-sensitive) are applied:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:'If the data type of the column contains any of the strings "CHAR", "CLOB",\n"STRI", or "TEXT" then that column has TEXT/String affinity. Notice that the\ntype VARCHAR contains the string "CHAR" and is thus assigned TEXT affinity.'}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:'If the data type for the column contains the string "BLOB" or if no data type\nis specified then the column has affinity NONE.'}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:'If the data type for column contains the string "XMLL" then the column has\nXMLList affinity.'}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:'If the data type is the string "XML" then the column has XML affinity.'}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:'If the data type contains the string "OBJE" then the column has Object\naffinity.'}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:'If the data type contains the string "BOOL" then the column has Boolean\naffinity.'}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:'If the data type contains the string "DATE" then the column has Date affinity.'}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:'If the data type contains the string "INT" (including "UINT") then it is\nassigned INTEGER/int affinity.'}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:'If the data type for a column contains any of the strings "REAL", "NUMB",\n"FLOA", or "DOUB" then the column has REAL/Number affinity.'}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Otherwise, the affinity is NUMERIC."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"If a table is created using a CREATE TABLE t AS SELECT... statement then all\ncolumns have no data type specified and they are given the affinity NONE."}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"data-types-and-comparison-operators",children:"Data types and comparison operators"}),"\n",(0,s.jsx)(n.p,{children:"The following binary comparison operators =, <, <=, >= and != are supported,\nalong with an operation to test for set membership, IN, and the ternary\ncomparison operator BETWEEN. For details about these operators see Operators."}),"\n",(0,s.jsx)(n.p,{children:"The results of a comparison depend on the storage classes of the two values\nbeing compared. When comparing two values the following rules are applied:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"A value with storage class NULL is considered less than any other value\n(including another value with storage class NULL)."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"An INTEGER or REAL value is less than any TEXT or BLOB value. When an INTEGER\nor REAL is compared to another INTEGER or REAL, a numerical comparison is\nperformed."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"A TEXT value is less than a BLOB value. When two TEXT values are compared, a\nbinary comparison is performed."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"When two BLOB values are compared, the result is always determined using a\nbinary comparison."}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The ternary operator BETWEEN is always recast as the equivalent binary\nexpression. For example, a BETWEEN b AND c is recast to a >= b AND a <= c,\neven if this means that different affinities are applied to a in each of the\ncomparisons required to evaluate the expression."}),"\n",(0,s.jsx)(n.p,{children:"Expressions of the type a IN (SELECT b ....) are handled by the three rules\nenumerated previously for binary comparisons, that is, in a similar manner to a\n= b. For example, if b is a column value and a is an expression, then the\naffinity of b is applied to a before any comparisons take place. The expression\na IN (x, y, z) is recast as a = +x OR a = +y OR a = +z. The values to the right\nof the IN operator (the x, y, and z values in this example) are considered to be\nexpressions, even if they happen to be column values. If the value of the left\nof the IN operator is a column, then the affinity of that column is used. If the\nvalue is an expression then no conversions occur."}),"\n",(0,s.jsx)(n.p,{children:"How comparisons are performed can also be affected by the use of a COLLATE\nclause. For more information, see COLLATE."}),"\n",(0,s.jsx)(n.h2,{id:"data-types-and-mathematical-operators",children:"Data types and mathematical operators"}),"\n",(0,s.jsx)(n.p,{children:"For each of the supported mathematical operators, *, /, %, +, and -, numeric\naffinity is applied to each operand before evaluating the expression. If any\noperand cannot be converted to the NUMERIC storage class successfully the\nexpression evaluates to NULL."}),"\n",(0,s.jsx)(n.p,{children:"When the concatenation operator || is used each operand is converted to the\nTEXT storage class before the expression is evaluated. If any operand cannot be\nconverted to the TEXT storage class then the result of the expression is NULL.\nThis inability to convert the value can happen in two situations, if the value\nof the operand is NULL, or if it's a BLOB containing a non-TEXT storage class."}),"\n",(0,s.jsx)(n.h2,{id:"data-types-and-sorting",children:"Data types and sorting"}),"\n",(0,s.jsx)(n.p,{children:"When values are sorted by an ORDER BY clause, values with storage class NULL\ncome first. These are followed by INTEGER and REAL values interspersed in\nnumeric order, followed by TEXT values in binary order or based on the specified\ncollation (BINARY or NOCASE). Finally come BLOB values in binary order. No\nstorage class conversions occur before the sort."}),"\n",(0,s.jsx)(n.h2,{id:"data-types-and-grouping",children:"Data types and grouping"}),"\n",(0,s.jsx)(n.p,{children:"When grouping values with the GROUP BY clause, values with different storage\nclasses are considered distinct. An exception is INTEGER and REAL values which\nare considered equal if they are numerically equivalent. No affinities are\napplied to any values as the result of a GROUP BY clause."}),"\n",(0,s.jsx)(n.h2,{id:"data-types-and-compound-select-statements",children:"Data types and compound SELECT statements"}),"\n",(0,s.jsx)(n.p,{children:"The compound SELECT operators UNION, INTERSECT, and EXCEPT perform implicit\ncomparisons between values. Before these comparisons are performed an affinity\nmay be applied to each value. The same affinity, if any, is applied to all\nvalues that may be returned in a single column of the compound SELECT result\nset. The affinity that is applied is the affinity of the column returned by the\nfirst component SELECT statement that has a column value (and not some other\nkind of expression) in that position. If for a given compound SELECT column none\nof the component SELECT statements return a column value, no affinity is applied\nto the values from that column before they are compared."})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);