"use strict";(globalThis.webpackChunkairsdk_dev=globalThis.webpackChunkairsdk_dev||[]).push([[90003],{28453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>d});var i=n(96540);const o={},s=i.createContext(o);function r(e){const t=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function d(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),i.createElement(s.Provider,{value:t},e.children)}},32875:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>d,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>a});const i=JSON.parse('{"id":"development/text/using-the-flash-text-engine/working-with-fonts","title":"Working with fonts","description":"The FontDescription object is used in conjunction with ElementFormat to","source":"@site/docs/development/text/using-the-flash-text-engine/working-with-fonts.md","sourceDirName":"development/text/using-the-flash-text-engine","slug":"/development/text/using-the-flash-text-engine/working-with-fonts","permalink":"/docs/development/text/using-the-flash-text-engine/working-with-fonts","draft":false,"unlisted":false,"editUrl":"https://github.com/airsdk/airsdk.dev/edit/main/docs/development/text/using-the-flash-text-engine/working-with-fonts.md","tags":[],"version":"current","frontMatter":{},"sidebar":"mainSidebar","previous":{"title":"Handling Events in FTE","permalink":"/docs/development/text/using-the-flash-text-engine/handling-events-in-fte"},"next":{"title":"Embedding fonts","permalink":"/docs/development/text/embedding-fonts"}}');var o=n(74848),s=n(28453);const r={},d="Working with fonts",c={},a=[{value:"Defining font characteristics (FontDescription object)",id:"defining-font-characteristics-fontdescription-object",level:2},{value:"Embedded versus device fonts",id:"embedded-versus-device-fonts",level:2},{value:"Rendering mode and hinting",id:"rendering-mode-and-hinting",level:2},{value:"Locking and cloning FontDescription",id:"locking-and-cloning-fontdescription",level:2}];function l(e){const t={code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.header,{children:(0,o.jsx)(t.h1,{id:"working-with-fonts",children:"Working with fonts"})}),"\n",(0,o.jsxs)(t.p,{children:["The ",(0,o.jsx)(t.code,{children:"FontDescription"})," object is used in conjunction with ",(0,o.jsx)(t.code,{children:"ElementFormat"})," to\nidentify a font face and define some of its characteristics. These\ncharacteristics include the font name, weight, posture, rendering, and how to\nfind the font (device versus embedded)."]}),"\n",(0,o.jsx)(t.p,{children:"Note: FTE does not support Type 1 fonts or bitmap fonts such as Type 3, ATC,\nsfnt-wrapped CID, or Naked CID."}),"\n",(0,o.jsx)(t.h2,{id:"defining-font-characteristics-fontdescription-object",children:"Defining font characteristics (FontDescription object)"}),"\n",(0,o.jsxs)(t.p,{children:["The ",(0,o.jsx)(t.code,{children:"fontName"})," property of the ",(0,o.jsx)(t.code,{children:"FontDescription"}),' object can be a single name or\na comma-separated list of names. For example, in a list such as "Arial,\nHelvetica, _sans", the text engine looks for "Arial" first, then "Helvetica",\nand finally "_sans", if it can\'t find either of the first two fonts. The set of\nfont names include three generic device font names: "_sans", "_serif", and\n"_typewriter". They map to specific device fonts, depending on the playback\nsystem. It is good practice to specify default names such as these in all font\ndescriptions that use device fonts. If no ',(0,o.jsx)(t.code,{children:"fontName"}),' is specified, "_serif" is\nused as the default.']}),"\n",(0,o.jsxs)(t.p,{children:["The ",(0,o.jsx)(t.code,{children:"fontPosture"})," property can either be set to the default (\n",(0,o.jsx)(t.code,{children:"FontPosture.NORMAL"}),") or to italics ( ",(0,o.jsx)(t.code,{children:"FontPosture.ITALIC"}),"). The ",(0,o.jsx)(t.code,{children:"fontWeight"}),"\nproperty can be set to the default ( ",(0,o.jsx)(t.code,{children:"FontWeight.NORMAL"}),") or to bold (\n",(0,o.jsx)(t.code,{children:"FontWeight.BOLD"}),")."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{children:'var fd1:FontDescription = new FontDescription();\nfd1.fontName = "Arial, Helvetica, _sans";\nfd1.fontPosture = FontPosture.NORMAL;\nfd1.fontWeight = FontWeight.BOLD;\n'})}),"\n",(0,o.jsx)(t.h2,{id:"embedded-versus-device-fonts",children:"Embedded versus device fonts"}),"\n",(0,o.jsxs)(t.p,{children:["The ",(0,o.jsx)(t.code,{children:"fontLookup"})," property of the ",(0,o.jsx)(t.code,{children:"FontDescription"})," object specifies whether the\ntext engine looks for a device font or embedded font to render text. If a device\nfont ( ",(0,o.jsx)(t.code,{children:"FontLookup.DEVICE"}),") is specified, the runtime looks for the font on the\nplayback system. Specifying an embedded font ( ",(0,o.jsx)(t.code,{children:"FontLookup.EMBEDDED_CFF"}),") causes\nthe runtime to look for an embedded font with the specified name in the SWF\nfile. Only embedded CFF (Compact Font Format) fonts work with this setting. If\nthe specified font is not found, a fallback device font is used."]}),"\n",(0,o.jsx)(t.p,{children:"Device fonts result in a smaller SWF file size. Embedded fonts give you greater\nfidelity across platforms."}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{children:'var fd1:FontDescription = new FontDescription();\nfd1.fontLookup = FontLookup.EMBEDDED_CFF;\nfd1.fontName = "Garamond, _serif";\n'})}),"\n",(0,o.jsx)(t.h2,{id:"rendering-mode-and-hinting",children:"Rendering mode and hinting"}),"\n",(0,o.jsxs)(t.p,{children:["CFF (Compact Font Format) rendering is available starting with Flash Player 10\nand Adobe AIR 1.5. This type of font rendering makes text more legible, and\npermits higher-quality display of fonts at small sizes. This setting only\napplies to embedded fonts. ",(0,o.jsx)(t.code,{children:"FontDescription"})," defaults to this setting (\n",(0,o.jsx)(t.code,{children:"RenderingMode.CFF"}),") for the ",(0,o.jsx)(t.code,{children:"renderingMode"})," property. You can set this property\nto ",(0,o.jsx)(t.code,{children:"RenderingMode.NORMAL"})," to match the type of rendering used by Flash Player 7\nor earlier versions."]}),"\n",(0,o.jsxs)(t.p,{children:["When CFF rendering is selected, a second property, ",(0,o.jsx)(t.code,{children:"cffHinting"}),", controls how a\nfont's horizontal stems are fit to the subpixel grid. The default value,\n",(0,o.jsx)(t.code,{children:"CFFHinting.HORIZONTAL_STEM"}),", uses CFF hinting. Setting this property to\n",(0,o.jsx)(t.code,{children:"CFFHinting.NONE"})," removes hinting, which is appropriate for animation or for\nlarge font sizes."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{children:"var fd1:FontDescription = new FontDescription();\nfd1.renderingMode = RenderingMode.CFF;\nfd1.cffHinting = CFFHinting.HORIZONTAL_STEM;\n"})}),"\n",(0,o.jsx)(t.h2,{id:"locking-and-cloning-fontdescription",children:"Locking and cloning FontDescription"}),"\n",(0,o.jsxs)(t.p,{children:["When a ",(0,o.jsx)(t.code,{children:"FontDescription"})," object is assigned to an ",(0,o.jsx)(t.code,{children:"ElementFormat"}),", its ",(0,o.jsx)(t.code,{children:"locked"}),"\nproperty is automatically set to ",(0,o.jsx)(t.code,{children:"true"}),". Attempting to modify a locked\n",(0,o.jsx)(t.code,{children:"FontDescription"})," object throws an ",(0,o.jsx)(t.code,{children:"IllegalOperationError"}),". The best practice is\nto fully define such an object before assigning it to a ",(0,o.jsx)(t.code,{children:"ElementFormat"}),"."]}),"\n",(0,o.jsxs)(t.p,{children:["If you want to modify an existing ",(0,o.jsx)(t.code,{children:"FontDescription"}),", first check its ",(0,o.jsx)(t.code,{children:"locked"}),"\nproperty. If it's ",(0,o.jsx)(t.code,{children:"true"}),", use the ",(0,o.jsx)(t.code,{children:"clone()"})," method to create an unlocked copy of\nthe object. The properties of this unlocked object can be changed, and it can\nthen be assigned to the ",(0,o.jsx)(t.code,{children:"ElementFormat"}),". Any new lines created from this\n",(0,o.jsx)(t.code,{children:"TextElement"})," have the new formatting. Previous lines created from this same\nobject are unchanged."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{children:'package\n{\n\timport flash.display.Sprite;\n\timport flash.text.*;\n\n\tpublic class FontDescriptionCloneExample extends Sprite\n\t{\n\t\tprivate var tb:TextBlock = new TextBlock();\n\t\tprivate var te:TextElement;\n\t\tprivate var ef1:ElementFormat;\n\t\tprivate var ef2:ElementFormat;\n\t\tprivate var fd1:FontDescription = new FontDescription();\n\t\tprivate var fd2:FontDescription;\n\n\t\tpublic function FontDescriptionCloneExample()\n\t\t{\n\t\t\tfd1.fontName = "Garamond";\n\t\t\tef1 = new ElementFormat(fd);\n\t\t\tvar str:String = "This is flash text";\n\t\t\tte = new TextElement(str, ef);\n\t\t\ttb.content = te;\n\t\t\tvar tx1:TextLine = tb.createTextLine(null,600);\n\t\t\taddChild(tx1);\n\n\t\t\tfd2 = (fd1.locked) ? fd1.clone() : fd1;\n\t\t\tfd2.fontName = "Arial";\n\t\t\tef2 = (ef1.locked) ? ef1.clone() : ef1;\n\t\t\tef2.fontDescription = fd2;\n\t\t\ttb.content.elementFormat = ef2;\n\t\t\tvar tx2:TextLine = tb.createTextLine(null,600);\n\t\t\taddChild(tx2);\n\t\t}\n\t}\n}\n'})})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}}}]);