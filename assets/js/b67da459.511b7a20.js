"use strict";(self.webpackChunkairsdk_dev=self.webpackChunkairsdk_dev||[]).push([[5919],{28453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>s});var o=n(96540);const i={},a=o.createContext(i);function r(e){const t=o.useContext(a);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),o.createElement(a.Provider,{value:t},e.children)}},79583:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>p,frontMatter:()=>r,metadata:()=>o,toc:()=>d});const o=JSON.parse('{"id":"development/security/air-security/working-securely-with-untrusted-content","title":"Working securely with untrusted content","description":"Content not assigned to the application sandbox can provide additional scripting","source":"@site/docs/development/security/air-security/working-securely-with-untrusted-content.md","sourceDirName":"development/security/air-security","slug":"/development/security/air-security/working-securely-with-untrusted-content","permalink":"/docs/development/security/air-security/working-securely-with-untrusted-content","draft":false,"unlisted":false,"editUrl":"https://github.com/airsdk/airsdk.dev/edit/main/docs/development/security/air-security/working-securely-with-untrusted-content.md","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"sidebar_position":6},"sidebar":"mainSidebar","previous":{"title":"Writing to disk","permalink":"/docs/development/security/air-security/writing-to-disk"},"next":{"title":"Best security practices for developers","permalink":"/docs/development/security/air-security/best-security-practices-for-developers"}}');var i=n(74848),a=n(28453);const r={sidebar_position:6},s="Working securely with untrusted content",c={},d=[{value:"Security.allowDomain()",id:"securityallowdomain",level:2},{value:"Scripting between application and non-application content",id:"scripting-between-application-and-non-application-content",level:2},{value:"Protection against dynamically generating unsafe SWF content",id:"protection-against-dynamically-generating-unsafe-swf-content",level:2}];function l(e){const t={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"working-securely-with-untrusted-content",children:"Working securely with untrusted content"})}),"\n",(0,i.jsx)(t.p,{children:"Content not assigned to the application sandbox can provide additional scripting\nfunctionality to your application, but only if it meets the security criteria of\nthe runtime. This topic explains the AIR security contract with non-application\ncontent."}),"\n",(0,i.jsx)(t.h2,{id:"securityallowdomain",children:"Security.allowDomain()"}),"\n",(0,i.jsxs)(t.p,{children:["AIR applications restrict scripting access for non-application content more\nstringently than the Flash Player browser plug-in restricts scripting access for\nuntrusted content. For example, in Flash Player in the browser, when a SWF file\nthat is assigned to the ",(0,i.jsx)(t.code,{children:"local-trusted"})," sandbox calls the ",(0,i.jsx)(t.code,{children:"System.allowDomain()"}),"\nmethod, scripting access is granted to any SWF loaded from the specified domain.\nThe analogous approach is not permitted from ",(0,i.jsx)(t.code,{children:"application"})," content in AIR\napplications, since it would grant unreasonable access unto the non-application\nfile into the user's file system. Remote files cannot directly access the\napplication sandbox, regardless of calls to the ",(0,i.jsx)(t.code,{children:"Security.allowDomain()"})," method."]}),"\n",(0,i.jsx)(t.h2,{id:"scripting-between-application-and-non-application-content",children:"Scripting between application and non-application content"}),"\n",(0,i.jsx)(t.p,{children:"AIR applications that script between application and non-application content\nhave more complex security arrangements. Files that are not in the application\nsandbox are only allowed to access the properties and methods of files in the\napplication sandbox through the use of a sandbox bridge. A sandbox bridge acts\nas a gateway between application content and non-application content, providing\nexplicit interaction between the two files. When used correctly, sandbox bridges\nprovide an extra layer of security, restricting non-application content from\naccessing object references that are part of application content."}),"\n",(0,i.jsx)(t.p,{children:"The benefit of sandbox bridges is best illustrated through example. Suppose an\nAIR music store application wants to provide an API to advertisers who want to\ncreate their own SWF files, with which the store application can then\ncommunicate. The store wants to provide advertisers with methods to look up\nartists and CDs from the store, but also wants to isolate some methods and\nproperties from the third-party SWF file for security reasons."}),"\n",(0,i.jsx)(t.p,{children:"A sandbox bridge can provide this functionality. By default, content loaded\nexternally into an AIR application at runtime does not have access to any\nmethods or properties in the main application. With a custom sandbox bridge\nimplementation, a developer can provide services to the remote content without\nexposing these methods or properties. Consider the sandbox bridge as a pathway\nbetween trusted and untrusted content, providing communication between loader\nand loadee content without exposing object references."}),"\n",(0,i.jsxs)(t.p,{children:["For more information on how to securely use sandbox bridges, see\n",(0,i.jsx)(t.a,{href:"/docs/development/security/air-security/scripting-between-content-in-different-domains",children:"Scripting between content in different domains"}),"."]}),"\n",(0,i.jsx)(t.h2,{id:"protection-against-dynamically-generating-unsafe-swf-content",children:"Protection against dynamically generating unsafe SWF content"}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"Loader.loadBytes()"})," method provides a way for an application to generate\nSWF content from a byte array. However, injection attacks on data loaded from\nremote sources could do severe damage when loading content. This is especially\ntrue when loading data into the application sandbox, where the generated SWF\ncontent can access the full set of AIR APIs."]}),"\n",(0,i.jsxs)(t.p,{children:["There are legitimate uses for using the ",(0,i.jsx)(t.code,{children:"loadBytes()"})," method without generating\nexecutable SWF code. You can use the ",(0,i.jsx)(t.code,{children:"loadBytes()"})," method to generate an image\ndata to control the timing of image display, for example. There are also\nlegitimate uses that ",(0,i.jsx)(t.em,{children:"do"})," rely on executing code, such as dynamic creation of\nSWF content for audio playback. In AIR, by default the ",(0,i.jsx)(t.code,{children:"loadBytes()"})," method does\n",(0,i.jsx)(t.em,{children:"not"})," let you load SWF content; it only allows you to load image content. In\nAIR, the ",(0,i.jsx)(t.code,{children:"loaderContext"})," property of the ",(0,i.jsx)(t.code,{children:"loadBytes()"})," method has an\n",(0,i.jsx)(t.code,{children:"allowLoadBytesCodeExecution"})," property, which you can set to ",(0,i.jsx)(t.code,{children:"true"})," to\nexplicitly allow the application to use ",(0,i.jsx)(t.code,{children:"loadBytes()"})," to load executable SWF\ncontent. The following code shows how to use this feature:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"var loader:Loader = new Loader();\nvar loaderContext:LoaderContext = new LoaderContext();\nloaderContext.allowLoadBytesCodeExecution = true;\nloader.loadBytes(bytes, loaderContext);\n"})}),"\n",(0,i.jsxs)(t.p,{children:["If you call ",(0,i.jsx)(t.code,{children:"loadBytes()"})," to load SWF content and the\n",(0,i.jsx)(t.code,{children:"allowLoadBytesCodeExecution"})," property of the LoaderContext object is set to\n",(0,i.jsx)(t.code,{children:"false"})," (the default), the Loader object throws a SecurityError exception."]}),"\n",(0,i.jsxs)(t.p,{children:["Note: In a future release of Adobe AIR, this API may change. When that occurs,\nyou may need to recompile content that uses the ",(0,i.jsx)(t.code,{children:"allowLoadBytesCodeExecution"}),"\nproperty of the LoaderContext class."]})]})}function p(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}}}]);