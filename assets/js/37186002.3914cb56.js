"use strict";(self.webpackChunkairsdk_dev=self.webpackChunkairsdk_dev||[]).push([[12258],{28453:(t,e,n)=>{n.d(e,{R:()=>a,x:()=>r});var i=n(96540);const o={},s=i.createContext(o);function a(t){const e=i.useContext(s);return i.useMemo((function(){return"function"==typeof t?t(e):{...e,...t}}),[e,t])}function r(t){let e;return e=t.disableParentContext?"function"==typeof t.components?t.components(o):t.components||o:a(t.components),i.createElement(s.Provider,{value:e},t.children)}},31482:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>d,contentTitle:()=>r,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"development/user-interaction/keyboard-input/virtual-keyboards/adding-virtual-keyboard-support-for-interactive-objects","title":"Adding virtual keyboard support for interactive objects","description":"Normally, the virtual keyboard only opens when a TextField object is tapped. You","source":"@site/docs/development/user-interaction/keyboard-input/virtual-keyboards/adding-virtual-keyboard-support-for-interactive-objects.md","sourceDirName":"development/user-interaction/keyboard-input/virtual-keyboards","slug":"/development/user-interaction/keyboard-input/virtual-keyboards/adding-virtual-keyboard-support-for-interactive-objects","permalink":"/docs/development/user-interaction/keyboard-input/virtual-keyboards/adding-virtual-keyboard-support-for-interactive-objects","draft":false,"unlisted":false,"editUrl":"https://github.com/airsdk/airsdk.dev/edit/main/docs/development/user-interaction/keyboard-input/virtual-keyboards/adding-virtual-keyboard-support-for-interactive-objects.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"mainSidebar","previous":{"title":"Controlling virtual keyboard behavior","permalink":"/docs/development/user-interaction/keyboard-input/virtual-keyboards/controlling-virtual-keyboard-behavior"},"next":{"title":"Handling application display changes","permalink":"/docs/development/user-interaction/keyboard-input/virtual-keyboards/handling-application-display-changes"}}');var o=n(74848),s=n(28453);const a={sidebar_position:2},r="Adding virtual keyboard support for interactive objects",d={},l=[];function c(t){const e={code:"code",h1:"h1",header:"header",p:"p",pre:"pre",...(0,s.R)(),...t.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.header,{children:(0,o.jsx)(e.h1,{id:"adding-virtual-keyboard-support-for-interactive-objects",children:"Adding virtual keyboard support for interactive objects"})}),"\n",(0,o.jsx)(e.p,{children:"Normally, the virtual keyboard only opens when a TextField object is tapped. You\ncan configure an instance of the InteractiveObject class to open the virtual\nkeyboard when it receives focus."}),"\n",(0,o.jsxs)(e.p,{children:["To configure an InteractiveObject instance to open the soft keyboard, set its\n",(0,o.jsx)(e.code,{children:"needsSoftKeyboard"})," property to ",(0,o.jsx)(e.code,{children:"true"}),". Whenever the object is assigned to the\nstage focus property, the soft keyboard automatically opens. In addition, you\ncan raise the keyboard by calling the ",(0,o.jsx)(e.code,{children:"requestSoftKeyboard()"})," method of the\nInteractiveObject."]}),"\n",(0,o.jsxs)(e.p,{children:["The following example illustrates how you can program an InteractiveObject to\nact as a text entry field. The TextInput class shown in the example sets the\n",(0,o.jsx)(e.code,{children:"needsSoftKeyboard"})," property so that the keyboard is raised when needed. The\nobject then listens for ",(0,o.jsx)(e.code,{children:"keyDown"})," events and inserts the typed character into\nthe field."]}),"\n",(0,o.jsx)(e.p,{children:"The example uses the Flash text engine to append and display any typed text and\nhandles some important events. For simplicity, the example does not implement a\nfull-featured text field."}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{children:'package  {\n\timport flash.geom.Rectangle;\n\timport flash.display.Sprite;\n\timport flash.text.engine.TextElement;\n\timport flash.text.engine.TextBlock;\n\timport flash.events.MouseEvent;\n\timport flash.events.FocusEvent;\n\timport flash.events.KeyboardEvent;\n\timport flash.text.engine.TextLine;\n\timport flash.text.engine.ElementFormat;\n\timport flash.events.Event;\n\n\tpublic class TextInput extends Sprite\n\t{\n\n\t\tpublic var text:String = " ";\n\t\tpublic  var textSize:Number = 24;\n\t\tpublic var textColor:uint = 0x000000;\n\t\tprivate var _bounds:Rectangle = new Rectangle( 0, 0, 100, textSize );\n\t\tprivate var textElement: TextElement;\n\t\tprivate var textBlock:TextBlock = new  TextBlock();\n\n\t\tpublic function TextInput( text:String = "" )\n\t\t{\n\t\t\tthis.text = text;\n\t\t\tthis.scrollRect = _bounds;\n\t\t\tthis.focusRect= false;\n\n\t\t\t//Enable keyboard support\n\t\t\tthis.needsSoftKeyboard = true;\n\t\t\tthis.addEventListener(MouseEvent.MOUSE_DOWN, onSelect);\n\t\t\tthis.addEventListener(FocusEvent.FOCUS_IN, onFocusIn);\n\t\t\tthis.addEventListener(FocusEvent.FOCUS_OUT, onFocusOut);\n\n\t\t\t//Setup text engine\n\t\t\ttextElement = new TextElement( text, new ElementFormat( null, textSize, textColor ) );\n\t\t\ttextBlock.content = textElement;\n\t\t\tvar firstLine:TextLine = textBlock.createTextLine( null, _bounds.width - 8 );\n\t\t\tfirstLine.x = 4;\n\t\t\tfirstLine.y = 4 + firstLine.totalHeight;\n\t\t\tthis.addChild( firstLine );\n\n\t\t}\n\n\t\tprivate function onSelect( event:MouseEvent ):void\n\t\t{\n\t\t\tstage.focus = this;\n\t\t}\n\t\tprivate function onFocusIn( event:FocusEvent ):void\n\t\t{\n\t\t\tthis.addEventListener( KeyboardEvent.KEY_DOWN, onKey );\n\t\t}\n\n\t\tprivate function onFocusOut( event:FocusEvent ):void\n\t\t{\n\t\t\tthis.removeEventListener( KeyboardEvent.KEY_UP, onKey );\n\t\t}\n\n\t\tprivate function onKey( event:KeyboardEvent ):void\n\t\t{\n\t\t\ttextElement.replaceText( textElement.text.length, textElement.text.length, String.fromCharCode( event.charCode ) );\n\t\t\tupdateText();\n\t\t}\n\t\tpublic function set bounds( newBounds:Rectangle ):void\n\t\t{\n\t\t\t_bounds = newBounds.clone();\n\t\t\tdrawBackground();\n\t\t\tupdateText();\n\t\t\tthis.scrollRect = _bounds;\n\n\t\t\t//force update to focus rect, if needed\n\t\t\tif( this.stage!= null && this.focusRect && this.stage.focus == this )\n\t\t\t\tthis.stage.focus = this;\n\t\t}\n\n\t\tprivate function updateText():void\n\t\t{\n\t\t\t//clear text lines\n\t\t\twhile( this.numChildren > 0 ) this.removeChildAt( 0 );\n\n\t\t\t//and recreate them\n\t\t\tvar textLine:TextLine = textBlock.createTextLine( null, _bounds.width - 8);\n\t\t\twhile ( textLine)\n\t\t\t{\n\t\t\t\ttextLine.x = 4;\n\t\t\t\tif( textLine.previousLine != null )\n\t\t\t\t{\n\t\t\t\t\ttextLine.y = textLine.previousLine.y +\n\t\t\t\t\t\t\t\ttextLine.previousLine.totalHeight + 2;\n\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttextLine.y = 4 + textLine.totalHeight;\n\t\t\t\t}\n\t\t\t\tthis.addChild(textLine);\n\t\t\t\ttextLine = textBlock.createTextLine(textLine, _bounds.width - 8 );\n\t\t\t\t}\n\t\t}\n\n\t\tprivate function drawBackground():void\n\t\t{\n\t\t\t//draw background and border for the field\n\t\t\tthis.graphics.clear();\n\t\t\tthis.graphics.beginFill( 0xededed );\n\t\t\tthis.graphics.lineStyle( 1, 0x000000 );\n\t\t\tthis.graphics.drawRect( _bounds.x + 2, _bounds.y + 2, _bounds.width - 4, _bounds.height - 4);\n\t\t\tthis.graphics.endFill();\n\t\t}\n\t}\n}\n'})}),"\n",(0,o.jsx)(e.p,{children:"The following main application class illustrates how to use the TextInput class\nand manage the application layout when the keyboard is raised or the device\norientation changes. The main class creates a TextInput object and sets its\nbounds to fill the stage. The class adjusts the size of the TextInput object\nwhen either the soft keyboard is raised or the stage changes size. The class\nlistens for soft keyboard events from the TextInput object and resize events\nfrom the stage. Irrespective of the cause of the event, the application\ndetermines the visible area of the stage and resizes the input control to fill\nit. Naturally, in a real application, you would need a more sophisticated layout\nalgorithm."}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{children:'package  {\n\n\timport flash.display.MovieClip;\n\timport flash.events.SoftKeyboardEvent;\n\timport flash.geom.Rectangle;\n\timport flash.events.Event;\n\timport flash.display.StageScaleMode;\n\timport flash.display.StageAlign;\n\n\tpublic class CustomTextField extends MovieClip {\n\n\t\tprivate var customField:TextInput = new TextInput("Input text: ");\n\n\t\tpublic function CustomTextField() {\n\t\t\tthis.stage.scaleMode = StageScaleMode.NO_SCALE;\n\t\t\tthis.stage.align = StageAlign.TOP_LEFT;\n\t\t\tthis.addChild( customField );\n\t\t\tcustomField.bounds = new Rectangle( 0, 0, this.stage.stageWidth, this.stage.stageHeight );\n\n\t\t\t//track soft keyboard and stage resize events\n\t\t\tcustomField.addEventListener(SoftKeyboardEvent.SOFT_KEYBOARD_ACTIVATE, onDisplayAreaChange );\n\t\t\tcustomField.addEventListener(SoftKeyboardEvent.SOFT_KEYBOARD_DEACTIVATE, onDisplayAreaChange );\n\t\t\tthis.stage.addEventListener( Event.RESIZE, onDisplayAreaChange );\n\t\t}\n\n\t\tprivate function onDisplayAreaChange( event:Event ):void\n\t\t{\n\t\t\t//Fill the stage if possible, but avoid the area covered by a keyboard\n\t\t\tvar desiredBounds = new Rectangle( 0, 0, this.stage.stageWidth, this.stage.stageHeight );\n\t\t\tif( this.stage.stageHeight - this.stage.softKeyboardRect.height < desiredBounds.height )\n\t\t\t\tdesiredBounds.height = this.stage.stageHeight - this.stage.softKeyboardRect.height;\n\n\t\t\tcustomField.bounds = desiredBounds;\n\t\t}\n\t}\n}\n'})}),"\n",(0,o.jsxs)(e.p,{children:["Note: The stage only dispatches resize events in response to an orientation\nchange when the ",(0,o.jsx)(e.code,{children:"scaleMode"})," property is set to ",(0,o.jsx)(e.code,{children:"noScale"}),". In other modes, the\ndimensions of the stage do not change; instead, the content is scaled to\ncompensate."]})]})}function h(t={}){const{wrapper:e}={...(0,s.R)(),...t.components};return e?(0,o.jsx)(e,{...t,children:(0,o.jsx)(c,{...t})}):c(t)}}}]);