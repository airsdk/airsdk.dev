"use strict";(self.webpackChunkairsdk_dev=self.webpackChunkairsdk_dev||[]).push([[55139],{28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>i});var r=t(96540);const s={},o=r.createContext(s);function a(e){const n=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),r.createElement(o.Provider,{value:n},e.children)}},85382:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>l,frontMatter:()=>a,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"development/client-system-interaction/using-workers-for-concurrency/understanding-workers-and-concurrency","title":"Understanding workers and concurrency","description":"When an application doesn\'t use workers, the application\'s code executes in a","source":"@site/docs/development/client-system-interaction/using-workers-for-concurrency/understanding-workers-and-concurrency.md","sourceDirName":"development/client-system-interaction/using-workers-for-concurrency","slug":"/development/client-system-interaction/using-workers-for-concurrency/understanding-workers-and-concurrency","permalink":"/docs/development/client-system-interaction/using-workers-for-concurrency/understanding-workers-and-concurrency","draft":false,"unlisted":false,"editUrl":"https://github.com/airsdk/airsdk.dev/edit/main/docs/development/client-system-interaction/using-workers-for-concurrency/understanding-workers-and-concurrency.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"mainSidebar","previous":{"title":"Using workers for concurrency","permalink":"/docs/development/client-system-interaction/using-workers-for-concurrency/"},"next":{"title":"Creating and managing workers","permalink":"/docs/development/client-system-interaction/using-workers-for-concurrency/creating-and-managing-workers"}}');var s=t(74848),o=t(28453);const a={sidebar_position:1},i="Understanding workers and concurrency",c={},d=[];function h(e){const n={code:"code",h1:"h1",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"understanding-workers-and-concurrency",children:"Understanding workers and concurrency"})}),"\n",(0,s.jsxs)(n.p,{children:["When an application doesn't use workers, the application's code executes in a\nsingle linear block of executing steps known as an execution ",(0,s.jsx)("span",{class:"dfn",children:"\nthread "}),". The thread executes the code that a developer writes. It also\nexecutes much of the code that's part of the runtime, most notably the code that\nupdates the screen when display objects' properties change. Although code is\nwritten in chunks as methods and classes, at run time the code executes one line\nat a time as though it were written in a single long series of steps. Consider\nthis hypothetical example of the steps that an application executes:"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["Enter frame: The runtime calls any ",(0,s.jsx)(n.code,{children:"enterFrame"})," event handlers and runs"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"their code one at a time\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"2",children:["\n",(0,s.jsx)(n.li,{children:"Mouse event: The user moves the mouse, and the runtime calls any mouse event"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"handlers as the various rollover and rollout events happen\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"3",children:["\n",(0,s.jsx)(n.li,{children:"Load complete event: A request to load an xml file from a url returns with"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"the loaded file data. The event handler is called and runs its steps,\nreading the xml content and creating a set of objects from the xml data.\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"4",children:["\n",(0,s.jsx)(n.li,{children:"Mouse event: The mouse has moved again, so the runtime calls the relevant"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"mouse event handlers\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"5",children:["\n",(0,s.jsx)(n.li,{children:"Rendering: No more events are waiting, so the runtime updates the screen"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"based on any changes made to display objects\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"6",children:["\n",(0,s.jsx)(n.li,{children:"Enter frame: The cycle begins again"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"As described in the example, the hypothetical steps 1-5 run in sequence within a\nsingle block of time called a frame. Because they run in sequence in a single\nthread, the runtime can't interrupt one step of the process to run another one.\nAt a frame rate of 30 frames-per-second, the runtime has less than one thirtieth\nof a second to execute all those operations. In many cases that is enough time\nfor the code to run, and the runtime simply waits during the remaining time.\nHowever, suppose the xml data that loads in step 3 is a very large, deeply\nnested xml structure. As the code loops over the xml and creates objects, it\nmight conceivably take longer than one thirtieth of a second to do that work. In\nthat case, the later steps (responding to the mouse and redrawing the screen) do\nnot happen as soon as they should. This causes the screen to freeze and stutter\nas the screen isn't redrawn fast enough in response to the user moving the\nmouse."}),"\n",(0,s.jsx)(n.p,{children:"If all the code executes in the same thread, there is only one way to avoid\noccasional stutters and freezes. This is to not do long-running operations such\nas looping over a large set of data. ActionScript workers provide another\nsolution. Using a worker, you can execute long-running code in a separate\nworker. Each worker runs in a separate thread, so the background worker performs\nthe long-running operation in its own thread. That frees up the main worker's\nexecution thread to redraw the screen each frame without being blocked by other\nwork."}),"\n",(0,s.jsxs)(n.p,{children:["The ability to run multiple code operations at the same time in this way is\nknown as ",(0,s.jsx)("span",{class:"dfn",children:" concurrency "}),'. When the background worker\nfinishes its work, or at "progress" points along the way, you can send the main\nworker notifications and data. In this way, you can write code that performs\ncomplex or time consuming operations but avoid the bad user experience of having\nthe screen freeze.']}),"\n",(0,s.jsx)(n.p,{children:"Workers are useful because they decrease the chances of the frame rate dropping\ndue to the main rendering thread being blocked by other code. However, workers\nrequire additional system memory and CPU use, which can be costly to overall\napplication performance. Because each worker uses its own instance of the\nruntime virtual machine, even the overhead of a trivial worker can be large.\nWhen using workers, test your code across all your target platforms to ensure\nthat the demands on the system are not too large. Adobe recommends that you do\nnot use more than one or two background workers in a typical scenario."})]})}function l(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}}}]);