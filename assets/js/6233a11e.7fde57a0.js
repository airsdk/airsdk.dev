"use strict";(self.webpackChunkairsdk_dev=self.webpackChunkairsdk_dev||[]).push([[97757],{28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>d});var s=t(96540);const r={},a=s.createContext(r);function o(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),s.createElement(a.Provider,{value:n},e.children)}},52569:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>i,contentTitle:()=>d,default:()=>l,frontMatter:()=>o,metadata:()=>s,toc:()=>h});const s=JSON.parse('{"id":"development/display/working-with-pixel-bender-shaders/using-a-shader-in-stand-alone-mode","title":"Using a shader in stand-alone mode","description":"When you use a shader in stand-alone mode, the shader processing runs","source":"@site/docs/development/display/working-with-pixel-bender-shaders/using-a-shader-in-stand-alone-mode.md","sourceDirName":"development/display/working-with-pixel-bender-shaders","slug":"/development/display/working-with-pixel-bender-shaders/using-a-shader-in-stand-alone-mode","permalink":"/docs/development/display/working-with-pixel-bender-shaders/using-a-shader-in-stand-alone-mode","draft":false,"unlisted":false,"editUrl":"https://github.com/airsdk/airsdk.dev/edit/main/docs/development/display/working-with-pixel-bender-shaders/using-a-shader-in-stand-alone-mode.md","tags":[],"version":"current","frontMatter":{},"sidebar":"mainSidebar","previous":{"title":"Using a shader as a filter","permalink":"/docs/development/display/working-with-pixel-bender-shaders/using-a-shader-as-a-filter"},"next":{"title":"Using a shader","permalink":"/docs/development/display/working-with-pixel-bender-shaders/using-a-shader"}}');var r=t(74848),a=t(28453);const o={},d="Using a shader in stand-alone mode",i={},h=[];function c(e){const n={code:"code",h1:"h1",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"using-a-shader-in-stand-alone-mode",children:"Using a shader in stand-alone mode"})}),"\n",(0,r.jsx)(n.p,{children:"When you use a shader in stand-alone mode, the shader processing runs\nindependent of how you intend to use the output. You specify a shader to\nexecute, set input and parameter values, and designate an object into which the\nresult data is placed. You can use a shader in stand-alone mode for two reasons:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Processing non-image data: In stand-alone mode, you can choose to pass\narbitrary binary or number data to the shader rather than bitmap image data.\nYou can choose to have the shader result be returned as binary data or number\ndata in addition to bitmap image data."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Background processing: When you run a shader in stand-alone mode, by default\nthe shader executes asynchronously. This means that the shader runs in the\nbackground while your application continues to run, and your code is notified\nwhen the shader processing finishes. You can use a shader that takes a long\ntime to run and it doesn't freeze up the application user interface or other\nprocessing while the shader is running."}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"You use a ShaderJob object to execute a shader in stand-alone mode. First you\ncreate the ShaderJob object and link it to the Shader object representing the\nshader to execute:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"var job:ShaderJob = new ShaderJob(myShader);\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Next, you set any input or parameter values that the shader expects. If you are\nexecuting the shader in the background, you also register a listener for the\nShaderJob object's ",(0,r.jsx)(n.code,{children:"complete"})," event. Your listener is called when the shader\nfinishes its work:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"function completeHandler(event:ShaderEvent):void\n{\n"})}),"\n",(0,r.jsx)(n.p,{children:"// do something with the shader result"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"}\n\njob.addEventListener(ShaderEvent.COMPLETE, completeHandler);\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Next, you create an object into which the shader operation result is written\nwhen the operation finishes. You assign that object to the ShaderJob object's\n",(0,r.jsx)(n.code,{children:"target"})," property:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"var jobResult:BitmapData = new BitmapData(100, 75);\njob.target = jobResult;\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Assign a BitmapData instance to the ",(0,r.jsx)(n.code,{children:"target"})," property if you are using the\nShaderJob to perform image processing. If you are processing binary or number\ndata, assign a ByteArray object or Vector.<Number> instance to the ",(0,r.jsx)(n.code,{children:"target"}),"\nproperty. In that case, you must set the ShaderJob object's ",(0,r.jsx)(n.code,{children:"width"})," and ",(0,r.jsx)(n.code,{children:"height"}),"\nproperties to specify the amount of data to output to the ",(0,r.jsx)(n.code,{children:"target"})," object."]}),"\n",(0,r.jsxs)(n.p,{children:["Note: You can set the ShaderJob object's ",(0,r.jsx)(n.code,{children:"shader"}),", ",(0,r.jsx)(n.code,{children:"target"}),", ",(0,r.jsx)(n.code,{children:"width"}),", and\n",(0,r.jsx)(n.code,{children:"height"})," properties in one step by passing arguments to the ",(0,r.jsx)(n.code,{children:"ShaderJob()"}),"\nconstructor, like this:\n",(0,r.jsx)(n.code,{children:"var job:ShaderJob = new ShaderJob(myShader, myTarget, myWidth, myHeight);"})]}),"\n",(0,r.jsxs)(n.p,{children:["When you are ready to execute the shader, you call the ShaderJob object's\n",(0,r.jsx)(n.code,{children:"start()"}),") method:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"job.start();\n"})}),"\n",(0,r.jsxs)(n.p,{children:["By default calling ",(0,r.jsx)(n.code,{children:"start()"})," causes the ShaderJob to execute asynchronously. In\nthat case program execution continues immediately with the next line of code\nrather than waiting for the shader to finish. When the shader operation\nfinishes, the ShaderJob object calls its ",(0,r.jsx)(n.code,{children:"complete"})," event listeners, notifying\nthem that it is done. At that point (that is, in the body of your ",(0,r.jsx)(n.code,{children:"complete"}),"\nevent listener) the ",(0,r.jsx)(n.code,{children:"target"})," object contains the shader operation result."]}),"\n",(0,r.jsxs)(n.p,{children:["Note: Instead of using the ",(0,r.jsx)(n.code,{children:"target"})," property object, you can retrieve the shader\nresult directly from the event object that's passed to your listener method. The\nevent object is a ShaderEvent instance. The ShaderEvent object has three\nproperties that can be used to access the result, depending on the data type of\nthe object you set as the ",(0,r.jsx)(n.code,{children:"target"})," property: ",(0,r.jsx)(n.code,{children:"ShaderEvent.bitmapData"}),",\n",(0,r.jsx)(n.code,{children:"ShaderEvent.byteArray"}),", and ",(0,r.jsx)(n.code,{children:"ShaderEvent.vector"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["Alternatively, you can pass a ",(0,r.jsx)(n.code,{children:"true"})," argument to the ",(0,r.jsx)(n.code,{children:"start()"})," method. In that\ncase the shader operation executes synchronously. All code (including\ninteraction with the user interface and any other events) pauses while the\nshader executes. When the shader finishes, the ",(0,r.jsx)(n.code,{children:"target"})," object contains the\nshader result and the program continues with the next line of code."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"job.start(true);\n"})})]})}function l(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}}}]);