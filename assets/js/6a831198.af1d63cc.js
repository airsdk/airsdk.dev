"use strict";(self.webpackChunkairsdk_dev=self.webpackChunkairsdk_dev||[]).push([[96254],{5407:(e,n,a)=>{a.d(n,{A:()=>t});const t=a.p+"assets/images/sb_drawing_fill_three_point_gradient-977c160d20354e15add2bc99e8c4a0c9.png"},28453:(e,n,a)=>{a.d(n,{R:()=>o,x:()=>s});var t=a(96540);const i={},r=t.createContext(i);function o(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),t.createElement(r.Provider,{value:n},e.children)}},72620:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>d,contentTitle:()=>s,default:()=>c,frontMatter:()=>o,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"development/display/working-with-pixel-bender-shaders/using-a-shader-as-a-drawing-fill","title":"Using a shader as a drawing fill","description":"When you use a shader to create a drawing fill, you use the drawing api methods","source":"@site/docs/development/display/working-with-pixel-bender-shaders/using-a-shader-as-a-drawing-fill.md","sourceDirName":"development/display/working-with-pixel-bender-shaders","slug":"/development/display/working-with-pixel-bender-shaders/using-a-shader-as-a-drawing-fill","permalink":"/docs/development/display/working-with-pixel-bender-shaders/using-a-shader-as-a-drawing-fill","draft":false,"unlisted":false,"editUrl":"https://github.com/airsdk/airsdk.dev/edit/main/docs/development/display/working-with-pixel-bender-shaders/using-a-shader-as-a-drawing-fill.md","tags":[],"version":"current","frontMatter":{},"sidebar":"mainSidebar","previous":{"title":"Using a shader as a blend mode","permalink":"/docs/development/display/working-with-pixel-bender-shaders/using-a-shader-as-a-blend-mode"},"next":{"title":"Using a shader as a filter","permalink":"/docs/development/display/working-with-pixel-bender-shaders/using-a-shader-as-a-filter"}}');var i=a(74848),r=a(28453);const o={},s="Using a shader as a drawing fill",d={},l=[];function h(e){const n={a:"a",code:"code",h1:"h1",header:"header",img:"img",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"using-a-shader-as-a-drawing-fill",children:"Using a shader as a drawing fill"})}),"\n",(0,i.jsxs)(n.p,{children:["When you use a shader to create a drawing fill, you use the drawing api methods\nto create a vector shape. The shader's output is used to fill in the shape, in\nthe same way that any bitmap image can be used as a bitmap fill with the drawing\napi. To create a shader fill, at the point in your code at which you want to\nstart drawing the shape, call the Graphics object's ",(0,i.jsx)(n.code,{children:"beginShaderFill()"})," method.\nPass the Shader object as the first argument to the ",(0,i.jsx)(n.code,{children:"beginShaderFill()"})," method,\nas shown in this listing:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"var canvas:Sprite = new Sprite();\ncanvas.graphics.beginShaderFill(myShader);\ncanvas.graphics.drawRect(10, 10, 150, 150);\ncanvas.graphics.endFill();\n// add canvas to the display list to see the result\n"})}),"\n",(0,i.jsx)(n.p,{children:"When you use a shader as a drawing fill, you set any input image values and\nparameter values that the shader requires."}),"\n",(0,i.jsx)(n.p,{children:"The following example demonstrates using a shader as a drawing fill. In this\nexample, the shader creates a three-point gradient. This gradient has three\ncolors, each at the point of a triangle, with a gradient blend between them. In\naddition, the colors rotate to create an animated spinning color effect."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:a(5407).A+"",width:"280",height:"281"})}),"\n",(0,i.jsxs)(n.p,{children:["Note: The code for this example was written by Petri Leskinen. Thank you Petri\nfor sharing this example. You can see more of Petri's examples and tutorials at\n",(0,i.jsx)(n.a,{href:"http://pixelero.wordpress.com/",children:"http://pixelero.wordpress.com/"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"The ActionScript code is in three methods:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"init()"}),": The ",(0,i.jsx)(n.code,{children:"init()"})," method is called when the application loads. In this\nmethod the code sets the initial values for the Point objects representing the\npoints of the triangle. The also code creates a Sprite instance named\n",(0,i.jsx)(n.code,{children:"canvas"}),". Later, in the ",(0,i.jsx)(n.code,{children:"updateShaderFill()"}),", the code draws the shader result\ninto ",(0,i.jsx)(n.code,{children:"canvas"})," once per frame. Finally, the code loads the shader bytecode\nfile."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"onLoadComplete()"}),": In the ",(0,i.jsx)(n.code,{children:"onLoadComplete()"})," method the code creates the\nShader object named ",(0,i.jsx)(n.code,{children:"shader"}),". It also sets the initial parameter values.\nFinally, the code adds the ",(0,i.jsx)(n.code,{children:"updateShaderFill()"})," method as a listener for the\n",(0,i.jsx)(n.code,{children:"enterFrame"})," event, meaning that it is called once per frame to create an\nanimation effect."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"updateShaderFill()"}),": The ",(0,i.jsx)(n.code,{children:"updateShaderFill()"})," method is called once per\nframe, creating the animation effect. In this method, the code calculates and\nsets the shader parameters' values. The code then calls the\n",(0,i.jsx)(n.code,{children:"beginShaderFill()"})," method to create a shader fill and calls other drawing api\nmethods to draw the shader result in a triangle."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"The following is the ActionScript code for this example. Use this class as the\nmain application class for an ActionScript-only project in Flash Builder, or as\nthe document class for a FLA file in Flash Professional:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'package\n{\n    import flash.display.Shader;\n    import flash.display.Sprite;\n    import flash.events.Event;\n    import flash.geom.Point;\n    import flash.net.URLLoader;\n    import flash.net.URLLoaderDataFormat;\n    import flash.net.URLRequest;\n\n    public class ThreePointGradient extends Sprite\n    {\n        private var canvas:Sprite;\n        private var shader:Shader;\n        private var loader:URLLoader;\n\n        private var topMiddle:Point;\n        private var bottomLeft:Point;\n        private var bottomRight:Point;\n\n        private var colorAngle:Number = 0.0;\n        private const d120:Number = 120 / 180 * Math.PI; // 120 degrees in radians\n\n\n        public function ThreePointGradient()\n        {\n            init();\n        }\n\n        private function init():void\n        {\n            canvas = new Sprite();\n            addChild(canvas);\n\n            var size:int = 400;\n            topMiddle = new Point(size / 2, 10);\n            bottomLeft = new Point(0, size - 10);\n            bottomRight = new Point(size, size - 10);\n\n            loader = new URLLoader();\n            loader.dataFormat = URLLoaderDataFormat.BINARY;\n            loader.addEventListener(Event.COMPLETE, onLoadComplete);\n            loader.load(new URLRequest("ThreePointGradient.pbj"));\n        }\n\n        private function onLoadComplete(event:Event):void\n        {\n            shader = new Shader(loader.data);\n\n            shader.data.point1.value = [topMiddle.x, topMiddle.y];\n            shader.data.point2.value = [bottomLeft.x, bottomLeft.y];\n            shader.data.point3.value = [bottomRight.x, bottomRight.y];\n\n            addEventListener(Event.ENTER_FRAME, updateShaderFill);\n        }\n\n        private function updateShaderFill(event:Event):void\n        {\n            colorAngle += .06;\n\n            var c1:Number = 1 / 3 + 2 / 3 * Math.cos(colorAngle);\n            var c2:Number = 1 / 3 + 2 / 3 * Math.cos(colorAngle + d120);\n            var c3:Number = 1 / 3 + 2 / 3 * Math.cos(colorAngle - d120);\n\n            shader.data.color1.value = [c1, c2, c3, 1.0];\n            shader.data.color2.value = [c3, c1, c2, 1.0];\n            shader.data.color3.value = [c2, c3, c1, 1.0];\n\n            canvas.graphics.clear();\n            canvas.graphics.beginShaderFill(shader);\n\n            canvas.graphics.moveTo(topMiddle.x, topMiddle.y);\n            canvas.graphics.lineTo(bottomLeft.x, bottomLeft.y);\n            canvas.graphics.lineTo(bottomRight.x, bottomLeft.y);\n\n            canvas.graphics.endFill();\n        }\n    }\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:'The following is the source code for the ThreePointGradient shader kernel, used\nto create the "ThreePointGradient.pbj" Pixel Bender bytecode file:'}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'<languageVersion : 1.0;>\nkernel ThreePointGradient\n<\nnamespace : "Petri Leskinen::Example";\nvendor : "Petri Leskinen";\nversion : 1;\ndescription : "Creates a gradient fill using three specified points and colors.";\n    >\n{\n\n    parameter float2 point1 // coordinates of the first point\n    <\n        minValue:float2(0, 0);\n        maxValue:float2(4000, 4000);\n        defaultValue:float2(0, 0);\n    >;\n\n    parameter float4 color1 // color at the first point, opaque red by default\n    <\n        defaultValue:float4(1.0, 0.0, 0.0, 1.0);\n    >;\n\n    parameter float2 point2 // coordinates of the second point\n    <\n        minValue:float2(0, 0);\n        maxValue:float2(4000, 4000);\n        defaultValue:float2(0, 500);\n    >;\n\n    parameter float4 color2 // color at the second point, opaque green by default\n    <\n        defaultValue:float4(0.0, 1.0, 0.0, 1.0);\n    >;\n\n    parameter float2 point3 // coordinates of the third point\n    <\n        minValue:float2(0, 0);\n        maxValue:float2(4000, 4000);\n        defaultValue:float2(0, 500);\n    >;\n\n    parameter float4 color3 // color at the third point, opaque blue by default\n    <\n        defaultValue:float4(0.0, 0.0, 1.0, 1.0);\n    >;\n\n    output pixel4 dst;\n\n    void evaluatePixel()\n    {\n        float2 d2 = point2 - point1;\n        float2 d3 = point3 - point1;\n\n        // transformation to a new coordinate system\n        // transforms point 1 to origin, point2 to (1, 0), and point3 to (0, 1)\n        float2x2 mtrx = float2x2(d3.y, -d2.y, -d3.x, d2.x) / (d2.x * d3.y - d3.x * d2.y);\n        float2 pNew = mtrx * (outCoord() - point1);\n\n        // repeat the edge colors on the outside\n        pNew.xy = clamp(pNew.xy, 0.0, 1.0); // set the range to 0.0 ... 1.0\n\n        // interpolating the output color or alpha value\n        dst = mix(mix(color1, color2, pNew.x), color3, pNew.y);\n    }\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"Note: If you use a shader fill when rendering under the graphics processing unit\n(GPU), the filled area will be colored cyan."}),"\n",(0,i.jsxs)(n.p,{children:["For more information about drawing shapes using the drawing api, see\n",(0,i.jsx)(n.a,{href:"/docs/development/display/using-the-drawing-api/",children:"Using the drawing API"}),"."]})]})}function c(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}}}]);