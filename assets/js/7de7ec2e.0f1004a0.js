"use strict";(self.webpackChunkairsdk_dev=self.webpackChunkairsdk_dev||[]).push([[27877],{28453:(e,t,a)=>{a.d(t,{R:()=>r,x:()=>o});var n=a(96540);const i={},s=n.createContext(i);function r(e){const t=n.useContext(s);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),n.createElement(s.Provider,{value:t},e.children)}},66696:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>n,toc:()=>d});const n=JSON.parse('{"id":"development/display/working-with-bitmaps/manipulating-pixels","title":"Manipulating pixels","description":"The BitmapData class contains a set of methods that allow you to manipulate","source":"@site/docs/development/display/working-with-bitmaps/manipulating-pixels.md","sourceDirName":"development/display/working-with-bitmaps","slug":"/development/display/working-with-bitmaps/manipulating-pixels","permalink":"/docs/development/display/working-with-bitmaps/manipulating-pixels","draft":false,"unlisted":false,"editUrl":"https://github.com/airsdk/airsdk.dev/edit/main/docs/development/display/working-with-bitmaps/manipulating-pixels.md","tags":[],"version":"current","frontMatter":{},"sidebar":"mainSidebar","previous":{"title":"Making textures with noise functions","permalink":"/docs/development/display/working-with-bitmaps/making-textures-with-noise-functions"},"next":{"title":"Scrolling bitmaps","permalink":"/docs/development/display/working-with-bitmaps/scrolling-bitmaps"}}');var i=a(74848),s=a(28453);const r={},o="Manipulating pixels",l={},d=[{value:"Manipulating individual pixels",id:"manipulating-individual-pixels",level:2},{value:"Pixel-level collision detection",id:"pixel-level-collision-detection",level:2}];function p(e){const t={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"manipulating-pixels",children:"Manipulating pixels"})}),"\n",(0,i.jsx)(t.p,{children:"The BitmapData class contains a set of methods that allow you to manipulate\npixel data values."}),"\n",(0,i.jsx)(t.h2,{id:"manipulating-individual-pixels",children:"Manipulating individual pixels"}),"\n",(0,i.jsxs)(t.p,{children:["When changing the appearance of a bitmap image at a pixel level, you first need\nto get the color values of the pixels contained within the area you wish to\nmanipulate. You use the ",(0,i.jsx)(t.code,{children:"getPixel()"})," method to read these pixel values."]}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"getPixel()"})," method retrieves an RGB value from a set of x, y (pixel)\ncoordinates that are passed as a parameter. If any of the pixels that you want\nto manipulate include transparency (alpha channel) information, you need to use\nthe ",(0,i.jsx)(t.code,{children:"getPixel32()"})," method. This method also retrieves an RGB value, but unlike\nwith ",(0,i.jsx)(t.code,{children:"getPixel()"}),", the value returned by ",(0,i.jsx)(t.code,{children:"getPixel32()"})," contains additional data\nthat represents the alpha channel (transparency) value of the selected pixel."]}),"\n",(0,i.jsxs)(t.p,{children:["Alternatively, if you simply want to change the color or transparency of a pixel\ncontained within a bitmap, you can use the ",(0,i.jsx)(t.code,{children:"setPixel()"})," or ",(0,i.jsx)(t.code,{children:"setPixel32()"}),"\nmethod. To set a pixel's color, simply pass in the x, y coordinates and the\ncolor value to one of these methods."]}),"\n",(0,i.jsxs)(t.p,{children:["The following example uses ",(0,i.jsx)(t.code,{children:"setPixel()"})," to draw a cross on a green BitmapData\nbackground. It then uses ",(0,i.jsx)(t.code,{children:"getPixel()"})," to retrieve the color value from the pixel\nat the coordinate 50, 50 and traces the returned value."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"import flash.display.Bitmap;\nimport flash.display.BitmapData;\n\nvar myBitmapData:BitmapData = new BitmapData(100, 100, false, 0x009900);\n\nfor (var i:uint = 0; i < 100; i++)\n{\n"})}),"\n",(0,i.jsxs)(t.p,{children:["var red",":uint"," = 0xFF0000;\nmyBitmapData.setPixel(50, i, red);\nmyBitmapData.setPixel(i, 50, red);"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"}\n\nvar myBitmapImage:Bitmap = new Bitmap(myBitmapData);\naddChild(myBitmapImage);\n\nvar pixelValue:uint = myBitmapData.getPixel(50, 50);\ntrace(pixelValue.toString(16));\n"})}),"\n",(0,i.jsxs)(t.p,{children:["If you want to read the value of a group of pixels, as opposed to a single\npixel, use the ",(0,i.jsx)(t.code,{children:"getPixels()"})," method. This method generates a byte array from a\nrectangular region of pixel data that is passed as a parameter. Each of the\nelements of the byte array (in other words, the pixel values) are unsigned\nintegers\u201432-bit, unmultiplied pixel values."]}),"\n",(0,i.jsxs)(t.p,{children:["Conversely, to change (or set) the value of a group of pixels, use the\n",(0,i.jsx)(t.code,{children:"setPixels()"})," method. This method expects two parameters (",(0,i.jsx)(t.code,{children:"rect"})," and\n",(0,i.jsx)(t.code,{children:"inputByteArray"}),"), which are combined to output a rectangular region (",(0,i.jsx)(t.code,{children:"rect"}),") of\npixel data (",(0,i.jsx)(t.code,{children:"inputByteArray"}),")."]}),"\n",(0,i.jsxs)(t.p,{children:["As data is read (and written) out of the ",(0,i.jsx)(t.code,{children:"inputByteArray"}),", the\n",(0,i.jsx)(t.code,{children:"ByteArray.readUnsignedInt()"})," method is called for each of the pixels in the\narray. If, for some reason, the ",(0,i.jsx)(t.code,{children:"inputByteArray"})," doesn't contain a full\nrectangle worth of pixel data, the method stops processing the image data at\nthat point."]}),"\n",(0,i.jsx)(t.p,{children:"It's important to remember that, for both getting and setting pixel data, the\nbyte array expects 32-bit alpha, red, green, blue (ARGB) pixel values."}),"\n",(0,i.jsxs)(t.p,{children:["The following example uses the ",(0,i.jsx)(t.code,{children:"getPixels()"})," and ",(0,i.jsx)(t.code,{children:"setPixels()"})," methods to copy a\ngroup of pixels from one BitmapData object to another:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"import flash.display.Bitmap;\nimport flash.display.BitmapData;\nimport flash.utils.ByteArray;\nimport flash.geom.Rectangle;\n\nvar bitmapDataObject1:BitmapData = new BitmapData(100, 100, false, 0x006666FF);\nvar bitmapDataObject2:BitmapData = new BitmapData(100, 100, false, 0x00FF0000);\n\nvar rect:Rectangle = new Rectangle(0, 0, 100, 100);\nvar bytes:ByteArray = bitmapDataObject1.getPixels(rect);\n\nbytes.position = 0;\nbitmapDataObject2.setPixels(rect, bytes);\n\nvar bitmapImage1:Bitmap = new Bitmap(bitmapDataObject1);\naddChild(bitmapImage1);\nvar bitmapImage2:Bitmap = new Bitmap(bitmapDataObject2);\naddChild(bitmapImage2);\nbitmapImage2.x = 110;\n"})}),"\n",(0,i.jsx)(t.h2,{id:"pixel-level-collision-detection",children:"Pixel-level collision detection"}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"BitmapData.hitTest()"})," method performs pixel-level collision detection\nbetween the bitmap data and another object or point."]}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"BitmapData.hitTest()"})," method accepts five parameters:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"firstPoint"})," (Point): This parameter refers to the pixel position of the\nupper-left corner of the first BitmapData upon which the hit test is being\nperformed."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"firstAlphaThreshold"})," (uint): This parameter specifies the highest alpha\nchannel value that is considered opaque for this hit test."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"secondObject"})," (Object): This parameter represents the area of impact. The\n",(0,i.jsx)(t.code,{children:"secondObject"})," object can be a Rectangle, Point, Bitmap, or BitmapData object.\nThis object represents the hit area on which the collision detection is being\nperformed."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"secondBitmapDataPoint"})," (Point): This optional parameter is used to define a\npixel location in the second BitmapData object. This parameter is used only\nwhen the value of ",(0,i.jsx)(t.code,{children:"secondObject"})," is a BitmapData object. The default is\n",(0,i.jsx)(t.code,{children:"null"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"secondAlphaThreshold"})," (uint): This optional parameter represents the highest\nalpha channel value that is considered opaque in the second BitmapData object.\nThe default value is 1. This parameter is only used when the value of\n",(0,i.jsx)(t.code,{children:"secondObject"})," is a BitmapData object and both BitmapData objects are\ntransparent."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"When performing collision detection on opaque images, keep in mind that\nActionScript treats the image as though it were a fully opaque rectangle (or\nbounding box). Alternatively, when performing pixel-level hit testing on images\nthat are transparent, both of the images are required to be transparent. In\naddition to this, ActionScript uses the alpha threshold parameters to determine\nat what point the pixels change from being transparent to opaque."}),"\n",(0,i.jsx)(t.p,{children:"The following example creates three bitmap images and checks for pixel collision\nusing two different collision points (one returns false, the other true):"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"import flash.display.Bitmap;\nimport flash.display.BitmapData;\nimport flash.geom.Point;\n\nvar bmd1:BitmapData = new BitmapData(100, 100, false, 0x000000FF);\nvar bmd2:BitmapData = new BitmapData(20, 20, false, 0x00FF3300);\n\nvar bm1:Bitmap = new Bitmap(bmd1);\nthis.addChild(bm1);\n\n// Create a red square.\nvar redSquare1:Bitmap = new Bitmap(bmd2);\nthis.addChild(redSquare1);\nredSquare1.x = 0;\n\n// Create a second red square.\nvar redSquare2:Bitmap = new Bitmap(bmd2);\nthis.addChild(redSquare2);\nredSquare2.x = 150;\nredSquare2.y = 150;\n\n// Define the point at the top-left corner of the bitmap.\nvar pt1:Point = new Point(0, 0);\n// Define the point at the center of redSquare1.\nvar pt2:Point = new Point(20, 20);\n// Define the point at the center of redSquare2.\nvar pt3:Point = new Point(160, 160);\n\ntrace(bmd1.hitTest(pt1, 0xFF, pt2)); // true\ntrace(bmd1.hitTest(pt1, 0xFF, pt3)); // false\n"})})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(p,{...e})}):p(e)}}}]);