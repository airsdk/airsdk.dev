"use strict";(self.webpackChunkairsdk_dev=self.webpackChunkairsdk_dev||[]).push([[57861],{2962:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>n,toc:()=>d});const n=JSON.parse('{"id":"development/files-and-data/working-with-local-sql-databases-in-air/strategies-for-working-with-sql-databases","title":"Strategies for working with SQL databases","description":"There are various ways that an application can access and work with a local SQL","source":"@site/docs/development/files-and-data/working-with-local-sql-databases-in-air/strategies-for-working-with-sql-databases.md","sourceDirName":"development/files-and-data/working-with-local-sql-databases-in-air","slug":"/development/files-and-data/working-with-local-sql-databases-in-air/strategies-for-working-with-sql-databases","permalink":"/docs/development/files-and-data/working-with-local-sql-databases-in-air/strategies-for-working-with-sql-databases","draft":false,"unlisted":false,"editUrl":"https://github.com/airsdk/airsdk.dev/edit/main/docs/development/files-and-data/working-with-local-sql-databases-in-air/strategies-for-working-with-sql-databases.md","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"sidebar_position":6},"sidebar":"mainSidebar","previous":{"title":"Using encryption with SQL databases","permalink":"/docs/development/files-and-data/working-with-local-sql-databases-in-air/using-encryption-with-sql-databases"},"next":{"title":"Connecting to a database","permalink":"/docs/development/files-and-data/working-with-local-sql-databases-in-air/connecting-to-a-database"}}');var s=a(74848),i=a(28453);const o={sidebar_position:6},r="Strategies for working with SQL databases",c={},d=[{value:"Distributing a pre-populated database",id:"distributing-a-pre-populated-database",level:2},{value:"Best practices for working with local SQL databases",id:"best-practices-for-working-with-local-sql-databases",level:2},{value:"Pre-create database connections",id:"pre-create-database-connections",level:3},{value:"Reuse database connections",id:"reuse-database-connections",level:3},{value:"Favor asynchronous execution mode",id:"favor-asynchronous-execution-mode",level:3},{value:"Use separate SQL statements and don&#39;t change the SQLStatement&#39;s text property",id:"use-separate-sql-statements-and-dont-change-the-sqlstatements-text-property",level:3},{value:"Use statement parameters",id:"use-statement-parameters",level:3}];function l(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"strategies-for-working-with-sql-databases",children:"Strategies for working with SQL databases"})}),"\n",(0,s.jsx)(t.p,{children:"There are various ways that an application can access and work with a local SQL\ndatabase. The application design can vary in terms of how the application code\nis organized, the sequence and timing of how operations are performed, and so\non. The techniques you choose can have an impact on how easy it is to develop\nyour application. They can affect how easy it is to modify the application in\nfuture updates. They can also affect how well the application performs from the\nusers' perspective."}),"\n",(0,s.jsx)(t.h2,{id:"distributing-a-pre-populated-database",children:"Distributing a pre-populated database"}),"\n",(0,s.jsx)(t.p,{children:"When you use an AIR local SQL database in your application, the application\nexpects a database with a certain structure of tables, columns, and so forth.\nSome applications also expect certain data to be pre-populated in the database\nfile. One way to ensure that the database has the proper structure is to create\nthe database within the application code. When the application loads it checks\nfor the existence of its database file in a particular location. If the file\ndoesn't exist, the application executes a set of commands to create the database\nfile, create the database structure, and populate the tables with the initial\ndata."}),"\n",(0,s.jsx)(t.p,{children:"The code that creates the database and its tables is frequently complex. It is\noften only used once in the installed lifetime of the application, but still\nadds to the size and complexity of the application. As an alternative to\ncreating the database, structure, and data programmatically, you can distribute\na pre-populated database with your application. To distribute a predefined\ndatabase, include the database file in the application's AIR package."}),"\n",(0,s.jsxs)(t.p,{children:["Like all files that are included in an AIR package, a bundled database file is\ninstalled in the application directory (the directory represented by the\n",(0,s.jsx)(t.code,{children:"File.applicationDirectory"}),' property). However, files in that directory are read\nonly. Use the file from the AIR package as a "template" database. The first time\na user runs the application, copy the original database file into the user\'s\n',(0,s.jsx)(t.a,{href:"/docs/development/files-and-data/working-with-the-file-system/using-the-air-file-system-api/working-with-file-objects-in-air#pointing-to-the-application-storage-directory",children:"Pointing to the application storage directory"}),"\n(or another location), and use that database within the application."]}),"\n",(0,s.jsx)(t.h2,{id:"best-practices-for-working-with-local-sql-databases",children:"Best practices for working with local SQL databases"}),"\n",(0,s.jsx)(t.p,{children:"The following list is a set of suggested techniques you can use to improve the\nperformance, security, and ease of maintenance of your applications when working\nwith local SQL databases."}),"\n",(0,s.jsx)(t.h3,{id:"pre-create-database-connections",children:"Pre-create database connections"}),"\n",(0,s.jsxs)(t.p,{children:["Even if your application doesn't execute any statements when it first loads,\ninstantiate a SQLConnection object and call its ",(0,s.jsx)(t.code,{children:"open()"})," or ",(0,s.jsx)(t.code,{children:"openAsync()"})," method\nahead of time (such as after the initial application startup) to avoid delays\nwhen running statements. See\n",(0,s.jsx)(t.a,{href:"/docs/development/files-and-data/working-with-local-sql-databases-in-air/connecting-to-a-database",children:"Connecting to a database"}),"."]}),"\n",(0,s.jsx)(t.h3,{id:"reuse-database-connections",children:"Reuse database connections"}),"\n",(0,s.jsxs)(t.p,{children:["If you access a certain database throughout the execution time of your\napplication, keep a reference to the SQLConnection instance, and reuse it\nthroughout the application, rather than closing and reopening the connection.\nSee ",(0,s.jsx)(t.a,{href:"/docs/development/files-and-data/working-with-local-sql-databases-in-air/connecting-to-a-database",children:"Connecting to a database"}),"."]}),"\n",(0,s.jsx)(t.h3,{id:"favor-asynchronous-execution-mode",children:"Favor asynchronous execution mode"}),"\n",(0,s.jsxs)(t.p,{children:["When writing data-access code, it can be tempting to execute operations\nsynchronously rather than asynchronously, because using synchronous operations\nfrequently requires shorter and less complex code. However, as described in\n",(0,s.jsx)(t.a,{href:"/docs/development/files-and-data/working-with-local-sql-databases-in-air/using-synchronous-and-asynchronous-database-operations/",children:"Using synchronous and asynchronous database operations"}),",\nsynchronous operations can have a performance impact that is obvious to users\nand detrimental to their experience with an application. The amount of time a\nsingle operation takes varies according to the operation and particularly the\namount of data it involves. For instance, a SQL ",(0,s.jsx)(t.code,{children:"INSERT"})," statement that only\nadds a single row to the database takes less time than a ",(0,s.jsx)(t.code,{children:"SELECT"})," statement that\nretrieves thousands of rows of data. However, when you're using synchronous\nexecution to perform multiple operations, the operations are usually strung\ntogether. Even if the time each single operation takes is very short, the\napplication is frozen until all the synchronous operations finish. As a result,\nthe cumulative time of multiple operations strung together may be enough to\nstall your application."]}),"\n",(0,s.jsxs)(t.p,{children:["Use asynchronous operations as a standard approach, especially with operations\nthat involve large numbers of rows. There is a technique for dividing up the\nprocessing of large sets of ",(0,s.jsx)(t.code,{children:"SELECT"})," statement results, described in\n",(0,s.jsx)(t.a,{href:"/docs/development/files-and-data/working-with-local-sql-databases-in-air/retrieving-data-from-a-database#retrieving-select-results-in-parts",children:"Retrieving SELECT results in parts"}),".\nHowever, this technique can only be used in asynchronous execution mode. Only\nuse synchronous operations when you can't achieve certain functionality using\nasynchronous programming, when you've considered the performance trade-off that\nyour application's users will face, and when you've tested your application so\nthat you know how your application's performance is affected. Using asynchronous\nexecution can involve more complex coding. However, remember that you only have\nto write the code once, but the application's users have to use it repeatedly,\nfast or slow."]}),"\n",(0,s.jsxs)(t.p,{children:["In many cases, by using a separate SQLStatement instance for each SQL statement\nto be executed, multiple SQL operations can be queued up at one time, which\nmakes asynchronous code like synchronous code in terms of how the code is\nwritten. For more information, see\n",(0,s.jsx)(t.a,{href:"/docs/development/files-and-data/working-with-local-sql-databases-in-air/using-synchronous-and-asynchronous-database-operations/understanding-the-asynchronous-execution-model",children:"Understanding the asynchronous execution model"}),"."]}),"\n",(0,s.jsx)(t.h3,{id:"use-separate-sql-statements-and-dont-change-the-sqlstatements-text-property",children:"Use separate SQL statements and don't change the SQLStatement's text property"}),"\n",(0,s.jsxs)(t.p,{children:["For any SQL statement that is executed more than once in an application, create\na separate SQLStatement instance for each SQL statement. Use that SQLStatement\ninstance each time that SQL command executes. For example, suppose you are\nbuilding an application that includes four different SQL operations that are\nperformed multiple times. In that case, create four separate SQLStatement\ninstances and call each statement's ",(0,s.jsx)(t.code,{children:"execute()"})," method to run it. Avoid the\nalternative of using a single SQLStatement instance for all SQL statements,\nredefining its ",(0,s.jsx)(t.code,{children:"text"})," property each time before executing the statement."]}),"\n",(0,s.jsx)(t.h3,{id:"use-statement-parameters",children:"Use statement parameters"}),"\n",(0,s.jsxs)(t.p,{children:["Use SQLStatement parameters\u2014never concatenate user input into statement text.\nUsing parameters makes your application more secure because it prevents the\npossibility of SQL injection attacks. It makes it possible to use objects in\nqueries (rather than only SQL literal values). It also makes statements run more\nefficiently because they can be reused without needing to be recompiled each\ntime they're executed. See\n",(0,s.jsx)(t.a,{href:"/docs/development/files-and-data/working-with-local-sql-databases-in-air/using-parameters-in-statements",children:"Using parameters in statements"})," for more\ninformation."]})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},28453:(e,t,a)=>{a.d(t,{R:()=>o,x:()=>r});var n=a(96540);const s={},i=n.createContext(s);function o(e){const t=n.useContext(i);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),n.createElement(i.Provider,{value:t},e.children)}}}]);