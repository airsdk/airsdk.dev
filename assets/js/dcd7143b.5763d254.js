"use strict";(globalThis.webpackChunkairsdk_dev=globalThis.webpackChunkairsdk_dev||[]).push([[41351],{28453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>i});var a=n(96540);const r={},s=a.createContext(r);function o(e){const t=a.useContext(s);return a.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),a.createElement(s.Provider,{value:t},e.children)}},32441:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"development/files-and-data/working-with-local-sql-databases-in-air/handling-database-errors","title":"Handling database errors","description":"In general, database error handling is like other runtime error handling. You","source":"@site/docs/development/files-and-data/working-with-local-sql-databases-in-air/handling-database-errors.md","sourceDirName":"development/files-and-data/working-with-local-sql-databases-in-air","slug":"/development/files-and-data/working-with-local-sql-databases-in-air/handling-database-errors","permalink":"/docs/development/files-and-data/working-with-local-sql-databases-in-air/handling-database-errors","draft":false,"unlisted":false,"editUrl":"https://github.com/airsdk/airsdk.dev/edit/main/docs/development/files-and-data/working-with-local-sql-databases-in-air/handling-database-errors.md","tags":[],"version":"current","sidebarPosition":7.8,"frontMatter":{"sidebar_position":7.8},"sidebar":"mainSidebar","previous":{"title":"Working with multiple databases","permalink":"/docs/development/files-and-data/working-with-local-sql-databases-in-air/working-with-multiple-databases"},"next":{"title":"Working with database data types","permalink":"/docs/development/files-and-data/working-with-local-sql-databases-in-air/working-with-database-data-types"}}');var r=n(74848),s=n(28453);const o={sidebar_position:7.8},i="Handling database errors",c={},l=[{value:"Connection errors",id:"connection-errors",level:2},{value:"Syntax errors",id:"syntax-errors",level:2},{value:"Constraint errors",id:"constraint-errors",level:2}];function d(e){const t={a:"a",br:"br",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"handling-database-errors",children:"Handling database errors"})}),"\n",(0,r.jsx)(t.p,{children:"In general, database error handling is like other runtime error handling. You\nshould write code that is prepared for errors that may occur, and respond to the\nerrors rather than leave it up to the runtime to do so. In a general sense, the\npossible database errors can be divided into three categories: connection\nerrors, SQL syntax errors, and constraint errors."}),"\n",(0,r.jsx)(t.h2,{id:"connection-errors",children:"Connection errors"}),"\n",(0,r.jsx)(t.p,{children:"Most database errors are connection errors, and they can occur during any\noperation. Although there are strategies for preventing connection errors, there\nis rarely a simple way to gracefully recover from a connection error if the\ndatabase is a critical part of your application."}),"\n",(0,r.jsx)(t.p,{children:"Most connection errors have to do with how the runtime interacts with the\noperating system, the file system, and the database file. For example, a\nconnection error occurs if the user doesn't have permission to create a database\nfile in a particular location on the file system. The following strategies help\nto prevent connection errors:"}),"\n",(0,r.jsxs)(t.p,{children:["Use user-specific database files",(0,r.jsx)(t.br,{}),"\n","Rather than using a single database file for all users who use the application\non a single computer, give each user their own database file. The file should be\nlocated in a directory that's associated with the user's account. For example,\nit could be in the application's storage directory, the user's documents folder,\nthe user's desktop, and so forth."]}),"\n",(0,r.jsxs)(t.p,{children:["Consider different user types",(0,r.jsx)(t.br,{}),"\n","Test your application with different types of user accounts, on different\noperating systems. Don't assume that the user has administrator permission on\nthe computer. Also, don't assume that the individual who installed the\napplication is the user who's running the application."]}),"\n",(0,r.jsxs)(t.p,{children:["Consider various file locations",(0,r.jsx)(t.br,{}),"\n","If you allow a user to specify where to save a database file or select a file to\nopen, consider the possible file locations that the users might use. In\naddition, consider defining limits on where users can store (or from where they\ncan open) database files. For example, you might only allow users to open files\nthat are within their user account's storage location."]}),"\n",(0,r.jsx)(t.p,{children:"If a connection error occurs, it most likely happens on the first attempt to\ncreate or open the database. This means that the user is unable to do any\ndatabase-related operations in the application. For certain types of errors,\nsuch as read-only or permission errors, one possible recovery technique is to\ncopy the database file to a different location. The application can copy the\ndatabase file to a different location where the user does have permission to\ncreate and write to files, and use that location instead."}),"\n",(0,r.jsx)(t.h2,{id:"syntax-errors",children:"Syntax errors"}),"\n",(0,r.jsx)(t.p,{children:"A syntax error occurs when a SQL statement is incorrectly formed, and the\napplication attempts to execute the statement. Because local database SQL\nstatements are created as strings, compile-time SQL syntax checking is not\npossible. All SQL statements must be executed to check their syntax. Use the\nfollowing strategies to prevent SQL syntax errors:"}),"\n",(0,r.jsxs)(t.p,{children:["Test all SQL statements thoroughly",(0,r.jsx)(t.br,{}),"\n","If possible, while developing your application test your SQL statements\nseparately before encoding them as statement text in the application code. In\naddition, use a code-testing approach such as unit testing to create a set of\ntests that exercise every possible option and variation in the code."]}),"\n",(0,r.jsxs)(t.p,{children:["Use statement parameters and avoid concatenating (dynamically generating) SQL",(0,r.jsx)(t.br,{}),"\n","Using parameters, and avoiding dynamically built SQL statements, means that the\nsame SQL statement text is used each time a statement is executed. Consequently,\nit's much easier to test your statements and limit the possible variation. If\nyou must dynamically generate a SQL statement, keep the dynamic parts of the\nstatement to a minimum. Also, carefully validate any user input to make sure it\nwon't cause syntax errors."]}),"\n",(0,r.jsx)(t.p,{children:"To recover from a syntax error, an application would need complex logic to be\nable to examine a SQL statement and correct its syntax. By following the\nprevious guidelines for preventing syntax errors, your code can identify any\npotential run-time sources of SQL syntax errors (such as user input used in a\nstatement). To recover from a syntax error, provide guidance to the user.\nIndicate what to correct to make the statement execute properly."}),"\n",(0,r.jsx)(t.h2,{id:"constraint-errors",children:"Constraint errors"}),"\n",(0,r.jsxs)(t.p,{children:["Constraint errors occur when an ",(0,r.jsx)(t.code,{children:"INSERT"})," or ",(0,r.jsx)(t.code,{children:"UPDATE"})," statement attempts to add\ndata to a column. The error happens if the new data violates one of the defined\nconstraints for the table or column. The set of possible constraints includes:"]}),"\n",(0,r.jsxs)(t.p,{children:["Unique constraint",(0,r.jsx)(t.br,{}),"\n","Indicates that across all the rows in a table, there cannot be duplicate values\nin one column. Alternatively, when multiple columns are combined in a unique\nconstraint, the combination of values in those columns must not be duplicated.\nIn other words, in terms of the specified unique column or columns, each row\nmust be distinct."]}),"\n",(0,r.jsxs)(t.p,{children:["Primary key constraint",(0,r.jsx)(t.br,{}),"\n","In terms of the data that a constraint allows and doesn't allow, a primary key\nconstraint is identical to a unique constraint."]}),"\n",(0,r.jsxs)(t.p,{children:["Not null constraint",(0,r.jsx)(t.br,{}),"\n","Specifies that a single column cannot store a ",(0,r.jsx)(t.code,{children:"NULL"})," value and consequently that\nin every row, that column must have a value."]}),"\n",(0,r.jsxs)(t.p,{children:["Check constraint",(0,r.jsx)(t.br,{}),"\n","Allows you to specify an arbitrary constraint on one or more tables. A common\ncheck constraint is a rule that define that a column's value must be within\ncertain bounds (for example, that a numeric column's value must be larger than\n0). Another common type of check constraint specifies relationships between\ncolumn values (for example, that a column's value must be different from the\nvalue of another column in the same row)."]}),"\n",(0,r.jsxs)(t.p,{children:["Data type (column affinity) constraint",(0,r.jsx)(t.br,{}),"\n","The runtime enforces the data type of columns' values, and an error occurs if an\nattempt is made to store a value of the incorrect type in a column. However, in\nmany conditions values are converted to match the column's declared data type.\nSee ",(0,r.jsx)(t.a,{href:"/docs/development/files-and-data/working-with-local-sql-databases-in-air/working-with-database-data-types",children:"Working with database data types"}),"\nfor more information."]}),"\n",(0,r.jsx)(t.p,{children:"The runtime does not enforce constraints on foreign key values. In other words,\nforeign key values aren't required to match an existing primary key value."}),"\n",(0,r.jsx)(t.p,{children:"In addition to the predefined constraint types, the runtime SQL engine supports\nthe use of triggers. A trigger is like an event handler. It is a predefined set\nof instructions that are carried out when a certain action happens. For example,\na trigger could be defined that runs when data is inserted into or deleted from\na particular table. One possible use of a trigger is to examine data changes and\ncause an error to occur if specified conditions aren't met. Consequently, a\ntrigger can serve the same purpose as a constraint, and the strategies for\npreventing and recovering from constraint errors also apply to trigger-generated\nerrors. However, the error id for trigger-generated errors is different from the\nerror id for constraint errors."}),"\n",(0,r.jsx)(t.p,{children:"The set of constraints that apply to a particular table is determined while\nyou're designing an application. Consciously designing constraints makes it\neasier to design your application to prevent and recover from constraint errors.\nHowever, constraint errors are difficult to systematically predict and prevent.\nPrediction is difficult because constraint errors don't appear until application\ndata is added. Constraint errors occur with data that is added to a database\nafter it's created. These errors are often a result of the relationship between\nnew data and data that already exists in the database. The following strategies\ncan help you avoid many constraint errors:"}),"\n",(0,r.jsxs)(t.p,{children:["Carefully plan database structure and constraints",(0,r.jsx)(t.br,{}),"\n","The purpose of constraints is to enforce application rules and help protect the\nintegrity of the database's data. When you're planning your application,\nconsider how to structure your database to support your application. As part of\nthat process, identify rules for your data, such as whether certain values are\nrequired, whether a value has a default, whether duplicate values are allowed,\nand so forth. Those rules guide you in defining database constraints."]}),"\n",(0,r.jsxs)(t.p,{children:["Explicitly specify column names",(0,r.jsx)(t.br,{}),"\n","An ",(0,r.jsx)(t.code,{children:"INSERT"})," statement can be written without explicitly specifying the columns\ninto which values are to be inserted, but doing so is an unnecessary risk. By\nexplicitly naming the columns into which values are to be inserted, you can\nallow for automatically generated values, columns with default values, and\ncolumns that allow ",(0,r.jsx)(t.code,{children:"NULL"})," values. In addition, by doing so you can ensure that\nall ",(0,r.jsx)(t.code,{children:"NOT NULL"})," columns have an explicit value inserted."]}),"\n",(0,r.jsxs)(t.p,{children:["Use default values",(0,r.jsx)(t.br,{}),"\n","Whenever you specify a ",(0,r.jsx)(t.code,{children:"NOT NULL"})," constraint for a column, if at all possible\nspecify a default value in the column definition. Application code can also\nprovide default values. For example, your code can check if a String variable is\n",(0,r.jsx)(t.code,{children:"null"})," and assign it a value before using it to set a statement parameter value."]}),"\n",(0,r.jsxs)(t.p,{children:["Validate user-entered data",(0,r.jsx)(t.br,{}),"\n","Check user-entered data ahead of time to make sure that it obeys limits\nspecified by constraints, especially in the case of ",(0,r.jsx)(t.code,{children:"NOT NULL"})," and ",(0,r.jsx)(t.code,{children:"CHECK"}),"\nconstraints. Naturally, a ",(0,r.jsx)(t.code,{children:"UNIQUE"})," constraint is more difficult to check for\nbecause doing so would require executing a ",(0,r.jsx)(t.code,{children:"SELECT"})," query to determine whether\nthe data is unique."]}),"\n",(0,r.jsxs)(t.p,{children:["Use triggers",(0,r.jsx)(t.br,{}),"\n","You can write a trigger that validates (and possibly replaces) inserted data or\ntakes other actions to correct invalid data. This validation and correction can\nprevent a constraint error from occurring."]}),"\n",(0,r.jsx)(t.p,{children:"In many ways constraint errors are more difficult to prevent than other types of\nerrors. Fortunately, there are several strategies to recover from constraint\nerrors in ways that don't make the application unstable or unusable:"}),"\n",(0,r.jsxs)(t.p,{children:["Use conflict algorithms",(0,r.jsx)(t.br,{}),"\n","When you define a constraint on a column, and when you create an ",(0,r.jsx)(t.code,{children:"INSERT"})," or\n",(0,r.jsx)(t.code,{children:"UPDATE"})," statement, you have the option of specifying a conflict algorithm. A\nconflict algorithm defines the action the database takes when a constraint\nviolation occurs. There are several possible actions the database engine can\ntake. The database engine can end a single statement or a whole transaction. It\ncan ignore the error. It can even remove old data and replace it with the data\nthat the code is attempting to store."]}),"\n",(0,r.jsxs)(t.p,{children:['For more information see the section "ON CONFLICT (conflict algorithms)" in the\n',(0,r.jsx)(t.a,{href:"/docs/development/appendixes/sql-support-in-local-databases/",children:"SQL support in local databases"}),"."]}),"\n",(0,r.jsxs)(t.p,{children:["Provide corrective feedback",(0,r.jsx)(t.br,{}),"\n","The set of constraints that can affect a particular SQL command can be\nidentified ahead of time. Consequently, you can anticipate constraint errors\nthat a statement could cause. With that knowledge, you can build application\nlogic to respond to a constraint error. For example, suppose an application\nincludes a data entry form for entering new products. If the product name column\nin the database is defined with a ",(0,r.jsx)(t.code,{children:"UNIQUE"})," constraint, the action of inserting a\nnew product row in the database could cause a constraint error. Consequently,\nthe application is designed to anticipate a constraint error. When the error\nhappens, the application alerts the user, indicating that the specified product\nname is already in use and asking the user to choose a different name. Another\npossible response is to allow the user to view information about the other\nproduct with the same name."]})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);