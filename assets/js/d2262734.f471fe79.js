"use strict";(self.webpackChunkairsdk_dev=self.webpackChunkairsdk_dev||[]).push([[61045],{28453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>s});var r=n(96540);const i={},o=r.createContext(i);function a(e){const t=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),r.createElement(o.Provider,{value:t},e.children)}},54041:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>p,frontMatter:()=>a,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"development/display/working-in-three-dimensions/performing-complex-3d-transformations","title":"Performing complex 3D transformations","description":"The Matrix3D class lets you transform 3D points within a coordinate space or map","source":"@site/docs/development/display/working-in-three-dimensions/performing-complex-3d-transformations.md","sourceDirName":"development/display/working-in-three-dimensions","slug":"/development/display/working-in-three-dimensions/performing-complex-3d-transformations","permalink":"/docs/development/display/working-in-three-dimensions/performing-complex-3d-transformations","draft":false,"unlisted":false,"editUrl":"https://github.com/airsdk/airsdk.dev/edit/main/docs/development/display/working-in-three-dimensions/performing-complex-3d-transformations.md","tags":[],"version":"current","frontMatter":{},"sidebar":"mainSidebar","previous":{"title":"Example: Perspective projection","permalink":"/docs/development/display/working-in-three-dimensions/example-perspective-projection"},"next":{"title":"Projecting 3D objects onto a 2D view","permalink":"/docs/development/display/working-in-three-dimensions/projecting-3d-objects-onto-a-2d-view"}}');var i=n(74848),o=n(28453);const a={},s="Performing complex 3D transformations",c={},l=[{value:"Creating Matrix3D objects",id:"creating-matrix3d-objects",level:2},{value:"Applying multiple 3D transformations",id:"applying-multiple-3d-transformations",level:2},{value:"Using Matrix3D objects for reordering display",id:"using-matrix3d-objects-for-reordering-display",level:2}];function d(e){const t={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"performing-complex-3d-transformations",children:"Performing complex 3D transformations"})}),"\n",(0,i.jsx)(t.p,{children:"The Matrix3D class lets you transform 3D points within a coordinate space or map\n3D points from one coordinate space to another."}),"\n",(0,i.jsx)(t.p,{children:"You don't need to understand matrix mathematics to use the Matrix3D class. Most\nof the common transformation operations can be handled using the methods of the\nclass. You don't have to worry about explicitly setting or calculating the\nvalues of each element in the matrix."}),"\n",(0,i.jsxs)(t.p,{children:["After you set the ",(0,i.jsx)(t.code,{children:"z"})," property of a display object to a numeric value, you can\nretrieve the object's transformation matrix using the Matrix3D property of the\ndisplay object's Transform object:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"var leafMatrix:Matrix3D = this.transform.matrix3D;\n"})}),"\n",(0,i.jsx)(t.p,{children:"You can use the methods of the Matrix3D object to perform translation, rotation,\nscaling, and perspective projection on the display object."}),"\n",(0,i.jsxs)(t.p,{children:["Use the Vector3D class with its ",(0,i.jsx)(t.code,{children:"x"}),", ",(0,i.jsx)(t.code,{children:"y"}),", and ",(0,i.jsx)(t.code,{children:"z"})," properties for managing 3D\npoints. It can also represent a spatial vector in physics, which has a direction\nand a magnitude. The methods of the Vector3D class let you perform common\ncalculations with spatial vectors, such as addition, dot product, and cross\nproduct calculations."]}),"\n",(0,i.jsx)(t.p,{children:"Note: The Vector3D class is not related to the ActionScript Vector class. The\nVector3D class contains properties and methods for defining and manipulating 3D\npoints, while the Vector class supports arrays of typed objects."}),"\n",(0,i.jsx)(t.h2,{id:"creating-matrix3d-objects",children:"Creating Matrix3D objects"}),"\n",(0,i.jsxs)(t.p,{children:["There are three main ways of creating or retrieving ",(0,i.jsx)(t.code,{children:"Matrix3D"})," objects:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:["Use the ",(0,i.jsx)(t.code,{children:"Matrix3D()"})," constructor method to instantiate a new matrix. The\n",(0,i.jsx)(t.code,{children:"Matrix3D()"})," constructor takes a ",(0,i.jsx)(t.code,{children:"Vector"})," object containing 16 numeric values\nand places each value into a cell of the matrix. For example:"]}),"\n",(0,i.jsxs)(t.p,{children:["var rotateMatrix",":Matrix3D"," = new Matrix3D(1,0,0,1, 0,1,0,1, 0,0,1,1, 0,0,0,1);"]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:["Set the value the ",(0,i.jsx)(t.code,{children:"z"})," property of a display object. Then retrieve the\ntransformation matrix from the ",(0,i.jsx)(t.code,{children:"transform.matrix3D"})," property of that object."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:["Retrieve the Matrix3D object that controls the display of 3D objects on the\nstage by calling the ",(0,i.jsx)(t.code,{children:"perspectiveProjection.toMatrix3D()"})," method on the root\ndisplay object."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"applying-multiple-3d-transformations",children:"Applying multiple 3D transformations"}),"\n",(0,i.jsx)(t.p,{children:"You can apply many 3D transformations at once using a Matrix3D object. For\nexample if you wanted to rotate, scale, and then move a cube, you could apply\nthree separate transformations to each point of the cube. However it is much\nmore efficient to precalculate multiple transformations in one Matrix3D object\nand then perform one matrix transformation on each of the points."}),"\n",(0,i.jsx)(t.p,{children:"Note: The order in which matrix transformations are applied is important. Matrix\ncalculations are not commutative. For example, applying a rotation followed by a\ntranslation gives a different result than applying the same translation followed\nby the same rotation."}),"\n",(0,i.jsx)(t.p,{children:"The following example shows two ways of performing multiple 3D transformations."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"package {\n    import flash.display.Sprite;\n    import flash.display.Shape;\n    import flash.display.Graphics;\n    import flash.geom.*;\n\n    public class Matrix3DTransformsExample extends Sprite\n    {\n        private var rect1:Shape;\n        private var rect2:Shape;\n\n        public function Matrix3DTransformsExample():void\n        {\n            var pp:PerspectiveProjection = this.transform.perspectiveProjection;\n            pp.projectionCenter = new Point(275,200);\n            this.transform.perspectiveProjection = pp;\n\n            rect1 = new Shape();\n            rect1.x = -70;\n            rect1.y = -40;\n            rect1.z = 0;\n            rect1.graphics.beginFill(0xFF8800);\n            rect1.graphics.drawRect(0,0,50,80);\n            rect1.graphics.endFill();\n            addChild(rect1);\n\n            rect2 = new Shape();\n            rect2.x = 20;\n            rect2.y = -40;\n            rect2.z = 0;\n            rect2.graphics.beginFill(0xFF0088);\n            rect2.graphics.drawRect(0,0,50,80);\n            rect2.graphics.endFill();\n            addChild(rect2);\n\n            doTransforms();\n        }\n\n        private function doTransforms():void\n        {\n            rect1.rotationX = 15;\n            rect1.scaleX = 1.2;\n            rect1.x += 100;\n            rect1.y += 50;\n            rect1.rotationZ = 10;\n\n            var matrix:Matrix3D = rect2.transform.matrix3D;\n            matrix.appendRotation(15, Vector3D.X_AXIS);\n            matrix.appendScale(1.2, 1, 1);\n            matrix.appendTranslation(100, 50, 0);\n            matrix.appendRotation(10, Vector3D.Z_AXIS);\n            rect2.transform.matrix3D = matrix;\n        }\n    }\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:["In the ",(0,i.jsx)(t.code,{children:"doTransforms()"})," method the first block of code uses the DisplayObject\nproperties to change the rotation, scaling, and position of a rectangle shape.\nThe second block of code uses the methods of the Matrix3D class to do the same\ntransformations."]}),"\n",(0,i.jsxs)(t.p,{children:["The main advantage of using the ",(0,i.jsx)(t.code,{children:"Matrix3D"})," methods is that all of the\ncalculations are performed in the matrix first,. Then they are applied to the\ndisplay object only once, when its ",(0,i.jsx)(t.code,{children:"transform.matrix3D"})," property is set. Setting\nDisplayObject properties make the source code a bit simpler to read. However\neach time a rotation or scaling property is set, it causes multiple calculations\nand changes multiple display object properties."]}),"\n",(0,i.jsx)(t.p,{children:"If your code will apply the same complex transformations to display objects more\nthan once, save the Matrix3D object as a variable and then reapply it over and\nover."}),"\n",(0,i.jsx)(t.h2,{id:"using-matrix3d-objects-for-reordering-display",children:"Using Matrix3D objects for reordering display"}),"\n",(0,i.jsx)(t.p,{children:"As mentioned previously, the layering order of display objects in the display\nlist determines the display layering order, regardless of their relative z-axes.\nIf your animation transforms the properties of display objects into an order\nthat differs from the display list order, the viewer might see display object\nlayering that does not correspond to the z-axis layering. So, an object that\nshould appear further away from the viewer might appear in front of an object\nthat is closer to the viewer."}),"\n",(0,i.jsx)(t.p,{children:"To ensure that the layering of 3D display objects corresponds to the relative\ndepths of the objects, use an approach like the following:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:["Use the ",(0,i.jsx)(t.code,{children:"getRelativeMatrix3D()"})," method of the Transform object to get the\nrelative ",(0,i.jsx)(t.code,{children:"z-axes"})," of the child 3D display objects."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:["Use the ",(0,i.jsx)(t.code,{children:"removeChild()"})," method to remove the objects from the display list."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"Sort the display objects based on their relative z-axis values."}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:["Use the ",(0,i.jsx)(t.code,{children:"addChild()"})," method to add the children back to the display list in\nreverse order."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"This reordering ensures that your objects display in accordance with their\nrelative z-axes."}),"\n",(0,i.jsx)(t.p,{children:"The following code enforces the correct display of the six faces of a 3D box. It\nreorders the faces of the box after rotations have been applied to the it:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:'public var faces:Array; . . .\n\npublic function ReorderChildren()\n{\n    for(var ind:uint = 0; ind < 6; ind++)\n    {\n        faces[ind].z = faces[ind].child.transform.getRelativeMatrix3D(root).position.z;\n        this.removeChild(faces[ind].child);\n    }\n    faces.sortOn("z", Array.NUMERIC | Array.DESCENDING);\n    for (ind = 0; ind < 6; ind++)\n    {\n        this.addChild(faces[ind].child);\n    }\n}\n'})}),"\n",(0,i.jsxs)(t.p,{children:["To get the application files for this sample, see\n",(0,i.jsx)(t.a,{href:"https://github.com/joshtynjala/flash-platform-as3-dev-guide-examples/releases/tag/original",children:(0,i.jsx)(t.em,{children:"FlashPlatformAS3DevGuideExamples.zip"})}),".\nThe application files are in the Samples/ReorderByZ folder."]})]})}function p(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);