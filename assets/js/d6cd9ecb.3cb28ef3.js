"use strict";(self.webpackChunkairsdk_dev=self.webpackChunkairsdk_dev||[]).push([[11937],{28453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>o});var a=n(96540);const i={},s=a.createContext(i);function r(e){const t=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),a.createElement(s.Provider,{value:t},e.children)}},80669:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>m,frontMatter:()=>r,metadata:()=>a,toc:()=>p});const a=JSON.parse('{"id":"development/display/working-with-bitmaps/scrolling-bitmaps","title":"Scrolling bitmaps","description":"Imagine you have created a street mapping application where each time the user","source":"@site/docs/development/display/working-with-bitmaps/scrolling-bitmaps.md","sourceDirName":"development/display/working-with-bitmaps","slug":"/development/display/working-with-bitmaps/scrolling-bitmaps","permalink":"/docs/development/display/working-with-bitmaps/scrolling-bitmaps","draft":false,"unlisted":false,"editUrl":"https://github.com/airsdk/airsdk.dev/edit/main/docs/development/display/working-with-bitmaps/scrolling-bitmaps.md","tags":[],"version":"current","frontMatter":{},"sidebar":"mainSidebar","previous":{"title":"Manipulating pixels","permalink":"/docs/development/display/working-with-bitmaps/manipulating-pixels"},"next":{"title":"Taking advantage of mipmapping","permalink":"/docs/development/display/working-with-bitmaps/taking-advantage-of-mipmapping"}}');var i=n(74848),s=n(28453);const r={},o="Scrolling bitmaps",l={},p=[];function d(e){const t={code:"code",h1:"h1",header:"header",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"scrolling-bitmaps",children:"Scrolling bitmaps"})}),"\n",(0,i.jsx)(t.p,{children:"Imagine you have created a street mapping application where each time the user\nmoves the map you are required to update the view (even if the map has been\nmoved by just a few pixels)."}),"\n",(0,i.jsxs)(t.p,{children:["One way to create this functionality would be to re-render a new image\ncontaining the updated map view each time the user moves the map. Alternatively,\nyou could create a large single image and use the ",(0,i.jsx)(t.code,{children:"scroll()"})," method."]}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"scroll()"})," method copies an on-screen bitmap and then pastes it to a new\noffset location\u2014specified by (",(0,i.jsx)(t.code,{children:"x"}),", ",(0,i.jsx)(t.code,{children:"y"}),") parameters. If a portion of the bitmap\nhappens to reside off-stage, this gives the effect that the image has shifted.\nWhen combined with a timer function (or an ",(0,i.jsx)(t.code,{children:"enterFrame"})," event), you can make the\nimage appear to be animating or scrolling."]}),"\n",(0,i.jsxs)(t.p,{children:["The following example takes the previous perlin noise example and generates a\nlarger bitmap image (three-fourths of which is rendered off-stage). The\n",(0,i.jsx)(t.code,{children:"scroll()"})," method is then applied, along with an ",(0,i.jsx)(t.code,{children:"enterFrame"})," event listener\nthat offsets the image by one pixel in a diagonally downward direction. This\nmethod is called each time the frame is entered and as a result, the off screen\nportions of the image are rendered to the Stage as the image scrolls down."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"import flash.display.Bitmap;\nimport flash.display.BitmapData;\n\nvar myBitmapDataObject:BitmapData = new BitmapData(1000, 1000, false, 0x00FF0000);\nvar seed:Number = Math.floor(Math.random() * 100);\nvar channels:uint = BitmapDataChannel.GREEN | BitmapDataChannel.BLUE;\nmyBitmapDataObject.perlinNoise(100, 80, 6, seed, false, true, channels, false, null);\n\nvar myBitmap:Bitmap = new Bitmap(myBitmapDataObject);\nmyBitmap.x = -750;\nmyBitmap.y = -750;\naddChild(myBitmap);\n\naddEventListener(Event.ENTER_FRAME, scrollBitmap);\n\nfunction scrollBitmap(event:Event):void\n{\n"})}),"\n",(0,i.jsx)(t.p,{children:"myBitmapDataObject.scroll(1, 1);"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"}\n"})})]})}function m(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);