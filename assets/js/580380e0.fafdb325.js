"use strict";(self.webpackChunkairsdk_dev=self.webpackChunkairsdk_dev||[]).push([[47404],{28453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>o});var i=n(96540);const a={},s=i.createContext(a);function r(e){const t=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),i.createElement(s.Provider,{value:t},e.children)}},39698:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>m,frontMatter:()=>r,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"development/display/working-with-bitmaps/taking-advantage-of-mipmapping","title":"Taking advantage of mipmapping","description":"MIP maps (also known as mipmaps), are bitmaps grouped together and","source":"@site/docs/development/display/working-with-bitmaps/taking-advantage-of-mipmapping.md","sourceDirName":"development/display/working-with-bitmaps","slug":"/development/display/working-with-bitmaps/taking-advantage-of-mipmapping","permalink":"/docs/development/display/working-with-bitmaps/taking-advantage-of-mipmapping","draft":false,"unlisted":false,"editUrl":"https://github.com/airsdk/airsdk.dev/edit/main/docs/development/display/working-with-bitmaps/taking-advantage-of-mipmapping.md","tags":[],"version":"current","frontMatter":{},"sidebar":"mainSidebar","previous":{"title":"Scrolling bitmaps","permalink":"/docs/development/display/working-with-bitmaps/scrolling-bitmaps"},"next":{"title":"The Bitmap and BitmapData classes","permalink":"/docs/development/display/working-with-bitmaps/the-bitmap-and-bitmap-data-classes"}}');var a=n(74848),s=n(28453);const r={},o="Taking advantage of mipmapping",l={},d=[];function p(e){const t={code:"code",em:"em",h1:"h1",header:"header",li:"li",p:"p",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"taking-advantage-of-mipmapping",children:"Taking advantage of mipmapping"})}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.em,{children:"MIP maps"})," (also known as ",(0,a.jsx)(t.em,{children:"mipmaps"}),"), are bitmaps grouped together and\nassociated with a texture to increase runtime rendering quality and performance.\nEach bitmap image in the MIP map is a version of the main bitmap image, but at a\nreduced level of detail from the main image."]}),"\n",(0,a.jsx)(t.p,{children:"For example, you can have a MIP map that includes at the highest quality a main\nimage at 64 \xd7 64 pixels. Lower quality images in the MIP map would be 32 \xd7 32,\n16 \xd7 16, 8 \xd7 8, 4 \xd7 4, 2 \xd7 2, and 1 \xd7 1 pixels."}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.em,{children:"Texture streaming"})," is the ability to load the lowest quality bitmap first, and\nthen to progressively display higher quality bitmaps as the bitmaps are loaded.\nBecause lower quality bitmaps are small, they load faster than the main image.\nTherefore, application users can view image in an application before the main,\nhigh quality bitmap loads."]}),"\n",(0,a.jsxs)(t.p,{children:["Flash Player 9.115.0 and later versions and AIR implement this technology (the\nprocess is called ",(0,a.jsx)(t.em,{children:"mipmapping"}),"), by creating optimized versions of varying scale\nof each bitmap (starting at 50%)."]}),"\n",(0,a.jsxs)(t.p,{children:["Flash Player 11.3 and AIR 3.3 support texture streaming through the\n",(0,a.jsx)(t.code,{children:"streamingLevels"})," parameter of the ",(0,a.jsx)(t.code,{children:"Context3D.createCubeTexture()"})," and\n",(0,a.jsx)(t.code,{children:"Context3D.createTexture()"})," methods."]}),"\n",(0,a.jsx)(t.p,{children:"Texture compression lets you store texture images in compressed format directly\non the GPU, which saves GPU memory and memory bandwidth. Typically, compressed\ntextures are compressed offline and uploaded to the GPU in compressed format.\nHowever, Flash Player 11.4 and AIR 3.4 support runtime texture compression,\nwhich is useful in certain situations, such as when rendering dynami textures\nfrom vector art. To use runtime texture compression, perform the following\nsteps:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:["Create the texture object by calling the ",(0,a.jsx)(t.code,{children:"Context3D.createTexture()"})," method,\npassing either ",(0,a.jsx)(t.code,{children:"flash.display3D.Context3DTextureFormat.COMPRESSED"})," or\n",(0,a.jsx)(t.code,{children:"flash.display3D.Context3DTextureFormat.COMPRESSED_ALPHA"})," in the third\nparameter."]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:["Using the ",(0,a.jsx)(t.code,{children:"flash.display3D.textures.Texture"})," instance returned by\n",(0,a.jsx)(t.code,{children:"createTexture()"}),", call either\n",(0,a.jsx)(t.code,{children:"flash.display3D.textures.Texture.uploadFromBitmapData()"})," or\n",(0,a.jsx)(t.code,{children:"flash.display3D.textures.Texture.uploadFromByteArray()"}),". These methods upload\nand compress the texture in one step."]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"MIP maps are created for the following types of bitmaps:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:"a bitmap (JPEG, GIF, or PNG files) displayed using the ActionScript 3.0 Loader\nclass"}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:"a bitmap in the library of a Flash Professional document"}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:"a BitmapData object"}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:["a bitmap displayed using the ActionScript 2.0 ",(0,a.jsx)(t.code,{children:"loadMovie()"})," function"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"MIP maps are not applied to filtered objects or bitmap-cached movie clips.\nHowever, MIP maps are applied if you have bitmap transformations within a\nfiltered display object, even if the bitmap is within masked content."}),"\n",(0,a.jsx)(t.p,{children:"Mipmapping happens automatically, but you can follow a few guidelines to make\nsure your images take advantage of this optimization:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:["For video playback, set the ",(0,a.jsx)(t.code,{children:"smoothing"})," property to ",(0,a.jsx)(t.code,{children:"true"})," for the Video\nobject (see the Video class)."]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:["For bitmaps, the ",(0,a.jsx)(t.code,{children:"smoothing"})," property does not have to be set to ",(0,a.jsx)(t.code,{children:"true"}),", but\nthe quality improvements are more visible when bitmaps use smoothing."]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:"Use bitmap sizes that are divisible by 4 or 8 for two-dimensional images (such\nas 640 x 128, which can be reduced as follows: 320 x 64 > 160 x 32 > 80 x 16\n> 40 x 8 > 20 x 4 > 10 x 2 > 5 x 1)."}),"\n",(0,a.jsx)(t.p,{children:"For three-dimensional textures, use MIP maps where each image is at a\nresolution that is a power of 2 (meaning 2^n). For example, the main image is\nat a resolution of 1024 x 1024 pixels. The lower quality images in the MIP map\nwould then be at 512 x 512, 256 x 256, 128 x 128 down to 1 x 1 pixels for a\ntotal of 11 images in the MIP map."}),"\n",(0,a.jsx)(t.p,{children:"Note that mipmapping does not occur for bitmap content with an odd width or\nheight."}),"\n"]}),"\n"]})]})}function m(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(p,{...e})}):p(e)}}}]);