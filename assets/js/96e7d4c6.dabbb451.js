"use strict";(globalThis.webpackChunkairsdk_dev=globalThis.webpackChunkairsdk_dev||[]).push([[66277],{28453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>a});var i=n(96540);const r={},l=i.createContext(r);function s(e){const t=i.useContext(l);return i.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),i.createElement(l.Provider,{value:t},e.children)}},72958:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/fo_filter_workbench_screenshot_popup-c6471e35c2f37d17f5462dda60a0758c.png"},77553:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>d,frontMatter:()=>s,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"development/display/filtering-display-objects/filtering-display-objects-example-filter-workbench","title":"Filtering display objects example: Filter Workbench","description":"The Filter Workbench provides a user interface to apply different filters to","source":"@site/docs/development/display/filtering-display-objects/filtering-display-objects-example-filter-workbench.md","sourceDirName":"development/display/filtering-display-objects","slug":"/development/display/filtering-display-objects/filtering-display-objects-example-filter-workbench","permalink":"/docs/development/display/filtering-display-objects/filtering-display-objects-example-filter-workbench","draft":false,"unlisted":false,"editUrl":"https://github.com/airsdk/airsdk.dev/edit/main/docs/development/display/filtering-display-objects/filtering-display-objects-example-filter-workbench.md","tags":[],"version":"current","frontMatter":{},"sidebar":"mainSidebar","previous":{"title":"Example: Combining basic filters","permalink":"/docs/development/display/filtering-display-objects/example-combining-basic-filters"},"next":{"title":"Glow filter","permalink":"/docs/development/display/filtering-display-objects/glow-filter"}}');var r=n(74848),l=n(28453);const s={},a="Filtering display objects example: Filter Workbench",c={},o=[{value:"Experimenting with ActionScript filters",id:"experimenting-with-actionscript-filters",level:2},{value:"Creating filter instances",id:"creating-filter-instances",level:2},{value:"Applying filters to display objects",id:"applying-filters-to-display-objects",level:2}];function h(e){const t={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",img:"img",li:"li",p:"p",pre:"pre",ul:"ul",...(0,l.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"filtering-display-objects-example-filter-workbench",children:"Filtering display objects example: Filter Workbench"})}),"\n",(0,r.jsx)(t.p,{children:"The Filter Workbench provides a user interface to apply different filters to\nimages and other visual content and see the resulting code that can be used to\ngenerate the same effect in ActionScript. In addition to providing a tool for\nexperimenting with filters, this application demonstrates the following\ntechniques:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsx)(t.p,{children:"Creating instances of various filters"}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsx)(t.p,{children:"Applying multiple filters to a display object"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(t.p,{children:["To get the application files for this sample, see\n",(0,r.jsx)(t.a,{href:"https://github.com/joshtynjala/flash-platform-as3-dev-guide-examples/releases/tag/original",children:(0,r.jsx)(t.em,{children:"FlashPlatformAS3DevGuideExamples.zip"})}),".\nThe Filter Workbench application files can be found in the\nSamples/FilterWorkbench folder. The application consists of the following files:"]}),"\n",(0,r.jsxs)("table",{children:[(0,r.jsx)("thead",{children:(0,r.jsxs)("tr",{children:[(0,r.jsx)("th",{children:(0,r.jsx)("p",{children:"File"})}),(0,r.jsx)("th",{children:(0,r.jsx)("p",{children:"Description"})})]})}),(0,r.jsxs)("tbody",{children:[(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("p",{children:"com/example/programmingas3/filterWorkbench/FilterWorkbenchController.as"})}),(0,r.jsx)("td",{children:(0,r.jsx)("p",{children:"Class that\nprovides the main functionality of the application, including switching\ncontent to which filters are applied, and applying filters to\ncontent."})})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("p",{children:"com/example/programmingas3/filterWorkbench/IFilterFactory.as"})}),(0,r.jsx)("td",{children:(0,r.jsx)("p",{children:"Interface\ndefining common methods that are implemented by each of the filter\nfactory classes. This interface defines the common functionality that\nthe FilterWorkbenchController class uses to interact with the individual\nfilter factory classes."})})]}),(0,r.jsxs)("tr",{children:[(0,r.jsxs)("td",{children:[(0,r.jsx)("p",{children:"in folder\ncom/example/programmingas3/filterWorkbench/:"}),"\n",(0,r.jsx)("p",{children:"BevelFactory.as"}),"\n",(0,r.jsx)("p",{children:"BlurFactory.as"}),"\n",(0,r.jsx)("p",{children:"ColorMatrixFactory.as"}),"\n",(0,r.jsx)("p",{children:"ConvolutionFactory.as"}),"\n",(0,r.jsx)("p",{children:"DropShadowFactory.as"}),"\n",(0,r.jsx)("p",{children:"GlowFactory.as"}),"\n",(0,r.jsx)("p",{children:"GradientBevelFactory.as"}),"\n",(0,r.jsx)("p",{children:"GradientGlowFactory.as"})]}),(0,r.jsx)("td",{children:(0,r.jsx)("p",{children:"Set of\nclasses, each of which implements the IFilterFactory interface. Each of\nthese classes provides the functionality of creating and setting values\nfor a single type of filter. The filter property panels in the\napplication use these factory classes to create instances of their\nparticular filters, which the FilterWorkbenchController class retrieves\nand applies to the image content."})})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("p",{children:"com/example/programmingas3/filterWorkbench/IFilterPanel.as"})}),(0,r.jsx)("td",{children:(0,r.jsx)("p",{children:"Interface\ndefining common methods that are implemented by classes that define the\nuser interface panels that are used to manipulate filter values in the\napplication."})})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("p",{children:"com/example/programmingas3/filterWorkbench/ColorStringFormatter.as"})}),(0,r.jsx)("td",{children:(0,r.jsx)("p",{children:"Utility class\nthat includes a method to convert a numeric color value to hexadecimal\nString format"})})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("p",{children:"com/example/programmingas3/filterWorkbench/GradientColor.as"})}),(0,r.jsx)("td",{children:(0,r.jsx)("p",{children:"Class that\nserves as a value object, combining into a single object the three\nvalues (color, alpha, and ratio) that are associated with each color in\nthe GradientBevelFilter and GradientGlowFilter"})})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("p",{children:"User\ninterface (Flex)"})}),(0,r.jsx)("td",{})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("p",{children:"FilterWorkbench.mxml"})}),(0,r.jsx)("td",{children:(0,r.jsx)("p",{children:"The main file\ndefining the application's user interface."})})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("p",{children:"flexapp/FilterWorkbench.as"})}),(0,r.jsx)("td",{children:(0,r.jsx)("p",{children:"Class that\nprovides the functionality for the main application's user interface;\nthis class is used as the code-behind class for the application MXML\nfile."})})]}),(0,r.jsxs)("tr",{children:[(0,r.jsxs)("td",{children:[(0,r.jsx)("p",{children:"In folder\nflexapp/filterPanels:"}),"\n",(0,r.jsx)("p",{children:"BevelPanel.mxml"}),"\n",(0,r.jsx)("p",{children:"BlurPanel.mxml"}),"\n",(0,r.jsx)("p",{children:"ColorMatrixPanel.mxml"}),"\n",(0,r.jsx)("p",{children:"ConvolutionPanel.mxml"}),"\n",(0,r.jsx)("p",{children:"DropShadowPanel.mxml"}),"\n",(0,r.jsx)("p",{children:"GlowPanel.mxml"}),"\n",(0,r.jsx)("p",{children:"GradientBevelPanel.mxml"}),"\n",(0,r.jsx)("p",{children:"GradientGlowPanel.mxml"})]}),(0,r.jsx)("td",{children:(0,r.jsx)("p",{children:"Set of MXML\ncomponents that provide the functionality for each panel that is used to\nset options for a single filter."})})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("p",{children:"flexapp/ImageContainer.as"})}),(0,r.jsx)("td",{children:(0,r.jsx)("p",{children:"A display\nobject that serves as a container for the loaded image on the\nscreen"})})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("p",{children:"flexapp/controls/BGColorCellRenderer.as"})}),(0,r.jsx)("td",{children:(0,r.jsx)("p",{children:"Custom cell\nrenderer used to change the background color of a cell in the DataGrid\ncomponent"})})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("p",{children:"flexapp/controls/QualityComboBox.as"})}),(0,r.jsx)("td",{children:(0,r.jsx)("p",{children:"Custom\ncontrol defining a combo box that can be used for the Quality setting in\nseveral filter panels."})})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("p",{children:"flexapp/controls/TypeComboBox.as"})}),(0,r.jsx)("td",{children:(0,r.jsx)("p",{children:"Custom\ncontrol defining a combo box that can be used for the Type setting in\nseveral filter panels."})})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("p",{children:"User\ninterface (Flash)"})}),(0,r.jsx)("td",{})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("p",{children:"FilterWorkbench.fla"})}),(0,r.jsx)("td",{children:(0,r.jsx)("p",{children:"The main file\ndefining the application's user interface."})})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("p",{children:"flashapp/FilterWorkbench.as"})}),(0,r.jsx)("td",{children:(0,r.jsx)("p",{children:"Class that\nprovides the functionality for the main application's user interface;\nthis class is used as the document class for the application FLA\nfile."})})]}),(0,r.jsxs)("tr",{children:[(0,r.jsxs)("td",{children:[(0,r.jsx)("p",{children:"In folder\nflashapp/filterPanels:"}),"\n",(0,r.jsx)("p",{children:"BevelPanel.as"}),"\n",(0,r.jsx)("p",{children:"BlurPanel.as"}),"\n",(0,r.jsx)("p",{children:"ColorMatrixPanel.as"}),"\n",(0,r.jsx)("p",{children:"ConvolutionPanel.as"}),"\n",(0,r.jsx)("p",{children:"DropShadowPanel.as"}),"\n",(0,r.jsx)("p",{children:"GlowPanel.as"}),"\n",(0,r.jsx)("p",{children:"GradientBevelPanel.as"}),"\n",(0,r.jsx)("p",{children:"GradientGlowPanel.as"})]}),(0,r.jsxs)("td",{children:[(0,r.jsx)("p",{children:"Set of\nclasses that provide the functionality for each panel that is used to\nset options for a single filter."}),"\n",(0,r.jsx)("p",{children:'For each class, there is also an associated MovieClip symbol in the\nlibrary of the main application FLA file, whose name matches the name of\nthe class (for example, the symbol "BlurPanel" is linked to the class\ndefined in BlurPanel.as). The components that make up the user interface\nare positioned and named within those symbols.'})]})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("p",{children:"flashapp/ImageContainer.as"})}),(0,r.jsx)("td",{children:(0,r.jsx)("p",{children:"A display\nobject that serves as a container for the loaded image on the\nscreen"})})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("p",{children:"flashapp/BGColorCellRenderer.as"})}),(0,r.jsx)("td",{children:(0,r.jsx)("p",{children:"Custom cell\nrenderer used to change the background color of a cell in the DataGrid\ncomponent"})})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("p",{children:"flashapp/ButtonCellRenderer.as"})}),(0,r.jsx)("td",{children:(0,r.jsx)("p",{children:"Custom cell\nrenderer used to include a button component in a cell in the DataGrid\ncomponent"})})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("p",{children:"Filtered\nimage content"})}),(0,r.jsx)("td",{})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("p",{children:"com/example/programmingas3/filterWorkbench/ImageType.as"})}),(0,r.jsx)("td",{children:(0,r.jsx)("p",{children:"This class\nserves as a value object containing the type and URL of a single image\nfile to which the application can load and apply filters. The class also\nincludes a set of constants representing the actual image files\navailable."})})]}),(0,r.jsxs)("tr",{children:[(0,r.jsxs)("td",{children:[(0,r.jsx)("p",{children:"images/sampleAnimation.swf,"}),"\n",(0,r.jsx)("p",{children:"images/sampleImage1.jpg,"}),"\n",(0,r.jsx)("p",{children:"images/sampleImage2.jpg"})]}),(0,r.jsx)("td",{children:(0,r.jsx)("p",{children:"Images and\nother visual content to which filters are applied in the\napplication."})})]})]})]}),"\n",(0,r.jsx)(t.h2,{id:"experimenting-with-actionscript-filters",children:"Experimenting with ActionScript filters"}),"\n",(0,r.jsx)(t.p,{children:"The Filter Workbench application is designed to help you experiment with various\nfilter effects and generate the relevant ActionScript code for that effect. The\napplication lets you select from three different files containing visual\ncontent, including bitmap images and an animation created by Flash, and apply\neight different ActionScript filters to the selected image, either individually\nor in combination with other filters. The application includes the following\nfilters:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsx)(t.p,{children:"Bevel (flash.filters.BevelFilter)"}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsx)(t.p,{children:"Blur (flash.filters.BlurFilter)"}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsx)(t.p,{children:"Color matrix (flash.filters.ColorMatrixFilter)"}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsx)(t.p,{children:"Convolution (flash.filters.ConvolutionFilter)"}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsx)(t.p,{children:"Drop shadow (flash.filters.DropShadowFilter)"}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsx)(t.p,{children:"Glow (flash.filters.GlowFilter)"}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsx)(t.p,{children:"Gradient bevel (flash.filters.GradientBevelFilter)"}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsx)(t.p,{children:"Gradient glow (flash.filters.GradientGlowFilter)"}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"Once a user has selected an image and a filter to apply to that image, the\napplication displays a panel with controls for setting the specific properties\nof the selected filter. For example, the following image shows the application\nwith the Bevel filter selected:"}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.img,{src:n(72958).A+"",width:"720",height:"500"})}),"\n",(0,r.jsx)(t.p,{children:"As the user adjusts the filter properties, the preview updates in real time. The\nuser can also apply multiple filters by customizing one filter, clicking the\nApply button, customizing another filter, clicking the Apply button, and so\nforth."}),"\n",(0,r.jsx)(t.p,{children:"There are a few features and limitations in the application's filter panels:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsx)(t.p,{children:"The color matrix filter includes a set of controls for directly manipulating\ncommon image properties including brightness, contrasts, saturation, and hue.\nIn addition, custom color matrix values can be specified."}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsx)(t.p,{children:"The convolution filter, which is only available using ActionScript, includes a\nset of commonly used convolution matrix values, or custom values can be\nspecified. However, while the ConvolutionFilter class accepts a matrix of any\nsize, the Filter Workbench application uses a fixed 3 x 3 matrix, the most\ncommonly used filter size."}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsx)(t.p,{children:"The displacement map filter and shader filter, which are only available in\nActionScript, are not available in the Filter Workbench application."}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"creating-filter-instances",children:"Creating filter instances"}),"\n",(0,r.jsxs)(t.p,{children:["The Filter Workbench application includes a set of classes, one for each of the\navailable filters, which are used by the individual panels to create the\nfilters. When a user selects a filter, the ActionScript code associated with the\nfilter panel creates an instance of the appropriate filter factory class. (These\nclasses are known as ",(0,r.jsx)(t.em,{children:"factory classes"})," because their purpose is to create\ninstances of other objects, much like a real-world factory creates individual\nproducts.)"]}),"\n",(0,r.jsxs)(t.p,{children:["Whenever the user changes a property value on the panel, the panel's code calls\nthe appropriate method in the factory class. Each factory class includes\nspecific methods that the panel uses to create the appropriate filter instance.\nFor example, if the user selects the Blur filter, the application creates a\nBlurFactory instance. The BlurFactory class includes a ",(0,r.jsx)(t.code,{children:"modifyFilter()"})," method\nthat accepts three parameters: ",(0,r.jsx)(t.code,{children:"blurX"}),", ",(0,r.jsx)(t.code,{children:"blurY"}),", and ",(0,r.jsx)(t.code,{children:"quality"}),", which together\nare used to create the desired BlurFilter instance:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"private var _filter:BlurFilter;\n\npublic function modifyFilter(blurX:Number = 4, blurY:Number = 4, quality:int = 1):void\n{\n    _filter = new BlurFilter(blurX, blurY, quality);\n    dispatchEvent(new Event(Event.CHANGE));\n}\n"})}),"\n",(0,r.jsx)(t.p,{children:"On the other hand, if the user selects the Convolution filter, that filter\nallows for much greater flexibility and consequently has a larger set of\nproperties to control. In the ConvolutionFactory class, the following code is\ncalled when the user selects a different value on the filter panel:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"private var _filter:ConvolutionFilter;\n\npublic function modifyFilter(matrixX:Number = 0,\n                            matrixY:Number = 0,\n                            matrix:Array = null,\n                            divisor:Number = 1.0,\n                            bias:Number = 0.0,\n                            preserveAlpha:Boolean = true,\n                            clamp:Boolean = true,\n                            color:uint = 0,\n                            alpha:Number = 0.0):void\n{\n    _filter = new ConvolutionFilter(matrixX, matrixY, matrix, divisor, bias, preserveAlpha, clamp, color, alpha);\n    dispatchEvent(new Event(Event.CHANGE));\n}\n"})}),"\n",(0,r.jsxs)(t.p,{children:["Notice that in each case, when the filter values are changed, the factory object\ndispatches an ",(0,r.jsx)(t.code,{children:"Event.CHANGE"})," event to notify listeners that the filter's values\nhave changed. The FilterWorkbenchController class, which does the work of\nactually applying filters to the filtered content, listens for that event to\nascertain when it needs to retrieve a new copy of the filter and re-apply it to\nthe filtered content."]}),"\n",(0,r.jsxs)(t.p,{children:["The FilterWorkbenchController class doesn't need to know specific details of\neach filter factory class\u2014it just needs to know that the filter has changed and\nto be able to access a copy of the filter. To support this, the application\nincludes an interface, IFilterFactory, that defines the behavior a filter\nfactory class needs to provide so the application's FilterWorkbenchController\ninstance can do its job. The IFilterFactory defines the ",(0,r.jsx)(t.code,{children:"getFilter"})," () method\nthat's used in the FilterWorkbenchController class:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"function getFilter():BitmapFilter;\n"})}),"\n",(0,r.jsxs)(t.p,{children:["Notice that the ",(0,r.jsx)(t.code,{children:"getFilter()"})," interface method definition specifies that it\nreturns a BitmapFilter instance rather than a specific type of filter. The\nBitmapFilter class does not define a specific type of filter. Rather,\nBitmapFilter is the base class on which all the filter classes are built. Each\nfilter factory class defines a specific implementation of the ",(0,r.jsx)(t.code,{children:"getFilter()"}),"\nmethod in which it returns a reference to the filter object it has built. For\nexample, here is an abbreviated version of the ConvolutionFactory class's source\ncode:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"public class ConvolutionFactory extends EventDispatcher implements IFilterFactory\n{\n    // ------- Private vars -------\n    private var _filter:ConvolutionFilter;\n    ...\n    // ------- IFilterFactory implementation -------\n    public function getFilter():BitmapFilter\n    {\n        return _filter;\n    }\n    ...\n}\n"})}),"\n",(0,r.jsxs)(t.p,{children:["In the ConvolutionFactory class's implementation of the ",(0,r.jsx)(t.code,{children:"getFilter()"})," method, it\nreturns a ConvolutionFilter instance, although any object that calls\n",(0,r.jsx)(t.code,{children:"getFilter()"})," doesn't necessarily know that\u2014according to the definition of the\n",(0,r.jsx)(t.code,{children:"getFilter()"})," method that ConvolutionFactory follows, it must return any\nBitmapFilter instance, which could be an instance of any of the ActionScript\nfilter classes."]}),"\n",(0,r.jsx)(t.h2,{id:"applying-filters-to-display-objects",children:"Applying filters to display objects"}),"\n",(0,r.jsxs)(t.p,{children:['As explained previously, the Filter Workbench application uses an instance of\nthe FilterWorkbenchController class (hereafter referred to as the "controller\ninstance"), which performs the actual task of applying filters to the selected\nvisual object. Before the controller instance can apply a filter, it first needs\nto know what image or visual content the filter should be applied to. When the\nuser selects an image, the application calls the ',(0,r.jsx)(t.code,{children:"setFilterTarget()"})," method in\nthe FilterWorkbenchController class, passing in one of the constants defined in\nthe ImageType class:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"public function setFilterTarget(targetType:ImageType):void\n{\n    ...\n    _loader = new Loader();\n    ...\n    _loader.contentLoaderInfo.addEventListener(Event.COMPLETE, targetLoadComplete);\n    ...\n}\n"})}),"\n",(0,r.jsxs)(t.p,{children:["Using that information the controller instance loads the designated file,\nstoring it in an instance variable named ",(0,r.jsx)(t.code,{children:"_currentTarget"})," once it loads:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"private var _currentTarget:DisplayObject;\n\nprivate function targetLoadComplete(event:Event):void\n{\n    ...\n    _currentTarget = _loader.content;\n    ...\n}\n"})}),"\n",(0,r.jsxs)(t.p,{children:["When the user selects a filter, the application calls the controller instance's\n",(0,r.jsx)(t.code,{children:"setFilter()"})," method, giving the controller a reference to the relevant filter\nfactory object, which it stores in an instance variable named ",(0,r.jsx)(t.code,{children:"_filterFactory"}),"."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"private var _filterFactory:IFilterFactory;\n\npublic function setFilter(factory:IFilterFactory):void\n{\n    ...\n\n    _filterFactory = factory;\n    _filterFactory.addEventListener(Event.CHANGE, filterChange);\n}\n"})}),"\n",(0,r.jsxs)(t.p,{children:["Notice that, as described previously, the controller instance doesn't know the\nspecific data type of the filter factory instance that it is given; it only\nknows that the object implements the IFilterFactory instance, meaning it has a\n",(0,r.jsx)(t.code,{children:"getFilter()"})," method and it dispatches a ",(0,r.jsx)(t.code,{children:"change"})," (",(0,r.jsx)(t.code,{children:"Event.CHANGE"}),") event when\nthe filter changes."]}),"\n",(0,r.jsxs)(t.p,{children:["When the user changes a filter's properties in the filter's panel, the\ncontroller instance finds out that the filter has changed through the filter\nfactory's ",(0,r.jsx)(t.code,{children:"change"})," event, which calls the controller instance's ",(0,r.jsx)(t.code,{children:"filterChange()"}),"\nmethod. That method, in turn, calls the ",(0,r.jsx)(t.code,{children:"applyTemporaryFilter()"})," method:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"private function filterChange(event:Event):void\n{\n    applyTemporaryFilter();\n}\n\nprivate function applyTemporaryFilter():void\n{\n    var currentFilter:BitmapFilter = _filterFactory.getFilter();\n\n    // Add the current filter to the set temporarily\n    _currentFilters.push(currentFilter);\n\n    // Refresh the filter set of the filter target\n    _currentTarget.filters = _currentFilters;\n\n    // Remove the current filter from the set\n    // (This doesn't remove it from the filter target, since\n    // the target uses a copy of the filters array internally.)\n    _currentFilters.pop();\n}\n"})}),"\n",(0,r.jsxs)(t.p,{children:["The work of applying the filter to the display object occurs within the\n",(0,r.jsx)(t.code,{children:"applyTemporaryFilter()"})," method. First, the controller retrieves a reference to\nthe filter object by calling the filter factory's ",(0,r.jsx)(t.code,{children:"getFilter()"})," method."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"var currentFilter:BitmapFilter = _filterFactory.getFilter();\n"})}),"\n",(0,r.jsxs)(t.p,{children:["The controller instance has an Array instance variable named ",(0,r.jsx)(t.code,{children:"_currentFilters"}),",\nin which it stores all the filters that have been applied to the display object.\nThe next step is to add the newly updated filter to that array:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"_currentFilters.push(currentFilter);\n"})}),"\n",(0,r.jsxs)(t.p,{children:["Next, the code assigns the array of filters to the display object's ",(0,r.jsx)(t.code,{children:"filters"}),"\nproperty, which actually applies the filters to the image:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"_currentTarget.filters = _currentFilters;\n"})}),"\n",(0,r.jsxs)(t.p,{children:['Finally, since this most recently added filter is still the "working" filter, it\nshouldn\'t be permanently applied to the display object, so it is removed from\nthe ',(0,r.jsx)(t.code,{children:"_currentFilters"})," array:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"_currentFilters.pop();\n"})}),"\n",(0,r.jsxs)(t.p,{children:["Removing this filter from the array doesn't affect the filtered display object,\nbecause a display object makes a copy of the filters array when it is assigned\nto the ",(0,r.jsx)(t.code,{children:"filters"})," property, and it uses that internal array rather than the\noriginal one. For this reason, any changes that are made to the array of filters\ndon't affect the display object until the array is assigned to the display\nobject's ",(0,r.jsx)(t.code,{children:"filters"})," property again."]})]})}function d(e={}){const{wrapper:t}={...(0,l.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}}}]);