"use strict";(globalThis.webpackChunkairsdk_dev=globalThis.webpackChunkairsdk_dev||[]).push([[13349],{28453:(e,t,a)=>{a.d(t,{R:()=>o,x:()=>d});var n=a(96540);const i={},s=n.createContext(i);function o(e){const t=n.useContext(s);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function d(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),n.createElement(s.Provider,{value:t},e.children)}},66780:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>r,contentTitle:()=>d,default:()=>h,frontMatter:()=>o,metadata:()=>n,toc:()=>l});const n=JSON.parse('{"id":"development/files-and-data/working-with-local-sql-databases-in-air/working-with-database-data-types","title":"Working with database data types","description":"When a table is created in a database, the SQL statement for creating the table","source":"@site/docs/development/files-and-data/working-with-local-sql-databases-in-air/working-with-database-data-types.md","sourceDirName":"development/files-and-data/working-with-local-sql-databases-in-air","slug":"/development/files-and-data/working-with-local-sql-databases-in-air/working-with-database-data-types","permalink":"/docs/development/files-and-data/working-with-local-sql-databases-in-air/working-with-database-data-types","draft":false,"unlisted":false,"editUrl":"https://github.com/airsdk/airsdk.dev/edit/main/docs/development/files-and-data/working-with-local-sql-databases-in-air/working-with-database-data-types.md","tags":[],"version":"current","sidebarPosition":7.9,"frontMatter":{"sidebar_position":7.9},"sidebar":"mainSidebar","previous":{"title":"Handling database errors","permalink":"/docs/development/files-and-data/working-with-local-sql-databases-in-air/handling-database-errors"},"next":{"title":"Working with byte arrays","permalink":"/docs/development/files-and-data/working-with-bytearrays/"}}');var i=a(74848),s=a(28453);const o={sidebar_position:7.9},d="Working with database data types",r={},l=[];function c(e){const t={a:"a",code:"code",h1:"h1",header:"header",p:"p",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"working-with-database-data-types",children:"Working with database data types"})}),"\n",(0,i.jsxs)(t.p,{children:["When a table is created in a database, the SQL statement for creating the table\ndefines the affinity, or data type, for each column in the table. Although\naffinity declarations can be omitted, it's a good idea to explicitly declare\ncolumn affinity in your ",(0,i.jsx)(t.code,{children:"CREATE TABLE"})," SQL statements."]}),"\n",(0,i.jsxs)(t.p,{children:["As a general rule, any object that you store in a database using an ",(0,i.jsx)(t.code,{children:"INSERT"}),"\nstatement is returned as an instance of the same data type when you execute a\n",(0,i.jsx)(t.code,{children:"SELECT"})," statement. However, the data type of the retrieved value can be\ndifferent depending on the affinity of the database column in which the value is\nstored. When a value is stored in a column, if its data type doesn't match the\ncolumn's affinity, the database attempts to convert the value to match the\ncolumn's affinity. For example, if a database column is declared with ",(0,i.jsx)(t.code,{children:"NUMERIC"}),"\naffinity, the database attempts to convert inserted data into a numeric storage\nclass ( ",(0,i.jsx)(t.code,{children:"INTEGER"})," or ",(0,i.jsx)(t.code,{children:"REAL"}),') before storing the data. The database throws an\nerror if the data can\'t be converted. According to this rule, if the String\n"12345" is inserted into a ',(0,i.jsx)(t.code,{children:"NUMERIC"})," column, the database automatically converts\nit to the integer value 12345 before storing it in the database. When it's\nretrieved with a ",(0,i.jsx)(t.code,{children:"SELECT"})," statement, the value is returned as an instance of a\nnumeric data type (such as Number) rather than as a String instance."]}),"\n",(0,i.jsx)(t.p,{children:"The best way to avoid undesirable data type conversion is to follow two rules.\nFirst, define each column with the affinity that matches the type of data that\nit is intended to store. Next, only insert values whose data type matches the\ndefined affinity. Following these rules provides two benefits. When you insert\nthe data it isn't converted unexpectedly (possibly losing its intended meaning\nas a result). In addition, when you retrieve the data it is returned with its\noriginal data type."}),"\n",(0,i.jsxs)(t.p,{children:["For more information about the available column affinity types and using data\ntypes in SQL statements, see the\n",(0,i.jsx)(t.a,{href:"/docs/development/appendixes/sql-support-in-local-databases/data-type-support",children:"Data type support"}),"."]})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}}}]);