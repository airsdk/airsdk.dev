"use strict";(self.webpackChunkairsdk_dev=self.webpackChunkairsdk_dev||[]).push([[44348],{28453:(e,n,i)=>{i.d(n,{R:()=>s,x:()=>l});var a=i(96540);const t={},o=a.createContext(t);function s(e){const n=a.useContext(o);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),a.createElement(o.Provider,{value:n},e.children)}},68742:(e,n,i)=>{i.d(n,{A:()=>a});const a=i.p+"assets/images/se_load_content_app_popup-b8706e4043e11af7558970d3cb7ef631.png"},75666:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>p,frontMatter:()=>s,metadata:()=>a,toc:()=>r});const a=JSON.parse('{"id":"development/core-actionscript-classes/working-with-application-domains","title":"Working with application domains","description":"The purpose of the ApplicationDomain class is to store a table of ActionScript","source":"@site/docs/development/core-actionscript-classes/working-with-application-domains.md","sourceDirName":"development/core-actionscript-classes","slug":"/development/core-actionscript-classes/working-with-application-domains","permalink":"/docs/development/core-actionscript-classes/working-with-application-domains","draft":false,"unlisted":false,"editUrl":"https://github.com/airsdk/airsdk.dev/edit/main/docs/development/core-actionscript-classes/working-with-application-domains.md","tags":[],"version":"current","sidebarPosition":9,"frontMatter":{"title":"Working with application domains","sidebar_position":9},"sidebar":"mainSidebar","previous":{"title":"Event handling example: Alarm Clock","permalink":"/docs/development/core-actionscript-classes/handling-events/event-handling-example-alarm-clock"},"next":{"title":"Display","permalink":"/docs/development/display/"}}');var t=i(74848),o=i(28453);const s={title:"Working with application domains",sidebar_position:9},l=void 0,c={},r=[{value:"Usage A",id:"usage-a",level:2},{value:"Usage B",id:"usage-b",level:2},{value:"Usage C",id:"usage-c",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h2:"h2",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"The purpose of the ApplicationDomain class is to store a table of ActionScript\n3.0 definitions. All code in a SWF file is defined to exist in an application\ndomain. You use application domains to partition classes that are in the same\nsecurity domain. This allows multiple definitions of the same class to exist and\nalso lets children reuse parent definitions."}),"\n",(0,t.jsxs)(n.p,{children:["You can use application domains when loading an external SWF file written in\nActionScript 3.0 using the Loader class API. (Note that you cannot use\napplication domains when loading an image or SWF file written in ActionScript\n1.0 or ActionScript 2.0.) All ActionScript 3.0 definitions contained in the\nloaded class are stored in the application domain. When loading the SWF file,\nyou can specify that the file be included in the same application domain as that\nof the Loader object, by setting the ",(0,t.jsx)(n.code,{children:"applicationDomain"})," parameter of the\nLoaderContext object to ",(0,t.jsx)(n.code,{children:"ApplicationDomain.currentDomain"}),". By putting the loaded\nSWF file in the same application domain, you can access its classes directly.\nThis can be useful if you are loading a SWF file that contains embedded media,\nwhich you can access via their associated class names, or if you want to access\nthe loaded SWF file's methods."]}),"\n",(0,t.jsx)(n.p,{children:"The following example assumes it has access to a separate Greeter.swf file that\ndefines a public method named welcome():"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-actionscript",children:'package\n{\n    import flash.display.Loader;\n    import flash.display.Sprite;\n    import flash.events.*;\n    import flash.net.URLRequest;\n    import flash.system.ApplicationDomain;\n    import flash.system.LoaderContext;\n\n    public class ApplicationDomainExample extends Sprite\n    {\n        private var ldr:Loader;\n        public function ApplicationDomainExample()\n        {\n            ldr = new Loader();\n            var req:URLRequest = new URLRequest("Greeter.swf");\n            var ldrContext:LoaderContext = new LoaderContext(false, ApplicationDomain.currentDomain);\n            ldr.contentLoaderInfo.addEventListener(Event.COMPLETE, completeHandler);\n            ldr.load(req, ldrContext);\n        }\n        private function completeHandler(event:Event):void\n        {\n            var myGreeter:Class = ApplicationDomain.currentDomain.getDefinition("Greeter") as Class;\n            var myGreeter:Greeter = Greeter(event.target.content);\n            var message:String = myGreeter.welcome("Tommy");\n            trace(message); // Hello, Tommy\n        }\n    }\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Also see the\n",(0,t.jsx)(n.a,{href:"https://airsdk.dev/reference/actionscript/3.0/flash/system/ApplicationDomain.html#includeExamplesSummary",children:"ApplicationDomain class example"}),"\nin the\n",(0,t.jsx)(n.a,{href:"https://airsdk.dev/reference/actionscript/3.0/index.html",children:"ActionScript 3.0 Reference for the Adobe Flash Platform"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"Other things to keep in mind when you work with application domains include the\nfollowing:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["All code in a SWF file is defined to exist in an application domain. The\n",(0,t.jsx)(n.em,{children:"current domain"})," is where your main application runs. The ",(0,t.jsx)(n.em,{children:"system domain"}),"\ncontains all application domains, including the current domain, which means\nthat it contains all Flash Player classes."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"All application domains, except the system domain, have an associated parent\ndomain. The parent domain for your main application's application domain is\nthe system domain. Loaded classes are defined only when their parent doesn't\nalready define them. You cannot override a loaded class definition with a\nnewer definition."}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"The following diagram shows an application that loads content from various SWF\nfiles within a single domain, domain1.com. Depending on the content you load,\ndifferent application domains can be used. The text that follows describes the\nlogic used to set the appropriate application domain for each SWF file in the\napplication."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{src:i(68742).A+"",width:"618",height:"505"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"A."})," Usage A"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"B."})," Usage B"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"C."})," Usage C"]}),"\n",(0,t.jsx)(n.p,{children:"The main application file is application1.swf. It contains Loader objects that\nload content from other SWF files. In this scenario, the current domain is\nApplication domain 1. Usage A, usage B, and usage C illustrate different\ntechniques for setting the appropriate application domain for each SWF file in\nan application."}),"\n",(0,t.jsx)(n.h2,{id:"usage-a",children:"Usage A"}),"\n",(0,t.jsx)(n.p,{children:"Partition the child SWF file by creating a child of the system domain. In the\ndiagram, Application domain 2 is created as a child of the system domain.The\napplication2.swf file is loaded in Application domain 2, and its class\ndefinitions are thus partitioned from the classes defined in application1.swf."}),"\n",(0,t.jsx)(n.p,{children:"One use of this technique is to have an old application dynamically loading a\nnewer version of the same application without conflict. There is no conflict\nbecause although the same class names are used, they are partitioned into\ndifferent application domains."}),"\n",(0,t.jsx)(n.p,{children:"The following code creates an application domain that is a child of the system\ndomain, and starts loading a SWF using that application domain:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-actionscript",children:'var appDomainA:ApplicationDomain = new ApplicationDomain();\n\nvar contextA:LoaderContext = new LoaderContext(false, appDomainA);\nvar loaderA:Loader = new Loader();\nloaderA.load(new URLRequest("application2.swf"), contextA);\n'})}),"\n",(0,t.jsx)(n.h2,{id:"usage-b",children:"Usage B"}),"\n",(0,t.jsx)(n.p,{children:"Add new class definitions to current class definitions. The application domain\nof module1.swf is set to the current domain (Application domain 1). This lets\nyou add to the application's current set of class definitions with new class\ndefinitions. This could be used for a run-time shared library of the main\napplication. The loaded SWF is treated as a remote shared library (RSL). Use\nthis technique to load RSLs by a preloader before the application starts."}),"\n",(0,t.jsx)(n.p,{children:"The following code loads a SWF, setting its application domain to the current\ndomain:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-actionscript",children:'var appDomainB:ApplicationDomain = ApplicationDomain.currentDomain;\n\nvar contextB:LoaderContext = new LoaderContext(false, appDomainB);\nvar loaderB:Loader = new Loader();\nloaderB.load(new URLRequest("module1.swf"), contextB);\n'})}),"\n",(0,t.jsx)(n.h2,{id:"usage-c",children:"Usage C"}),"\n",(0,t.jsx)(n.p,{children:"Use the parent's class definitions by creating a new child domain of the current\ndomain. The application domain of module3.swf is a child of the current domain,\nand the child uses the parent's versions of all classes. One use of this\ntechnique might be a module of a multiple-screen rich Internet application\n(RIA), loaded as a child of the main application, that uses the main\napplication's types. If you can ensure that all classes are always updated to be\nbackward compatible, and that the loading application is always newer than the\nthings it loads, the children will use the parent versions. Having a new\napplication domain also allows you to unload all the class definitions for\ngarbage collection, if you can ensure that you do not continue to have\nreferences to the child SWF."}),"\n",(0,t.jsx)(n.p,{children:"This technique lets loaded modules share the loader's singleton objects and\nstatic class members."}),"\n",(0,t.jsx)(n.p,{children:"The following code creates a new child domain of the current domain, and starts\nloading a SWF using that application domain:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-actionscript",children:'var appDomainC:ApplicationDomain = new ApplicationDomain(ApplicationDomain.currentDomain);\n\nvar contextC:LoaderContext = new LoaderContext(false, appDomainC);\nvar loaderC:Loader = new Loader();\nloaderC.load(new URLRequest("module3.swf"), contextC);\n'})})]})}function p(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}}}]);