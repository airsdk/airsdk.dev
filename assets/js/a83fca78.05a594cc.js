"use strict";(self.webpackChunkairsdk_dev=self.webpackChunkairsdk_dev||[]).push([[57454],{2738:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>d,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"development/networking-and-communication/xml-signature-validation-in-air/basics-of-xml-signature-validation","title":"Basics of XML signature validation","description":"Adobe\xae AIR\xae provides the XMLSignatureValidator class and IURIDereferencer","source":"@site/docs/development/networking-and-communication/xml-signature-validation-in-air/basics-of-xml-signature-validation.md","sourceDirName":"development/networking-and-communication/xml-signature-validation-in-air","slug":"/development/networking-and-communication/xml-signature-validation-in-air/basics-of-xml-signature-validation","permalink":"/docs/development/networking-and-communication/xml-signature-validation-in-air/basics-of-xml-signature-validation","draft":false,"unlisted":false,"editUrl":"https://github.com/airsdk/airsdk.dev/edit/main/docs/development/networking-and-communication/xml-signature-validation-in-air/basics-of-xml-signature-validation.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"mainSidebar","previous":{"title":"XML signature validation in AIR","permalink":"/docs/development/networking-and-communication/xml-signature-validation-in-air/"},"next":{"title":"About XML signatures","permalink":"/docs/development/networking-and-communication/xml-signature-validation-in-air/about-xml-signatures"}}');var r=n(74848),s=n(28453);const a={sidebar_position:1},d="Basics of XML signature validation",c={},l=[{value:"XML signature validation classes",id:"xml-signature-validation-classes",level:2},{value:"Using the XML signature validation classes",id:"using-the-xml-signature-validation-classes",level:2},{value:"The XML signature validation process",id:"the-xml-signature-validation-process",level:3},{value:"Interpreting validation results",id:"interpreting-validation-results",level:3},{value:"The validityStatus property",id:"the-validitystatus-property",level:4},{value:"The digestStatus property",id:"the-digeststatus-property",level:4},{value:"The identityStatus property",id:"the-identitystatus-property",level:4},{value:"The referencesStatus property",id:"the-referencesstatus-property",level:4}];function o(e){const t={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"basics-of-xml-signature-validation",children:"Basics of XML signature validation"})}),"\n",(0,r.jsx)(t.p,{children:"Adobe\xae AIR\xae provides the XMLSignatureValidator class and IURIDereferencer\ninterface for validating XML signatures. The XML syntax accepted by the\nXMLSignatureValidator class is a subset of the W3C recommendation for XML\nSignature Syntax and Processing. (Because only a subset of the recommendation is\nsupported, not all legal signatures can be validated.) AIR does not provide an\nAPI for creating XML signatures."}),"\n",(0,r.jsx)(t.h2,{id:"xml-signature-validation-classes",children:"XML signature validation classes"}),"\n",(0,r.jsx)(t.p,{children:"The XML signature validation API includes the following classes:"}),"\n",(0,r.jsxs)("table",{children:[(0,r.jsx)("thead",{children:(0,r.jsxs)("tr",{children:[(0,r.jsx)("th",{children:(0,r.jsx)("p",{children:"Package"})}),(0,r.jsx)("th",{children:(0,r.jsx)("p",{children:"Classes"})})]})}),(0,r.jsxs)("tbody",{children:[(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("p",{children:"flash.security"})}),(0,r.jsx)("td",{children:(0,r.jsxs)("div",{children:[(0,r.jsxs)("ul",{class:"incremental",children:[(0,r.jsx)("li",{children:(0,r.jsx)("p",{children:(0,r.jsx)("a",{href:"https://airsdk.dev/reference/actionscript/3.0/flash/security/XMLSignatureValidator.html",children:"XMLSignatureValidator"})})}),(0,r.jsx)("li",{children:(0,r.jsx)("p",{children:(0,r.jsxs)(t.p,{children:[(0,r.jsx)("a",{href:"https://airsdk.dev/reference/actionscript/3.0/flash/security/IURIDereferencer.html",children:"IURIDereferencer"}),"\n(interface)"]})})})]}),(0,r.jsx)("p",{children:(0,r.jsx)(t.p,{children:"XMLSignatureValidator string constants are defined in the following\nclasses:"})}),(0,r.jsxs)("ul",{class:"incremental",children:[(0,r.jsx)("li",{children:(0,r.jsx)("p",{children:(0,r.jsx)("a",{href:"https://airsdk.dev/reference/actionscript/3.0/flash/security/ReferencesValidationSetting.html",children:"ReferencesValidationSetting"})})}),(0,r.jsx)("li",{children:(0,r.jsx)("p",{children:(0,r.jsx)("a",{href:"https://airsdk.dev/reference/actionscript/3.0/flash/security/RevocationCheckSettings.html",children:"RevocationCheckSettings"})})}),(0,r.jsx)("li",{children:(0,r.jsx)("p",{children:(0,r.jsx)("a",{href:"https://airsdk.dev/reference/actionscript/3.0/flash/security/SignatureStatus.html",children:"SignatureStatus"})})}),(0,r.jsx)("li",{children:(0,r.jsx)("p",{children:(0,r.jsx)("a",{href:"https://airsdk.dev/reference/actionscript/3.0/flash/security/SignerTrustSettings.html",children:"SignerTrustSettings"})})})]})]})})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("p",{children:"flash.events"})}),(0,r.jsx)("td",{children:(0,r.jsx)("div",{children:(0,r.jsxs)("ul",{class:"incremental",children:[(0,r.jsx)("li",{children:(0,r.jsx)("p",{children:(0,r.jsx)("a",{href:"https://airsdk.dev/reference/actionscript/3.0/flash/events/Event.html",children:"Event"})})}),(0,r.jsx)("li",{children:(0,r.jsx)("p",{children:(0,r.jsx)("a",{href:"https://airsdk.dev/reference/actionscript/3.0/flash/events/ErrorEvent.html",children:"ErrorEvent"})})})]})})})]})]})]}),"\n",(0,r.jsx)(t.h2,{id:"using-the-xml-signature-validation-classes",children:"Using the XML signature validation classes"}),"\n",(0,r.jsx)(t.p,{children:"To use the XMLSignatureValidator class to validate an XML signature, you must:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsx)(t.p,{children:"Create an XMLSignatureValidator object"}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsxs)(t.p,{children:["Provide an implementation of the IURIDereferencer interface. The\nXMLSignatureValidator object calls the IURIDereferencer ",(0,r.jsx)(t.code,{children:"dereference()"}),"\nmethod, passing in the URI for each reference in a signature. The\n",(0,r.jsx)(t.code,{children:"dereference()"})," method must resolve the URI and return the referenced data\n(which could be in the same document as the signature, or could be in an\nexternal resource)."]}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsx)(t.p,{children:"Set the certificate trust, revocation checking, and reference validation\nsettings of the XMLSignatureValidator object as appropriate for your\napplication."}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsxs)(t.p,{children:["Add event listeners for the ",(0,r.jsx)(t.code,{children:"complete"})," and ",(0,r.jsx)(t.code,{children:"error"})," events."]}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsxs)(t.p,{children:["Call the ",(0,r.jsx)(t.code,{children:"verify()"})," method, passing in the signature to validate."]}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsxs)(t.p,{children:["Handle the ",(0,r.jsx)(t.code,{children:"complete"})," and ",(0,r.jsx)(t.code,{children:"error"})," events and interpret the results."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(t.p,{children:["The following example implements a ",(0,r.jsx)(t.code,{children:"validate()"})," function that verifies the\nvalidity of an XML signature. The XMLSignatureValidator properties are set such\nthat the signing certificate must be in the system trust store, or chain to a\ncertificate in the trust store. The example also assumes that a suitable\nIURIDereferencer class named ",(0,r.jsx)(t.em,{children:"XMLDereferencer"})," exists."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:'private function validate( xmlSignature:XML ):void\n{\n\tvar verifier:XMLSignatureValidator = new XMLSignatureValidator();\n\tverifier.addEventListener(Event.COMPLETE, verificationComplete);\n\tverifier.addEventListener(ErrorEvent.ERROR, verificationError);\n\ttry\n\t{\n\t\tverifier.uriDereferencer = new XMLDereferencer();\n\n\t\tverifier.referencesValidationSetting =\n\t\t\tReferencesValidationSetting.VALID_IDENTITY;\n\t\tverifier.revocationCheckSetting = RevocationCheckSettings.BEST_EFFORT;\n\t\tverifier.useSystemTrustStore = true;\n\n\t\t//Verify the signature\n\t\tverifier.verify( xmlSignature );\n\t}\n\tcatch (e:Error)\n  {\n      trace("Verification error.\\n" + e);\n  }\n}\n\n//Trace verification results\nprivate function verificationComplete(event:Event):void\n{\n\tvar signature:XMLSignatureValidator = event.target as XMLSignatureValidator;\n\ttrace("Signature status: " + signature.validityStatus + "\\n");\n\ttrace("  Digest status: " + signature.digestStatus + "\\n");\n\ttrace("  Identity status: " + signature.identityStatus + "\\n");\n\ttrace("  Reference status: " + signature.referencesStatus + "\\n");\n}\n\nprivate function verificationError(event:ErrorEvent):void\n{\n\ttrace("Verification error.\\n" + event.text);\n}\n'})}),"\n",(0,r.jsx)(t.h3,{id:"the-xml-signature-validation-process",children:"The XML signature validation process"}),"\n",(0,r.jsxs)(t.p,{children:["When you call the XMLSignatureValidator ",(0,r.jsx)(t.code,{children:"verify()"})," method, AIR performs the\nfollowing steps:"]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsx)(t.p,{children:"The runtime verifies the cryptographic integrity of the signature using the\npublic key of the signing certificate."}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsx)(t.p,{children:"The runtime establishes the cryptographic integrity, identity, and\ntrustworthiness of the certificate based on the current settings of the\nXMLSignatureValidator object."}),"\n",(0,r.jsx)(t.p,{children:"The trust placed in the signing certificate is key to the integrity of the\nvalidation process. Signature validation is conducted using a well-defined\ncryptographic process, but the trustworthiness of the signing certificate is a\njudgment that cannot be made algorithmically."}),"\n",(0,r.jsx)(t.p,{children:"In general, you have three ways to decide whether a certificate is\ntrustworthy:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsx)(t.p,{children:"By relying on certification authorities and the operating system trust\nstore."}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsx)(t.p,{children:"By obtaining, directly from the signer, a copy of the certificate, another\ncertificate that serves as a trust anchor for the certificate, or sufficient\ninformation to reliably identify the certificate, such as the public key."}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsx)(t.p,{children:"Asking the end user of your application if they trust the certificate. Such\na query is invalid with self-signed certificates since the identifying\ninformation in the certificate is inherently unreliable."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsx)(t.p,{children:"The runtime verifies the cryptographic integrity of the signed data."}),"\n",(0,r.jsxs)(t.p,{children:["The signed data is verified with the help of your IURIDereferencer\nimplementation. For each reference in the signature document, the\nIURIDereferencer implementation ",(0,r.jsx)(t.code,{children:"dereference()"})," method is called. The data\nreturned by the ",(0,r.jsx)(t.code,{children:"dereference()"})," method is used to compute the reference\ndigest. This digest value is compared to the digest recorded in the signature\ndocument. If the digests match, then the data has not been altered since it\nwas signed."]}),"\n",(0,r.jsx)(t.p,{children:"One important consideration when relying on the results of validating an XML\nsignature is that only what is signed is secure. For example, consider a\nsigned manifest listing the files in a package. When the XMLSignatureValidator\nverifies the signature, it only checks whether the manifest itself is\nunaltered. The data in the files is not signed, so the signature will still\nvalidate when files referenced in the manifest are changed or deleted."}),"\n",(0,r.jsx)(t.p,{children:"Note: To verify files in such a manifest, you can compute the digest of the\nfile data (using the same hashing algorithm used in the manifest) and compare\nthe result to the digest stored in the signed manifest. In some cases, you\nshould also check for the presence of additional files."}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(t.h3,{id:"interpreting-validation-results",children:"Interpreting validation results"}),"\n",(0,r.jsxs)(t.p,{children:["The validation results are reported by the status properties of the\nXMLSignatureValidator object. These properties can be read after the validator\nobject dispatches the ",(0,r.jsx)(t.em,{children:"complete"})," event. The four status properties include:\n",(0,r.jsx)(t.code,{children:"validityStatus"}),", ",(0,r.jsx)(t.code,{children:"digestStatus"}),", ",(0,r.jsx)(t.code,{children:"identityStatus"}),", and ",(0,r.jsx)(t.code,{children:"referencesStatus"}),"."]}),"\n",(0,r.jsx)(t.h4,{id:"the-validitystatus-property",children:"The validityStatus property"}),"\n",(0,r.jsxs)(t.p,{children:["The ",(0,r.jsx)(t.code,{children:"validityStatus"})," property reports the overall validity of the signature. The\n",(0,r.jsx)(t.code,{children:"validityStatus"})," depends on the state of the other three status properties and\ncan have one of the following values:"]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"valid"})," \u2014 If ",(0,r.jsx)(t.code,{children:"digestStatus"}),", ",(0,r.jsx)(t.code,{children:"identityStatus"}),", and ",(0,r.jsx)(t.code,{children:"referencesStatus"})," are all\n",(0,r.jsx)(t.code,{children:"valid"}),"."]}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"invalid"})," \u2014 If one or more of the individual status properties is ",(0,r.jsx)(t.code,{children:"invalid"}),"."]}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"unknown"})," \u2014 If one or more of the individual status properties is ",(0,r.jsx)(t.code,{children:"unknown"}),"\nand no individual status is ",(0,r.jsx)(t.code,{children:"invalid"}),"."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(t.h4,{id:"the-digeststatus-property",children:"The digestStatus property"}),"\n",(0,r.jsxs)(t.p,{children:["The ",(0,r.jsx)(t.code,{children:"digestStatus"})," property reports the results of the cryptographic\nverification of the message digest. The ",(0,r.jsx)(t.code,{children:"digestStatus"})," property can have one of\nthe following values:"]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"valid"})," \u2014 If the signature document itself is unaltered since signing."]}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"invalid"})," \u2014 If the signature document has been altered or is malformed."]}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"unknown"})," \u2014 If the ",(0,r.jsx)(t.code,{children:"verify()"})," method has not completed without error."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(t.h4,{id:"the-identitystatus-property",children:"The identityStatus property"}),"\n",(0,r.jsxs)(t.p,{children:["The ",(0,r.jsx)(t.code,{children:"identityStatus"})," property reports the status of the signing certificate. The\nvalue of this property depends on several factors including:"]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsx)(t.p,{children:"the cryptographic integrity of the certificate"}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsx)(t.p,{children:"whether the certificate is expired or revoked"}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsx)(t.p,{children:"whether the certificate is trusted on the current machine"}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsxs)(t.p,{children:["the state of the XMLSignatureValidator object (such as whether additional\ncertificates have been added for building the trust chain, whether those\ncertificates are trusted, and the values of the ",(0,r.jsx)(t.code,{children:"useSystemTrustStore"})," and\n",(0,r.jsx)(t.code,{children:"revocationCheckSettings"})," properties)"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(t.p,{children:["The ",(0,r.jsx)(t.code,{children:"identityStatus"})," property can have the following values:"]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"valid"})," \u2014 To be considered valid, the signing certificate must meet the\nfollowing conditions:"]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsx)(t.p,{children:"The signing certificate must be unaltered."}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsx)(t.p,{children:"The signing certificate must not be expired or revoked\u2014except when a valid\ntimestamp is present in the signature. If the signature is timestamped, the\ncertificate will be considered valid as long as it was valid at the time the\ndocument was signed. (The certificate used by the timestamp service to sign\nthe timestamp must chain to a trusted root certificate on the user's\ncomputer.)"}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsxs)(t.p,{children:["The signing certificate is trusted. A certificate is trusted if the\ncertificate is in the system trust store or chains to another certificate in\nthe system trust store and you set the ",(0,r.jsx)(t.code,{children:"useSystemTrustStore"})," property to\ntrue. You can also designate a certificate as trusted using the\n",(0,r.jsx)(t.code,{children:"addCertificate()"})," method of the XMLSignatureValidator object."]}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsx)(t.p,{children:"The certificate is, in fact, the signing certificate."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"invalid"})," \u2014 The certificate is expired or revoked\u2014and no timestamp proving\nvalidity at the time of signing is present\u2014or the certificate has been\naltered."]}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"unknown"})," \u2014 If the certificate is not invalid, but is not trusted either.\nSelf-signed certificates, for example, will be reported as ",(0,r.jsx)(t.code,{children:"unknown"})," (unless\nexplicitly trusted). The ",(0,r.jsx)(t.code,{children:"identityStatus"})," is also reported as ",(0,r.jsx)(t.code,{children:"unknown"})," if the\n",(0,r.jsx)(t.code,{children:"verify()"})," method has not completed without error or if the identity has not\nbeen checked because the signature digest is invalid."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(t.h4,{id:"the-referencesstatus-property",children:"The referencesStatus property"}),"\n",(0,r.jsxs)(t.p,{children:["The ",(0,r.jsx)(t.code,{children:"referencesStatus"})," property reports the cryptographic integrity of the\nreferences in the SignedData element of the signature."]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"valid"})," \u2014 If the computed digest of every reference in the signature matches\nthe corresponding digest recorded in the XML signature. A ",(0,r.jsx)(t.code,{children:"valid"})," status\nindicates that the signed data has not been altered."]}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"invalid"})," \u2014 If any computed digest does not match the corresponding digest in\nthe signature."]}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"unknown"})," \u2014 If the reference digests have not been checked. The references are\nnot checked if the overall signature digest is ",(0,r.jsx)(t.code,{children:"invalid"})," or the signing\ncertificate is invalid. If the ",(0,r.jsx)(t.code,{children:"identityStatus"})," is ",(0,r.jsx)(t.code,{children:"unknown"}),", then the\nreferences are only checked when the ",(0,r.jsx)(t.code,{children:"referencesValidationSetting"})," is\n",(0,r.jsx)(t.code,{children:"validOrUnknown"}),"."]}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(o,{...e})}):o(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>d});var i=n(96540);const r={},s=i.createContext(r);function a(e){const t=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function d(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),i.createElement(s.Provider,{value:t},e.children)}}}]);