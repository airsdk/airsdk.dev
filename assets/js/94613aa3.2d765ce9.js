"use strict";(self.webpackChunkairsdk_dev=self.webpackChunkairsdk_dev||[]).push([[25039],{87:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/th_UV_ABC_distort-bb2bb36a64c1310851a4a5ed99281094.png"},2989:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/th_square_triangle_indices-f4f0ff087d0a1b9d7d3942a6e816760e.png"},6053:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"development/display/working-in-three-dimensions/using-triangles-for-3d-effects","title":"Using triangles for 3D effects","description":"In ActionScript, you perform bitmap transformations using the","source":"@site/docs/development/display/working-in-three-dimensions/using-triangles-for-3d-effects.md","sourceDirName":"development/display/working-in-three-dimensions","slug":"/development/display/working-in-three-dimensions/using-triangles-for-3d-effects","permalink":"/docs/development/display/working-in-three-dimensions/using-triangles-for-3d-effects","draft":false,"unlisted":false,"editUrl":"https://github.com/airsdk/airsdk.dev/edit/main/docs/development/display/working-in-three-dimensions/using-triangles-for-3d-effects.md","tags":[],"version":"current","frontMatter":{},"sidebar":"mainSidebar","previous":{"title":"Understanding 3D display objects in Flash Player and the AIR runtime","permalink":"/docs/development/display/working-in-three-dimensions/understanding-3d-display-objects-in-flash-player-and-the-air-runtime"},"next":{"title":"Text","permalink":"/docs/development/text/"}}');var a=t(74848),r=t(28453);const s={},o="Using triangles for 3D effects",c={},d=[{value:"Transforming bitmaps",id:"transforming-bitmaps",level:2},{value:"UV mapping",id:"uv-mapping",level:2},{value:"Culling",id:"culling",level:2}];function l(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",img:"img",p:"p",pre:"pre",strong:"strong",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"using-triangles-for-3d-effects",children:"Using triangles for 3D effects"})}),"\n",(0,a.jsxs)(n.p,{children:["In ActionScript, you perform bitmap transformations using the\n",(0,a.jsx)(n.code,{children:"Graphics.drawTriangles()"})," method, because 3D models are represented by a\ncollection of triangles in space. (However, Flash Player and AIR do not support\na depth buffer, so display objects are still inherently flat, or 2D. This is\ndescribed in\n",(0,a.jsx)(n.a,{href:"/docs/development/display/working-in-three-dimensions/understanding-3d-display-objects-in-flash-player-and-the-air-runtime",children:"Understanding 3D display objects in Flash Player and the AIR runtime"}),".)\nThe ",(0,a.jsx)(n.code,{children:"Graphics.drawTriangles()"})," method is like the ",(0,a.jsx)(n.code,{children:"Graphics.drawPath()"})," method,\nas it takes a set of coordinates to draw a triangle path."]}),"\n",(0,a.jsxs)(n.p,{children:["To familiarize yourself with using ",(0,a.jsx)(n.code,{children:"Graphics.drawPath()"}),", see\n",(0,a.jsx)(n.a,{href:"/docs/development/display/using-the-drawing-api/drawing-paths",children:"Drawing Paths"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"Graphics.drawTriangles()"})," method uses a Vector.<Number> to specify the\npoint locations for the triangle path:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:'drawTriangles(vertices:Vector.<Number>, indices:Vector.<int> = null, uvtData:Vector.<Number> = null, culling:String = "none"):void\n'})}),"\n",(0,a.jsxs)(n.p,{children:["The first parameter of ",(0,a.jsx)(n.code,{children:"drawTriangles()"})," is the only required parameter: the\n",(0,a.jsx)(n.code,{children:"vertices"})," parameter. This parameter is a vector of numbers defining the\ncoordinates through which your triangles are drawn. Every three sets of\ncoordinates (six numbers) represents a triangle path. Without the ",(0,a.jsx)(n.code,{children:"indices"}),"\nparameter, the length of the vector should always be a factor of six, since each\ntriangle requires three coordinate pairs (three sets of two x/y values). For\nexample:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"graphics.beginFill(0xFF8000);\ngraphics.drawTriangles(\nVector.<Number>([\n        10,10,  100,10,  10,100,\n        110,10, 110,100, 20,100]));\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Neither of these triangles share any points, but if they did, the second\n",(0,a.jsx)(n.code,{children:"drawTriangles()"})," parameter, ",(0,a.jsx)(n.code,{children:"indices"}),", could be used to reuse values in the\n",(0,a.jsx)(n.code,{children:"vertices"})," vector for more than one triangle."]}),"\n",(0,a.jsxs)(n.p,{children:["When using the ",(0,a.jsx)(n.code,{children:"indices"})," parameter, be aware that the ",(0,a.jsx)(n.code,{children:"indices"})," values are point\nindices, not indices that relate directly to the ",(0,a.jsx)(n.code,{children:"vertices"})," array elements. In\nother words, an index in the ",(0,a.jsx)(n.code,{children:"vertices"})," vector as defined by ",(0,a.jsx)(n.code,{children:"indices"})," is\nactually the real index divided by 2. For the third point of a ",(0,a.jsx)(n.code,{children:"vertices"}),"\nvector, for example, use an ",(0,a.jsx)(n.code,{children:"indices"})," value of 2, even though the first numeric\nvalue of that point starts at the vector index of 4."]}),"\n",(0,a.jsxs)(n.p,{children:["For example, merge two triangles to share the diagonal edge using the ",(0,a.jsx)(n.code,{children:"indices"}),"\nparameter:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"graphics.beginFill(0xFF8000);\ngraphics.drawTriangles(\nVector.<Number>([10,10, 100,10, 10,100, 100,100]),\nVector.<int>([0,1,2, 1,3,2]));\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Notice that though a square has now been drawn using two triangles, only four\npoints were specified in the ",(0,a.jsx)(n.code,{children:"vertices"})," vector. Using ",(0,a.jsx)(n.code,{children:"indices"}),", the two points\nshared by the two triangles are reused for each triangle. This reduces the\noverall vertices count from 6 (12 numbers) to 4 (8 numbers):"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{src:t(2989).A+"",width:"204",height:"250"})}),"\n",(0,a.jsx)(n.p,{children:"A square drawn with two triangles using the vertices parameter"}),"\n",(0,a.jsx)(n.p,{children:"This technique becomes useful with larger triangle meshes where most points are\nshared by multiple triangles."}),"\n",(0,a.jsx)(n.p,{children:"All fills can be applied to triangles. The fills are applied to the resulting\ntriangle mesh as they would to any other shape."}),"\n",(0,a.jsx)(n.h2,{id:"transforming-bitmaps",children:"Transforming bitmaps"}),"\n",(0,a.jsx)(n.p,{children:'Bitmap transformations provide the illusion of perspective or "texture" on a\nthree-dimensional object. Specifically, you can distort a bitmap toward a\nvanishing point so the image appears to shrink as it moves toward the vanishing\npoint. Or, you can use a two-dimensional bitmap to create a surface for a\nthree-dimensional object, providing the illusion of texture or "wrapping" on\nthat three-dimensional object.'}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{src:t(13442).A+"",width:"310",height:"226"})}),"\n",(0,a.jsx)(n.p,{children:"A two-dimensional surface using a vanishing point and a three-dimensional object\nwrapped with a bitmap."}),"\n",(0,a.jsx)(n.h2,{id:"uv-mapping",children:"UV mapping"}),"\n",(0,a.jsxs)(n.p,{children:["Once you start working with textures, you'll want to make use of the uvtData\nparameter of ",(0,a.jsx)(n.code,{children:"drawTriangles()"}),". This parameter allows you to set up UV mapping\nfor bitmap fills."]}),"\n",(0,a.jsx)(n.p,{children:"UV mapping is a method for texturing objects. It relies on two values, a U\nhorizontal (x) value and a V vertical (y) value. Rather than being based on\npixel values, they are based on percentages. 0 U and 0 V is the upper-left of an\nimage and 1 U and 1 V is the lower-right:"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{src:t(9176).A+"",width:"283",height:"199"})}),"\n",(0,a.jsx)(n.p,{children:"The UV 0 and 1 locations on a bitmap image"}),"\n",(0,a.jsx)(n.p,{children:"Vectors of a triangle can be given UV coordinates to associate themselves with\nthe respective locations on an image:"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{src:t(8672).A+"",width:"295",height:"199"})}),"\n",(0,a.jsx)(n.p,{children:"The UV coordinates of a triangular area of a bitmap image"}),"\n",(0,a.jsx)(n.p,{children:"The UV values stay consistent with the points of the triangle:"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{src:t(87).A+"",width:"216",height:"207"})}),"\n",(0,a.jsx)(n.p,{children:"The vertices of the triangle move and the bitmap distorts to keep the UV values\nfor an individual point the same"}),"\n",(0,a.jsx)(n.p,{children:"As ActionScript 3D transformations are applied to the triangle associated with\nthe bitmap, the bitmap image is applied to the triangle based on the UV values.\nSo, instead of using matrix calculations, set or adjust the UV values to create\na three-dimensional effect."}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"Graphics.drawTriangles()"}),' method also accepts an optional piece of\ninformation for three-dimensional transformations: the T value. The T value in\nuvtData represents the 3D perspective, or more specifically, the scale factor of\nthe associated vertex. UVT mapping adds perspective correction to UV mapping.\nFor example, if an object is positioned in 3D space away from the viewpoint so\nthat it appears to be 50% its "original" size, the T value of that object would\nbe 0.5. Since triangles are drawn to represent objects in 3D space, their\nlocations along the z-axis determine their T values. The equation that\ndetermines the T value is:']}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"T = focalLength/(focalLength + z);\n"})}),"\n",(0,a.jsx)(n.p,{children:'In this equation, focalLength represents a focal length or calculated "screen"\nlocation which dictates the amount of perspective provided in the view.'}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{src:t(78669).A+"",width:"444",height:"279"})}),"\n",(0,a.jsx)(n.p,{children:"The focal length and z value"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"A."})," viewpoint"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"B."})," screen"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"C."})," 3D object"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"D."})," focalLength value"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"E."})," z value"]}),"\n",(0,a.jsx)(n.p,{children:"The value of T is used to scale basic shapes to make them seem further in the\ndistance. It is usually the value used to convert 3D points to 2D points. In the\ncase of UVT data, it is also used to scale a bitmap between the points within a\ntriangle with perspective."}),"\n",(0,a.jsxs)(n.p,{children:["When you define UVT values, the T value directly follows the UV values defined\nfor a vertex. With the inclusion of T, every three values in the ",(0,a.jsx)(n.code,{children:"uvtData"}),"\nparameter (U, V, and T) match up with every two values in the ",(0,a.jsx)(n.code,{children:"vertices"}),"\nparameter (x, and y). With UV values alone, uvtData.length == vertices.length.\nWith the inclusion of a T value, uvtData.length = 1.5*vertices.length."]}),"\n",(0,a.jsx)(n.p,{children:'The following example shows a plane being rotated in 3D space using UVT data.\nThis example uses an image called ocean.jpg and a "helper" class, ImageLoader,\nto load the ocean.jpg image so it can be assigned to the BitmapData object.'}),"\n",(0,a.jsx)(n.p,{children:"Here is the ImageLoader class source (save this code into a file named\nImageLoader.as):"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:'package {\n    import flash.display.*\n    import flash.events.*;\n    import flash.net.URLRequest;\n    public class ImageLoader extends Sprite {\n        public var url:String;\n        public var bitmap:Bitmap;\n        public function ImageLoader(loc:String = null) {\n            if (loc != null){\n                url = loc;\n                loadImage();\n            }\n        }\n        public function loadImage():void{\n            if (url != null){\n                var loader:Loader = new Loader();\n                loader.contentLoaderInfo.addEventListener(Event.COMPLETE, onComplete);\n                loader.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, onIoError);\n\n                var req:URLRequest = new URLRequest(url);\n                loader.load(req);\n            }\n        }\n\n        private function onComplete(event:Event):void {\n            var loader:Loader = Loader(event.target.loader);\n            var info:LoaderInfo = LoaderInfo(loader.contentLoaderInfo);\n            this.bitmap = info.content as Bitmap;\n            this.dispatchEvent(new Event(Event.COMPLETE));\n        }\n\n        private function onIoError(event:IOErrorEvent):void {\n            trace("onIoError: " + event);\n        }\n    }\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"And here is the ActionScript that uses triangles, UV mapping, and T values to\nmake the image appear as if it is shrinking toward a vanishing point and\nrotating. Save this code in a file named Spinning3dOcean.as:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:'package {\n    import flash.display.*\n    import flash.events.*;\n    import flash.utils.getTimer;\n\n    public class Spinning3dOcean extends Sprite {\n        // plane vertex coordinates (and t values)\n        var x1:Number = -100,    y1:Number = -100,    z1:Number = 0,    t1:Number = 0;\n        var x2:Number = 100,    y2:Number = -100,    z2:Number = 0,    t2:Number = 0;\n        var x3:Number = 100,    y3:Number = 100,    z3:Number = 0,    t3:Number = 0;\n        var x4:Number = -100,    y4:Number = 100,    z4:Number = 0,    t4:Number = 0;\n        var focalLength:Number = 200;\n        // 2 triangles for 1 plane, indices will always be the same\n        var indices:Vector.<int>;\n\n        var container:Sprite;\n\n        var bitmapData:BitmapData; // texture\n        var imageLoader:ImageLoader;\n        public function Spinning3dOcean():void {\n            indices =  new Vector.<int>();\n            indices.push(0,1,3, 1,2,3);\n\n            container = new Sprite(); // container to draw triangles in\n            container.x = 200;\n            container.y = 200;\n            addChild(container);\n\n            imageLoader = new ImageLoader("ocean.jpg");\n            imageLoader.addEventListener(Event.COMPLETE, onImageLoaded);\n        }\n        function onImageLoaded(event:Event):void {\n            bitmapData = imageLoader.bitmap.bitmapData;\n            // animate every frame\n            addEventListener(Event.ENTER_FRAME, rotatePlane);\n        }\n        function rotatePlane(event:Event):void {\n            // rotate vertices over time\n            var ticker = getTimer()/400;\n            z2 = z3 = -(z1 = z4 = 100*Math.sin(ticker));\n            x2 = x3 = -(x1 = x4 = 100*Math.cos(ticker));\n\n            // calculate t values\n            t1 = focalLength/(focalLength + z1);\n            t2 = focalLength/(focalLength + z2);\n            t3 = focalLength/(focalLength + z3);\n            t4 = focalLength/(focalLength + z4);\n\n            // determine triangle vertices based on t values\n            var vertices:Vector.<Number> = new Vector.<Number>();\n            vertices.push(x1*t1,y1*t1, x2*t2,y2*t2, x3*t3,y3*t3, x4*t4,y4*t4);\n            // set T values allowing perspective to change\n            // as each vertex moves around in z space\n            var uvtData:Vector.<Number> = new Vector.<Number>();\n            uvtData.push(0,0,t1, 1,0,t2, 1,1,t3, 0,1,t4);\n\n            // draw\n            container.graphics.clear();\n            container.graphics.beginBitmapFill(bitmapData);\n            container.graphics.drawTriangles(vertices, indices, uvtData);\n        }\n    }\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:'To test this example, save these two class files in the same directory as an\nimage named "ocean.jpg". You can see how the original bitmap is transformed to\nappear as if it is vanishing in the distance and rotating in 3D space.'}),"\n",(0,a.jsx)(n.h2,{id:"culling",children:"Culling"}),"\n",(0,a.jsx)(n.p,{children:'Culling is the process that determines which surfaces of a three-dimensional\nobject the renderer should not render because they are hidden from the current\nviewpoint. In 3D space, the surface on the "back" of a three-dimensional object\nis hidden from the viewpoint:'}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{src:t(14964).A+"",width:"228",height:"201"})}),"\n",(0,a.jsx)(n.p,{children:"The back of a 3D object is hidden from the viewpoint."}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"A."})," viewpoint"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"B."})," 3D object"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"C."})," the back of a three dimensional object"]}),"\n",(0,a.jsx)(n.p,{children:"Inherently all triangles are always rendered no matter their size, shape, or\nposition. Culling insures that Flash Player or AIR renders your 3D object\ncorrectly. In addition, to save on rendering cycles, sometimes you want some\ntriangles to be skipped by the render. Consider a cube rotating in space. At any\ngiven time, you'll never see more than three sides of that cube since the sides\nnot in view would be facing the other direction on the other side of the cube.\nSince those sides are not going to be seen, the renderer shouldn't draw them.\nWithout culling, Flash Player or AIR renders both the front and back sides."}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{src:t(98650).A+"",width:"129",height:"125"})}),"\n",(0,a.jsx)(n.p,{children:"A cube has sides not visible from the current viewpoint"}),"\n",(0,a.jsxs)(n.p,{children:["So, the ",(0,a.jsx)(n.code,{children:"Graphics.drawTriangles()"})," method has a fourth parameter to establish a\nculling value:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:'public function drawTriangles(vertices:Vector.<Number>, indices:Vector.<int> = null, uvtData:Vector.<Number> = null, culling:String = "none"):void\n'})}),"\n",(0,a.jsxs)(n.p,{children:["The culling parameter is a value from the ",(0,a.jsx)(n.code,{children:"TriangleCulling"})," enumeration class:\n",(0,a.jsx)(n.code,{children:"TriangleCulling.NONE"}),", ",(0,a.jsx)(n.code,{children:"TriangleCulling.POSITIVE"}),", and\n",(0,a.jsx)(n.code,{children:"TriangleCulling.NEGATIVE"}),". These values are dependent upon the direction of the\ntriangle path defining the surface of the object. The ActionScript API for\ndetermining the culling assumes that all out-facing triangles of a 3D shape are\ndrawn with the same path direction. Once a triangle face is turned around, the\npath direction also changes. At that point, the triangle can be culled (removed\nfrom rendering)."]}),"\n",(0,a.jsxs)(n.p,{children:["So, a ",(0,a.jsx)(n.code,{children:"TriangleCulling"})," value of ",(0,a.jsx)(n.code,{children:"POSITIVE"})," removes triangles with positive path\ndirection (clockwise). A ",(0,a.jsx)(n.code,{children:"TriangleCulling"})," value of ",(0,a.jsx)(n.code,{children:"NEGATIVE"})," removes triangles\nwith a negative (counterclockwise) path direction. In the case of a cube, while\nthe front facing surfaces have a positive path direction, the back facing\nsurfaces have a negative path direction:"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{src:t(79106).A+"",width:"380",height:"166"})}),"\n",(0,a.jsx)(n.p,{children:'A cube "unwrapped" to show the path direction. When "wrapped", the back side\npath direction is reversed.'}),"\n",(0,a.jsxs)(n.p,{children:["To see how culling works, start with the earlier example from\n",(0,a.jsx)(n.a,{href:"/docs/development/display/working-in-three-dimensions/using-triangles-for-3d-effects#uv-mapping",children:"UV mapping"}),", set the culling\nparameter of the ",(0,a.jsx)(n.code,{children:"drawTriangles()"})," method to ",(0,a.jsx)(n.code,{children:"TriangleCulling.NEGATIVE"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"container.graphics.drawTriangles(vertices, indices, uvtData, TriangleCulling.NEGATIVE);\n"})}),"\n",(0,a.jsx)(n.p,{children:'Notice the "back" side of the image is not rendered as the object rotates.'})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},8672:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/th_UVcoord_triangle-5edd2493db0a3eb09be848a5ee4ec38c.png"},9176:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/th_UVcoord_00-a1e500cc5bc5aab52aa1fe36deab1761.png"},13442:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/th_ocean_perspective-b0bd214380ab4b82b0ec11142eadc2b4.png"},14964:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/th_backside_hidden-c409e858d33bd07196f9b4c42462af3e.png"},28453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>o});var i=t(96540);const a={},r=i.createContext(a);function s(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),i.createElement(r.Provider,{value:n},e.children)}},78669:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/th_focallength_screen-61cea391c4aa35fa5f278b5754ba798c.png"},79106:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/th_cube_with_winding-f1b99acd52c236da52e411f182aab4fe.png"},98650:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/th_cube_visible_sides-9734702b5485144ed7cd7847dbcf80e8.png"}}]);