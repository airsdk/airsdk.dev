"use strict";(self.webpackChunkairsdk_dev=self.webpackChunkairsdk_dev||[]).push([[45752],{27920:(e,n,t)=>{t.d(n,{A:()=>s});const s=t.p+"assets/images/eh_error_event_dialog-bc54d08ba43e9c602f504711118858cc.png"},28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>a});var s=t(96540);const i={},r=s.createContext(i);function o(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(r.Provider,{value:n},e.children)}},42028:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"development/core-actionscript-classes/handling-events/event-listeners","title":"Event listeners","description":"Event listeners, which are also called event handlers, are functions that Flash","source":"@site/docs/development/core-actionscript-classes/handling-events/event-listeners.md","sourceDirName":"development/core-actionscript-classes/handling-events","slug":"/development/core-actionscript-classes/handling-events/event-listeners","permalink":"/docs/development/core-actionscript-classes/handling-events/event-listeners","draft":false,"unlisted":false,"editUrl":"https://github.com/airsdk/airsdk.dev/edit/main/docs/development/core-actionscript-classes/handling-events/event-listeners.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5},"sidebar":"mainSidebar","previous":{"title":"Event objects","permalink":"/docs/development/core-actionscript-classes/handling-events/event-objects"},"next":{"title":"Event handling example: Alarm Clock","permalink":"/docs/development/core-actionscript-classes/handling-events/event-handling-example-alarm-clock"}}');var i=t(74848),r=t(28453);const o={sidebar_position:5},a="Event listeners",c={},l=[{value:"Creating a listener function",id:"creating-a-listener-function",level:2},{value:"Listener function defined outside of a class",id:"listener-function-defined-outside-of-a-class",level:4},{value:"Listener function defined as a class method",id:"listener-function-defined-as-a-class-method",level:4},{value:"Event listener that should not be used",id:"event-listener-that-should-not-be-used",level:4},{value:"Managing event listeners",id:"managing-event-listeners",level:2},{value:"Adding event listeners",id:"adding-event-listeners",level:4},{value:"Removing event listeners",id:"removing-event-listeners",level:4},{value:"Dispatching events",id:"dispatching-events",level:4},{value:"Checking for existing event listeners",id:"checking-for-existing-event-listeners",level:4},{value:"Error events without listeners",id:"error-events-without-listeners",level:2}];function d(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",h4:"h4",header:"header",img:"img",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"event-listeners",children:"Event listeners"})}),"\n",(0,i.jsxs)(n.p,{children:["Event listeners, which are also called event handlers, are functions that Flash\nPlayer and AIR execute in response to specific events. Adding an event listener\nis a two-step process. First, you create a function or class method for Flash\nPlayer or AIR to execute in response to the event. This is sometimes called the\nlistener function or the event handler function. Second, you use the\n",(0,i.jsx)(n.code,{children:"addEventListener()"})," method to register your listener function with the target\nof the event or any display list object that lies along the appropriate event\nflow."]}),"\n",(0,i.jsx)(n.h2,{id:"creating-a-listener-function",children:"Creating a listener function"}),"\n",(0,i.jsxs)(n.p,{children:["The creation of listener functions is one area where the ActionScript 3.0 event\nmodel deviates from the DOM event model. In the DOM event model, there is a\nclear distinction between an event listener and a listener function: an event\nlistener is an instance of a class that implements the EventListener interface,\nwhereas a listener function is a method of that class named ",(0,i.jsx)(n.code,{children:"handleEvent()"}),". In\nthe DOM event model, you register the class instance that contains the listener\nfunction rather than the actual listener function."]}),"\n",(0,i.jsxs)(n.p,{children:["In the ActionScript 3.0 event model, there is no distinction between an event\nlistener and a listener function. ActionScript 3.0 does not have an\nEventListener interface, and listener functions can be defined outside a class\nor as part of a class. Moreover, listener functions do not have to be named\n",(0,i.jsx)(n.code,{children:"handleEvent()"})," \u2014they can be named with any valid identifier. In ActionScript\n3.0, you register the name of the actual listener function."]}),"\n",(0,i.jsx)(n.h4,{id:"listener-function-defined-outside-of-a-class",children:"Listener function defined outside of a class"}),"\n",(0,i.jsxs)(n.p,{children:["The following code creates a simple SWF file that displays a red square shape. A\nlistener function named ",(0,i.jsx)(n.code,{children:"clickHandler()"}),", which is not part of a class, listens\nfor mouse click events on the red square."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-actionscript",children:'package \n{ \n    import flash.display.Sprite;\n\n    public class ClickExample extends Sprite\n    {\n        public function ClickExample() \n        { \n            var child:ChildSprite = new ChildSprite(); \n            addChild(child); \n        } \n    }\n} \n \nimport flash.display.Sprite; \nimport flash.events.MouseEvent; \n \nclass ChildSprite extends Sprite \n{ \n    public function ChildSprite()\n    {\n        graphics.beginFill(0xFF0000); \n        graphics.drawRect(0,0,100,100); \n        graphics.endFill(); \n        addEventListener(MouseEvent.CLICK, clickHandler); \n    }\n} \n \nfunction clickHandler(event:MouseEvent):void \n{ \n    trace("clickHandler detected an event of type: " + event.type);\n    trace("the this keyword refers to: " + this);\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"When a user interacts with the resulting SWF file by clicking on the square,\nFlash Player or AIR generates the following trace output:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"clickHandler detected an event of type: click\nthe this keyword refers to: [object global]\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Notice that the event object is passed as an argument to ",(0,i.jsx)(n.code,{children:"clickHandler()"}),". This\nallows your listener function to examine the event object. In this example, you\nuse the event object's ",(0,i.jsx)(n.code,{children:"type"})," property to ascertain that the event is a click\nevent."]}),"\n",(0,i.jsxs)(n.p,{children:["The example also checks the value of the ",(0,i.jsx)(n.code,{children:"this"})," keyword. In this case, ",(0,i.jsx)(n.code,{children:"this"}),"\nrepresents the global object, which makes sense because the function is defined\noutside of any custom class or object."]}),"\n",(0,i.jsx)(n.h4,{id:"listener-function-defined-as-a-class-method",children:"Listener function defined as a class method"}),"\n",(0,i.jsxs)(n.p,{children:["The following example is identical to the previous example that defines the\nClickExample class except that the ",(0,i.jsx)(n.code,{children:"clickHandler()"})," function is defined as a\nmethod of the ChildSprite class:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-actionscript",children:'package \n{ \n    import flash.display.Sprite;\n\n    public class ClickExample extends Sprite\n    {\n        public function ClickExample() \n        { \n            var child:ChildSprite = new ChildSprite(); \n            addChild(child); \n        } \n    }\n} \n \nimport flash.display.Sprite; \nimport flash.events.MouseEvent; \n \nclass ChildSprite extends Sprite \n{ \n    public function ChildSprite()\n    {\n        graphics.beginFill(0xFF0000); \n        graphics.drawRect(0,0,100,100); \n        graphics.endFill(); \n        addEventListener(MouseEvent.CLICK, clickHandler); \n    }\n    private function clickHandler(event:MouseEvent):void\n    {\n        trace("clickHandler detected an event of type: " + event.type); \n        trace("the this keyword refers to: " + this); \n    }\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"When a user interacts with the resulting SWF file by clicking on the red square,\nFlash Player or AIR generates the following trace output:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"clickHandler detected an event of type: click\nthe this keyword refers to: [object ChildSprite]\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Note that the ",(0,i.jsx)(n.code,{children:"this"})," keyword refers to the ChildSprite instance named ",(0,i.jsx)(n.code,{children:"child"}),".\nThis is a change in behavior from ActionScript 2.0. If you used components in\nActionScript 2.0, you may remember that when a class method was passed in to\n",(0,i.jsx)(n.code,{children:"UIEventDispatcher.addEventListener()"}),", the scope of the method was bound to the\ncomponent that broadcast the event instead of the class in which the listener\nmethod was defined. In other words, if you used this technique in ActionScript\n2.0, the ",(0,i.jsx)(n.code,{children:"this"})," keyword would refer to the component broadcasting the event\ninstead of the ChildSprite instance."]}),"\n",(0,i.jsxs)(n.p,{children:["This was a significant issue for some programmers because it meant that they\ncould not access other methods and properties of the class containing the\nlistener method. As a workaround, ActionScript 2.0 programmers could use the\n",(0,i.jsx)(n.code,{children:"mx.util.Delegate"})," class to change the scope of the listener method. This is no\nlonger necessary, however, because ActionScript 3.0 creates a bound method when\n",(0,i.jsx)(n.code,{children:"addEventListener()"})," is called. As a result, the ",(0,i.jsx)(n.code,{children:"this"})," keyword refers to the\nChildSprite instance named ",(0,i.jsx)(n.code,{children:"child"}),", and the programmer has access to the other\nmethods and properties of the ChildSprite class."]}),"\n",(0,i.jsx)(n.h4,{id:"event-listener-that-should-not-be-used",children:"Event listener that should not be used"}),"\n",(0,i.jsxs)(n.p,{children:["There is a third technique in which you create a generic object with a property\nthat points to a dynamically assigned listener function, but it is not\nrecommended. It is discussed here because it was commonly used in ActionScript\n2.0, but should not be used in ActionScript 3.0. This technique is not\nrecommended because the ",(0,i.jsx)(n.code,{children:"this"})," keyword will refer to the global object instead\nof your listener object."]}),"\n",(0,i.jsxs)(n.p,{children:["The following example is identical to the previous ClickExample class example,\nexcept that the listener function is defined as part of a generic object named\n",(0,i.jsx)(n.code,{children:"myListenerObj"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-actionscript",children:'package \n{ \n    import flash.display.Sprite;\n\n    public class ClickExample extends Sprite\n    {\n        public function ClickExample() \n        { \n            var child:ChildSprite = new ChildSprite(); \n            addChild(child); \n        } \n    }\n} \n \nimport flash.display.Sprite; \nimport flash.events.MouseEvent; \n \nclass ChildSprite extends Sprite \n{ \n    public function ChildSprite()\n    {\n        graphics.beginFill(0xFF0000); \n        graphics.drawRect(0,0,100,100); \n        graphics.endFill(); \n        addEventListener(MouseEvent.CLICK, myListenerObj.clickHandler); \n    }\n} \n \nvar myListenerObj:Object = new Object(); \nmyListenerObj.clickHandler = function (event:MouseEvent):void \n{ \n        trace("clickHandler detected an event of type: " + event.type); \n        trace("the this keyword refers to: " + this); \n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"The results of the trace will look like this:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"clickHandler detected an event of type: click\nthe this keyword refers to: [object global]\n"})}),"\n",(0,i.jsxs)(n.p,{children:["You would expect that ",(0,i.jsx)(n.code,{children:"this"})," would refer to ",(0,i.jsx)(n.code,{children:"myListenerObj"})," and that the trace\noutput would be ",(0,i.jsx)(n.code,{children:"[object Object]"}),", but instead it refers to the global object.\nWhen you pass in a dynamic property name as an argument to ",(0,i.jsx)(n.code,{children:"addEventListener()"}),",\nFlash Player or AIR is unable to create a bound method. This is because what you\nare passing as the ",(0,i.jsx)(n.code,{children:"listener"})," parameter is nothing more than the memory address\nof your listener function, and Flash Player and AIR have no way to link that\nmemory address with the ",(0,i.jsx)(n.code,{children:"myListenerObj"})," instance ",(0,i.jsx)(n.code,{children:"."})]}),"\n",(0,i.jsx)(n.h2,{id:"managing-event-listeners",children:"Managing event listeners"}),"\n",(0,i.jsx)(n.p,{children:"You can manage your listener functions using the methods of the IEventDispatcher\ninterface. The IEventDispatcher interface is the ActionScript 3.0 version of the\nEventTarget interface of the DOM event model. Although the name IEventDispatcher\nmay seem to imply that its main purpose is to send (or dispatch) event objects,\nthe methods of this class are actually used much more frequently to register\nevent listeners, check for event listeners, and remove event listeners. The\nIEventDispatcher interface defines five methods, as shown in the following code:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-actionscript",children:"package flash.events \n{ \n    public interface IEventDispatcher\n    {\n\n        function addEventListener(eventName:String,  \n                        listener:Object, \n                        useCapture:Boolean=false, \n                        priority:Integer=0, \n                        useWeakReference:Boolean=false):Boolean; \n \n        function removeEventListener(eventName:String,  \n                    listener:Object, \n                    useCapture:Boolean=false):Boolean; \n \n        function dispatchEvent(eventObject:Event):Boolean; \n \n        function hasEventListener(eventName:String):Boolean; \n        function willTrigger(eventName:String):Boolean; \n    }\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"The Flash Player API implements the IEventDispatcher interface with the\nEventDispatcher class, which serves as a base class for all classes that can be\nevent targets or part of an event flow. For example, the DisplayObject class\ninherits from the EventDispatcher class. This means that any object on the\ndisplay list has access to the methods of the IEventDispatcher interface."}),"\n",(0,i.jsx)(n.h4,{id:"adding-event-listeners",children:"Adding event listeners"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"addEventListener()"})," method is the workhorse of the IEventDispatcher\ninterface. You use it to register your listener functions. The two required\nparameters are ",(0,i.jsx)(n.code,{children:"type"})," and ",(0,i.jsx)(n.code,{children:"listener"}),". You use the ",(0,i.jsx)(n.code,{children:"type"})," parameter to specify\nthe type of event. You use the ",(0,i.jsx)(n.code,{children:"listener"})," parameter to specify the listener\nfunction that will execute when the event occurs. The ",(0,i.jsx)(n.code,{children:"listener"})," parameter can\nbe a reference to either a function or a class method."]}),"\n",(0,i.jsxs)(n.p,{children:["Do not use parentheses when you specify the ",(0,i.jsx)(n.code,{children:"listener"})," parameter. For example,\nthe ",(0,i.jsx)(n.code,{children:"clickHandler()"})," function is specified without parentheses in the following\ncall to the ",(0,i.jsx)(n.code,{children:"addEventListener()"})," method:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-actionscript",children:"addEventListener(MouseEvent.CLICK, clickHandler)\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"useCapture"})," parameter of the ",(0,i.jsx)(n.code,{children:"addEventListener()"})," method allows you to\ncontrol the event flow phase on which your listener will be active. If\n",(0,i.jsx)(n.code,{children:"useCapture"})," is set to ",(0,i.jsx)(n.code,{children:"true"}),", your listener will be active during the capture\nphase of the event flow. If ",(0,i.jsx)(n.code,{children:"useCapture"})," is set to ",(0,i.jsx)(n.code,{children:"false"}),", your listener will\nbe active during the target and bubbling phases of the event flow. To listen for\nan event during all phases of the event flow, you must call ",(0,i.jsx)(n.code,{children:"addEventListener()"}),"\ntwice, once with ",(0,i.jsx)(n.code,{children:"useCapture"})," set to ",(0,i.jsx)(n.code,{children:"true"}),", and then again with ",(0,i.jsx)(n.code,{children:"useCapture"}),"\nset to ",(0,i.jsx)(n.code,{children:"false"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"priority"})," parameter of the ",(0,i.jsx)(n.code,{children:"addEventListener()"})," method is not an official\npart of the DOM Level 3 event model. It is included in ActionScript 3.0 to\nprovide you with more flexibility in organizing your event listeners. When you\ncall ",(0,i.jsx)(n.code,{children:"addEventListener()"}),", you can set the priority for that event listener by\npassing an integer value as the ",(0,i.jsx)(n.code,{children:"priority"})," parameter. The default value is 0,\nbut you can set it to negative or positive integer values. The higher the\nnumber, the sooner that event listener will be executed. Event listeners with\nthe same priority are executed in the order that they were added, so the earlier\na listener is added, the sooner it will be executed."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"useWeakReference"})," parameter allows you to specify whether the reference to\nthe listener function is weak or normal. Setting this parameter to ",(0,i.jsx)(n.code,{children:"true"})," allows\nyou to avoid situations in which listener functions persist in memory even\nthough they are no longer needed. Flash Player and AIR use a technique called\n",(0,i.jsx)(n.em,{children:"garbage collection"})," to clear objects from memory that are no longer in use. An\nobject is considered no longer in use if no references to it exist. The garbage\ncollector disregards weak references, which means that a listener function that\nhas only a weak reference pointing to it is eligible for garbage collection."]}),"\n",(0,i.jsx)(n.h4,{id:"removing-event-listeners",children:"Removing event listeners"}),"\n",(0,i.jsxs)(n.p,{children:["You can use the ",(0,i.jsx)(n.code,{children:"removeEventListener()"})," method to remove an event listener that\nyou no longer need. It is a good idea to remove any listeners that will no\nlonger be used. Required parameters include the ",(0,i.jsx)(n.code,{children:"eventName"})," and ",(0,i.jsx)(n.code,{children:"listener"}),"\nparameters, which are the same as the required parameters for the\n",(0,i.jsx)(n.code,{children:"addEventListener()"})," method. Recall that you can listen for events during all\nevent phases by calling ",(0,i.jsx)(n.code,{children:"addEventListener()"})," twice, once with ",(0,i.jsx)(n.code,{children:"useCapture"})," set\nto ",(0,i.jsx)(n.code,{children:"true"}),", and then again with it set to ",(0,i.jsx)(n.code,{children:"false"}),". To remove both event\nlisteners, you would need to call ",(0,i.jsx)(n.code,{children:"removeEventListener()"})," twice, once with\n",(0,i.jsx)(n.code,{children:"useCapture"})," set to ",(0,i.jsx)(n.code,{children:"true"}),", and then again with it set to ",(0,i.jsx)(n.code,{children:"false"}),"."]}),"\n",(0,i.jsx)(n.h4,{id:"dispatching-events",children:"Dispatching events"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"dispatchEvent()"})," method can be used by advanced programmers to dispatch a\ncustom event object into the event flow. The only parameter accepted by this\nmethod is a reference to an event object, which must be an instance of the Event\nclass or a subclass of the Event class. Once dispatched, the ",(0,i.jsx)(n.code,{children:"target"})," property\nof the event object is set to the object on which ",(0,i.jsx)(n.code,{children:"dispatchEvent()"})," was called."]}),"\n",(0,i.jsx)(n.h4,{id:"checking-for-existing-event-listeners",children:"Checking for existing event listeners"}),"\n",(0,i.jsxs)(n.p,{children:["The final two methods of the IEventDispatcher interface provide useful\ninformation about the existence of event listeners. The ",(0,i.jsx)(n.code,{children:"hasEventListener()"}),"\nmethod returns ",(0,i.jsx)(n.code,{children:"true"})," if an event listener is found for a specific event type on\na particular display list object. The ",(0,i.jsx)(n.code,{children:"willTrigger()"})," method also returns ",(0,i.jsx)(n.code,{children:"true"}),"\nif a listener is found for a particular display list object, but ",(0,i.jsx)(n.code,{children:"willTrigger()"}),"\nchecks for listeners not only on that display object, but also on all of that\ndisplay list object's ancestors for all phases of the event flow."]}),"\n",(0,i.jsx)(n.h2,{id:"error-events-without-listeners",children:"Error events without listeners"}),"\n",(0,i.jsx)(n.p,{children:"Exceptions, rather than events, are the primary mechanism for error handling in\nActionScript 3.0, but exception handling does not work for asynchronous\noperations such as loading files. If an error occurs during such an asynchronous\noperation, Flash Player and AIR dispatch an error event object. If you do not\ncreate a listener for the error event, the debugger versions of Flash Player and\nAIR will bring up a dialog box with information about the error. For example,\nthe debugger version of Flash Player produces the following dialog box\ndescribing the error when the application attempts to load a file from an\ninvalid URL:"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:t(27920).A+"",width:"460",height:"286"})}),"\n",(0,i.jsxs)(n.p,{children:["Most error events are based on the ErrorEvent class, and as such will have a\nproperty named ",(0,i.jsx)(n.code,{children:"text"})," that is used to store the error message that Flash Player\nor AIR displays. The two exceptions are the StatusEvent and NetStatusEvent\nclasses. Both of these classes have a ",(0,i.jsx)(n.code,{children:"level"})," property (",(0,i.jsx)(n.code,{children:"StatusEvent.level"})," and\n",(0,i.jsx)(n.code,{children:"NetStatusEvent.info.level"}),"). When the value of the ",(0,i.jsx)(n.code,{children:"level"})," property is\n",(0,i.jsx)(n.code,{children:'"error"'}),", these event types are considered to be error events."]}),"\n",(0,i.jsx)(n.p,{children:"An error event will not cause a SWF file to stop running. It will manifest only\nas a dialog box on the debugger versions of the browser plug-ins and stand-alone\nplayers, as a message in the output panel in the authoring player, and as an\nentry in the log file for Adobe Flash Builder. It will not manifest at all in\nthe release versions of Flash Player or AIR."})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);