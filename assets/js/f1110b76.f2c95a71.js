"use strict";(globalThis.webpackChunkairsdk_dev=globalThis.webpackChunkairsdk_dev||[]).push([[25699],{19916:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>o,default:()=>c,frontMatter:()=>s,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"development/files-and-data/working-with-bytearrays/reading-and-writing-a-bytearray","title":"Reading and writing a ByteArray","description":"The ByteArray class is part of the flash.utils package. To create a ByteArray","source":"@site/docs/development/files-and-data/working-with-bytearrays/reading-and-writing-a-bytearray.md","sourceDirName":"development/files-and-data/working-with-bytearrays","slug":"/development/files-and-data/working-with-bytearrays/reading-and-writing-a-bytearray","permalink":"/docs/development/files-and-data/working-with-bytearrays/reading-and-writing-a-bytearray","draft":false,"unlisted":false,"editUrl":"https://github.com/airsdk/airsdk.dev/edit/main/docs/development/files-and-data/working-with-bytearrays/reading-and-writing-a-bytearray.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"mainSidebar","previous":{"title":"Working with byte arrays","permalink":"/docs/development/files-and-data/working-with-bytearrays/"},"next":{"title":"ByteArray example: Reading a .zip file","permalink":"/docs/development/files-and-data/working-with-bytearrays/bytearray-example-reading-a-zip-file"}}');var i=n(74848),a=n(28453);const s={sidebar_position:1},o="Reading and writing a ByteArray",d={},l=[{value:"ByteArray methods",id:"bytearray-methods",level:2},{value:"The position property",id:"the-position-property",level:2},{value:"The bytesAvailable and length properties",id:"the-bytesavailable-and-length-properties",level:2},{value:"The endian property",id:"the-endian-property",level:2},{value:"The compress() and uncompress() methods",id:"the-compress-and-uncompress-methods",level:2},{value:"Reading and writing objects",id:"reading-and-writing-objects",level:2}];function h(e){const t={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"reading-and-writing-a-bytearray",children:"Reading and writing a ByteArray"})}),"\n",(0,i.jsx)(t.p,{children:"The ByteArray class is part of the flash.utils package. To create a ByteArray\nobject in ActionScript 3.0, import the ByteArray class and invoke the\nconstructor, as shown in the following example:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"import flash.utils.ByteArray;\nvar stream:ByteArray = new ByteArray();\n"})}),"\n",(0,i.jsx)(t.h2,{id:"bytearray-methods",children:"ByteArray methods"}),"\n",(0,i.jsx)(t.p,{children:"Any meaningful data stream is organized into a format that you can analyze to\nfind the information that you want. A record in a simple employee file, for\nexample, would probably include an ID number, a name, an address, a phone\nnumber, and so on. An MP3 audio file contains an ID3 tag that identifies the\ntitle, author, album, publishing date, and genre of the file that's being\ndownloaded. The format allows you to know the order in which to expect the data\non the data stream. It allows you to read the byte stream intelligently."}),"\n",(0,i.jsxs)(t.p,{children:["The ByteArray class includes several methods that make it easier to read from\nand write to a data stream. Some of these methods include ",(0,i.jsx)(t.code,{children:"readBytes()"})," and\n",(0,i.jsx)(t.code,{children:"writeBytes()"}),", ",(0,i.jsx)(t.code,{children:"readInt()"})," and ",(0,i.jsx)(t.code,{children:"writeInt()"}),", ",(0,i.jsx)(t.code,{children:"readFloat()"})," and ",(0,i.jsx)(t.code,{children:"writeFloat()"}),",\n",(0,i.jsx)(t.code,{children:"readObject()"})," and ",(0,i.jsx)(t.code,{children:"writeObject()"}),", and ",(0,i.jsx)(t.code,{children:"readUTFBytes()"})," and ",(0,i.jsx)(t.code,{children:"writeUTFBytes()"}),".\nThese methods enable you to read data from the data stream into variables of\nspecific data types and write from specific data types directly to the binary\ndata stream."]}),"\n",(0,i.jsxs)(t.p,{children:["For example, the following code reads a simple array of strings and\nfloating-point numbers and writes each element to a ByteArray. The organization\nof the array allows the code to call the appropriate ByteArray methods (\n",(0,i.jsx)(t.code,{children:"writeUTFBytes()"})," and ",(0,i.jsx)(t.code,{children:"writeFloat()"}),") to write the data. The repeating data\npattern makes it possible to read the array with a loop."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:'// The following example reads a simple Array (groceries), made up of strings\n// and floating-point numbers, and writes it to a ByteArray.\n\nimport flash.utils.ByteArray;\n\n// define the grocery list Array\nvar groceries:Array = ["milk", 4.50, "soup", 1.79, "eggs", 3.19, "bread" , 2.35]\n// define the ByteArray\nvar bytes:ByteArray = new ByteArray();\n// for each item in the array\nfor (var i:int = 0; i < groceries.length; i++) {\n\tbytes.writeUTFBytes(groceries[i++]); //write the string and position to the next item\n\tbytes.writeFloat(groceries[i]);    // write the float\n\ttrace("bytes.position is: " + bytes.position);    //display the position in ByteArray\n}\ntrace("bytes length is: " +  bytes.length);    // display the length\n'})}),"\n",(0,i.jsx)(t.h2,{id:"the-position-property",children:"The position property"}),"\n",(0,i.jsx)(t.p,{children:"The position property stores the current position of the pointer that indexes\nthe ByteArray during reading or writing. The initial value of the position\nproperty is 0 (zero) as shown in the following code:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:'var bytes:ByteArray = new ByteArray();\ntrace("bytes.position is initially: " + bytes.position);     // 0\n'})}),"\n",(0,i.jsx)(t.p,{children:"When you read from or write to a ByteArray, the method that you use updates the\nposition property to point to the location immediately following the last byte\nthat was read or written. For example, the following code writes a string to a\nByteArray and afterward the position property points to the byte immediately\nfollowing the string in the ByteArray:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:'var bytes:ByteArray = new ByteArray();\ntrace("bytes.position is initially: " + bytes.position);     // 0\nbytes.writeUTFBytes("Hello World!");\ntrace("bytes.position is now: " + bytes.position);    // 12\n'})}),"\n",(0,i.jsx)(t.p,{children:"Likewise, a read operation increments the position property by the number of\nbytes read."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:'var bytes:ByteArray = new ByteArray();\n\ntrace("bytes.position is initially: " + bytes.position);     // 0\nbytes.writeUTFBytes("Hello World!");\ntrace("bytes.position is now: " + bytes.position);    // 12\nbytes.position = 0;\ntrace("The first 6 bytes are: " + (bytes.readUTFBytes(6)));    //Hello\ntrace("And the next 6 bytes are: " + (bytes.readUTFBytes(6)));    // World!\n'})}),"\n",(0,i.jsx)(t.p,{children:"Notice that you can set the position property to a specific location in the\nByteArray to read or write at that offset."}),"\n",(0,i.jsx)(t.h2,{id:"the-bytesavailable-and-length-properties",children:"The bytesAvailable and length properties"}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"length"})," and ",(0,i.jsx)(t.code,{children:"bytesAvailable"}),' properties tell you how long a ByteArray is\nand how many bytes remain in it from the current position to the end. The\nfollowing example illustrates how you can use these properties. The example\nwrites a String of text to the ByteArray and then reads the ByteArray one byte\nat a time until it encounters either the character "a" or the end (\n',(0,i.jsx)(t.code,{children:"bytesAvailable <= 0"}),")."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:'var bytes:ByteArray = new ByteArray();\nvar text:String = "Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Vivamus etc.";\n\nbytes.writeUTFBytes(text); // write the text to the ByteArray\ntrace("The length of the ByteArray is: " + bytes.length);    // 70\nbytes.position = 0; // reset position\nwhile (bytes.bytesAvailable > 0 && (bytes.readUTFBytes(1) != \'a\')) {\n\t//read to letter a or end of bytes\n}\nif (bytes.position < bytes.bytesAvailable) {\n\ttrace("Found the letter a; position is: " + bytes.position);     // 23\n\ttrace("and the number of bytes available is: " + bytes.bytesAvailable);    // 47\n}\n'})}),"\n",(0,i.jsx)(t.h2,{id:"the-endian-property",children:"The endian property"}),"\n",(0,i.jsxs)(t.p,{children:["Computers can differ in how they store multibyte numbers, that is, numbers that\nrequire more than 1 byte of memory to store them. An integer, for example, can\ntake 4 bytes, or 32 bits, of memory. Some computers store the most significant\nbyte of the number first, in the lowest memory address, and others store the\nleast significant byte first. This attribute of a computer, or of byte ordering,\nis referred to as being either ",(0,i.jsx)(t.em,{children:"big endian"})," (most significant byte first) or\n",(0,i.jsx)(t.em,{children:"little endian"})," (least significant byte first). For example, the number\n0x31323334 would be stored as follows for big endian and little endian byte\nordering, where a0 represents the lowest memory address of the 4 bytes and a3\nrepresents the highest:"]}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:"Big Endian"}),(0,i.jsx)(t.th,{children:"Big Endian"}),(0,i.jsx)(t.th,{children:"Big Endian"}),(0,i.jsx)(t.th,{children:"Big Endian"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"a0"}),(0,i.jsx)(t.td,{children:"a1"}),(0,i.jsx)(t.td,{children:"a2"}),(0,i.jsx)(t.td,{children:"a3"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"31"}),(0,i.jsx)(t.td,{children:"32"}),(0,i.jsx)(t.td,{children:"33"}),(0,i.jsx)(t.td,{children:"34"})]})]})]}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:"Little Endian"}),(0,i.jsx)(t.th,{children:"Little Endian"}),(0,i.jsx)(t.th,{children:"Little Endian"}),(0,i.jsx)(t.th,{children:"Little Endian"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"a0"}),(0,i.jsx)(t.td,{children:"a1"}),(0,i.jsx)(t.td,{children:"a2"}),(0,i.jsx)(t.td,{children:"a3"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"34"}),(0,i.jsx)(t.td,{children:"33"}),(0,i.jsx)(t.td,{children:"32"}),(0,i.jsx)(t.td,{children:"31"})]})]})]}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"endian"})," property of the ByteArray class allows you to denote this byte\norder for multibyte numbers that you are processing. The acceptable values for\nthis property are either ",(0,i.jsx)(t.code,{children:'"bigEndian"'})," or ",(0,i.jsx)(t.code,{children:'"littleEndian"'})," and the Endian class\ndefines the constants ",(0,i.jsx)(t.code,{children:"BIG_ENDIAN"})," and ",(0,i.jsx)(t.code,{children:"LITTLE_ENDIAN"})," for setting the ",(0,i.jsx)(t.code,{children:"endian"}),"\nproperty with these strings."]}),"\n",(0,i.jsx)(t.h2,{id:"the-compress-and-uncompress-methods",children:"The compress() and uncompress() methods"}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"compress()"})," method allows you to compress a ByteArray in accordance with a\ncompression algorithm that you specify as a parameter. The ",(0,i.jsx)(t.code,{children:"uncompress()"})," method\nallows you to uncompress a compressed ByteArray in accordance with a compression\nalgorithm. After calling ",(0,i.jsx)(t.code,{children:"compress()"})," and ",(0,i.jsx)(t.code,{children:"uncompress()"}),", the length of the byte\narray is set to the new length and the position property is set to the end."]}),"\n",(0,i.jsxs)(t.p,{children:["The CompressionAlgorithm class defines constants that you can use to specify the\ncompression algorithm. The ByteArray class supports the deflate (AIR-only),\nzlib, and lzma algorithms. The zlib compressed data format is described at\n",(0,i.jsx)(t.a,{href:"http://www.ietf.org/rfc/rfc1950.txt",children:"http://www.ietf.org/rfc/rfc1950.txt"}),". The lzma algorithm was added for Flash\nPlayer 11.4 and AIR 3.4. It is described at ",(0,i.jsx)(t.a,{href:"http://www.7-zip.org/7z.html",children:"http://www.7-zip.org/7z.html"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["The deflate compression algorithm is used in several compression formats, such\nas zlib, gzip, and some zip implementations. The deflate compression algorithm\nis described at ",(0,i.jsx)(t.a,{href:"http://www.ietf.org/rfc/rfc1951.txt",children:"http://www.ietf.org/rfc/rfc1951.txt"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["The following example compresses a ByteArray called ",(0,i.jsx)(t.code,{children:"bytes"})," using the lzma\nalgorithm:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"bytes.compress(CompressionAlgorithm.LZMA);\n"})}),"\n",(0,i.jsx)(t.p,{children:"The following example uncompresses a compressed ByteArray using the deflate\nalgorithm:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"bytes.uncompress(CompressionAlgorithm.LZMA);\n"})}),"\n",(0,i.jsx)(t.h2,{id:"reading-and-writing-objects",children:"Reading and writing objects"}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"readObject()"})," and ",(0,i.jsx)(t.code,{children:"writeObject()"})," methods read an object from and write an\nobject to a ByteArray, encoded in serialized Action Message Format (AMF). AMF is\na proprietary message protocol created by Adobe and used by various ActionScript\n3.0 classes, including Netstream, NetConnection, NetStream, LocalConnection, and\nShared Objects."]}),"\n",(0,i.jsx)(t.p,{children:"A one-byte type marker describes the type of the encoded data that follows. AMF\nuses the following 13 data types:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"value-type = undefined-marker | null-marker | false-marker | true-marker | integer-type |\ndouble-type | string-type | xml-doc-type | date-type | array-type | object-type |\nxml-type | byte-array-type\n"})}),"\n",(0,i.jsx)(t.p,{children:"The encoded data follows the type marker unless the marker represents a single\npossible value, such as null or true or false, in which case nothing else is\nencoded."}),"\n",(0,i.jsxs)(t.p,{children:["There are two versions of AMF: AMF0 and AMF3. AMF 0 supports sending complex\nobjects by reference and allows endpoints to restore object relationships. AMF 3\nimproves AMF 0 by sending object traits and strings by reference, in addition to\nobject references, and by supporting new data types that were introduced in\nActionScript 3.0. The ",(0,i.jsx)(t.code,{children:"ByteArray.objectEcoding"})," property specifies the version\nof AMF that is used to encode the object data. The flash.net.ObjectEncoding\nclass defines constants for specifying the AMF version: ",(0,i.jsx)(t.code,{children:"ObjectEncoding.AMF0"}),"\nand ",(0,i.jsx)(t.code,{children:"ObjectEncoding.AMF3"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["The following example calls ",(0,i.jsx)(t.code,{children:"writeObject()"})," to write an XML object to a\nByteArray, which it then compresses using the Deflate algorithm and writes to\nthe ",(0,i.jsx)(t.code,{children:"order"}),' file on the desktop. The example uses a label to display the message\n"Wrote order file to desktop!" in the AIR window when it is finished.']}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"import flash.filesystem.*;\nimport flash.display.Sprite;\nimport flash.display.TextField;\nimport flash.utils.ByteArray;\n\npublic class WriteObjectExample extends Sprite\n{\n\tpublic function WriteObjectExample()\n\t{\n\t\tvar bytes:ByteArray = new ByteArray();\n\t\tvar myLabel:TextField = new TextField();\n\t\tmyLabel.x = 150;\n\t\tmyLabel.y = 150;\n\t\tmyLabel.width = 200;\n\t\taddChild(myLabel);\n\n\t\tvar myXML:XML =\n\t\t\t<order>\n\t\t\t\t<item id='1'>\n\t\t\t\t\t<menuName>burger</menuName>\n\t\t\t\t\t<price>3.95</price>\n\t\t\t\t</item>\n\t\t\t\t<item id='2'>\n\t\t\t\t\t<menuName>fries</menuName>\n\t\t\t\t\t<price>1.45</price>\n\t\t\t\t</item>\n\t\t\t</order>;\n\n\t\t// Write XML object to ByteArray\n\t\tbytes.writeObject(myXML);\n\t\tbytes.position = 0;        //reset position to beginning\n\t\tbytes.compress(CompressionAlgorithm.DEFLATE);    // compress ByteArray\n\t\twriteBytesToFile(\"order.xml\", bytes);\n\t\tmyLabel.text = \"Wrote order file to desktop!\";\n\t}\n\n\tprivate function writeBytesToFile(fileName:String, data:ByteArray):void\n\t{\n\t\tvar outFile:File = File.desktopDirectory; // dest folder is desktop\n\t\toutFile = outFile.resolvePath(fileName);  // name of file to write\n\t\tvar outStream:FileStream = new FileStream();\n\t\t// open output file stream in WRITE mode\n\t\toutStream.open(outFile, FileMode.WRITE);\n\t\t// write out the file\n\t\toutStream.writeBytes(data, 0, data.length);\n\t\t// close it\n\t\toutStream.close();\n\t}\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"readObject()"})," method reads an object in serialized AMF from a ByteArray and\nstores it in an object of the specified type. The following example reads the\n",(0,i.jsx)(t.code,{children:"order"})," file from the desktop into a ByteArray ( ",(0,i.jsx)(t.code,{children:"inBytes"}),"), uncompresses it,\nand calls ",(0,i.jsx)(t.code,{children:"readObject()"})," to store it in the XML object ",(0,i.jsx)(t.code,{children:"orderXML"}),". The example\nuses a ",(0,i.jsx)(t.code,{children:"for each()"})," loop construct to add each node to a text area for display.\nThe example also displays the value of the ",(0,i.jsx)(t.code,{children:"objectEncoding"})," property along with\na header for the contents of the ",(0,i.jsx)(t.code,{children:"order"})," file."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:'import flash.filesystem.*;\nimport flash.display.Sprite;\nimport flash.display.TextField;\nimport flash.utils.ByteArray;\n\npublic class ReadObjectExample extends Sprite\n{\n\tpublic function ReadObjectExample()\n\t{\n\t\tvar inBytes:ByteArray = new ByteArray();\n\t\t// define text area for displaying XML content\n\t\tvar myTxt:TextField = new TextField();\n\t\tmyTxt.width = 550;\n\t\tmyTxt.height = 400;\n\t\taddChild(myTxt);\n\t\t//display objectEncoding and file heading\n\t\tmyTxt.text = "Object encoding is: " + inBytes.objectEncoding + "\\n\\n" + "order file: \\n\\n";\n\t\treadFileIntoByteArray("order", inBytes);\n\n\t\tinBytes.position = 0; // reset position to beginning\n\t\tinBytes.uncompress(CompressionAlgorithm.DEFLATE);\n\t\tinBytes.position = 0;    //reset position to beginning\n\t\t// read XML Object\n\t\tvar orderXML:XML = inBytes.readObject();\n\n\t\t// for each node in orderXML\n\t\tfor each (var child:XML in orderXML)\n\t\t{\n\t\t\t// append child node to text area\n\t\t\tmyTxt.text += child + "\\n";\n\t\t}\n\t}\n\n\t// read specified file into byte array\n\tprivate function readFileIntoByteArray(fileName:String, data:ByteArray):void\n\t{\n\t\tvar inFile:File = File.desktopDirectory; // source folder is desktop\n\t\tinFile = inFile.resolvePath(fileName);  // name of file to read\n\t\tvar inStream:FileStream = new FileStream();\n\t\tinStream.open(inFile, FileMode.READ);\n\t\tinStream.readBytes(data);\n\t\tinStream.close();\n\t}\n}\n'})})]})}function c(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>o});var r=n(96540);const i={},a=r.createContext(i);function s(e){const t=r.useContext(a);return r.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),r.createElement(a.Provider,{value:t},e.children)}}}]);