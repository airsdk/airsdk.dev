"use strict";(self.webpackChunkairsdk_dev=self.webpackChunkairsdk_dev||[]).push([[9663],{1003:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>r,contentTitle:()=>c,default:()=>d,frontMatter:()=>s,metadata:()=>n,toc:()=>h});const n=JSON.parse('{"id":"development/display/display-programming/manipulating-display-objects/caching-display-objects","title":"Caching display objects","description":"As your designs in Flash grow in size, whether you are creating an application or complex scripted animations, you need to consider performance and optimization. When you have content that remains static (such as a rectangle Shape instance), Flash Player and AIR do not optimize the content. Therefore, when you change the position of the rectangle, Flash Player or AIR redraws the entire Shape instance.","source":"@site/docs/development/display/display-programming/manipulating-display-objects/caching-display-objects.md","sourceDirName":"development/display/display-programming/manipulating-display-objects","slug":"/development/display/display-programming/manipulating-display-objects/caching-display-objects","permalink":"/docs/development/display/display-programming/manipulating-display-objects/caching-display-objects","draft":false,"unlisted":false,"editUrl":"https://github.com/airsdk/airsdk.dev/edit/main/docs/development/display/display-programming/manipulating-display-objects/caching-display-objects.md","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"title":"Caching display objects","sidebar_position":6},"sidebar":"mainSidebar","previous":{"title":"Controlling distortion when scaling","permalink":"/docs/development/display/display-programming/manipulating-display-objects/controlling-distortion-when-scaling"},"next":{"title":"Setting an opaque background color","permalink":"/docs/development/display/display-programming/manipulating-display-objects/setting-an-opaque-background-color"}}');var i=t(74848),o=t(28453);const s={title:"Caching display objects",sidebar_position:6},c=void 0,r={},h=[{value:"When to enable caching",id:"when-to-enable-caching",level:2},{value:"When to use bitmap caching",id:"when-to-use-bitmap-caching",level:3},{value:"When to avoid using bitmap caching",id:"when-to-avoid-using-bitmap-caching",level:3},{value:"Enabling bitmap caching",id:"enabling-bitmap-caching",level:2},{value:"Cached bitmap transform matrices",id:"cached-bitmap-transform-matrices",level:3}];function l(e){const a={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(a.p,{children:"As your designs in Flash grow in size, whether you are creating an application or complex scripted animations, you need to consider performance and optimization. When you have content that remains static (such as a rectangle Shape instance), Flash Player and AIR do not optimize the content. Therefore, when you change the position of the rectangle, Flash Player or AIR redraws the entire Shape instance."}),"\n",(0,i.jsx)(a.p,{children:"You can cache specified display objects to improve the performance of your SWF file. The display object is a surface , essentially a bitmap version of the instance's vector data, which is data that you do not intend to change much over the course of your SWF file. Therefore, instances with caching turned on are not continually redrawn as the SWF file plays, letting the SWF file render quickly."}),"\n",(0,i.jsx)(a.admonition,{type:"note",children:(0,i.jsx)(a.p,{children:"You can update the vector data, at which time the surface is recreated. Therefore, the vector data cached in the surface does not need to remain the same for the entire SWF file."})}),"\n",(0,i.jsxs)(a.p,{children:["Setting a display object's ",(0,i.jsx)(a.code,{children:"cacheAsBitmap"})," property to true makes the display object cache a bitmap representation of itself. Flash Player or AIR creates a surface object for the instance, which is a cached bitmap instead of vector data. If you change the bounds of the display object, the surface is recreated instead of resized. Surfaces can nest within other surfaces. The child surface copies its bitmap onto its parent surface. For more information, see Enabling bitmap caching ."]}),"\n",(0,i.jsxs)(a.p,{children:["The DisplayObject class's ",(0,i.jsx)(a.code,{children:"opaqueBackground"})," property and ",(0,i.jsx)(a.code,{children:"scrollRect"})," property are related to bitmap caching using the ",(0,i.jsx)(a.code,{children:"cacheAsBitmap"})," property. Although these three properties are independent of each other, the ",(0,i.jsx)(a.code,{children:"opaqueBackground"})," and ",(0,i.jsx)(a.code,{children:"scrollRect"})," properties work best when an object is cached as a bitmap\u2014you see performance benefits for the ",(0,i.jsx)(a.code,{children:"opaqueBackground"})," and ",(0,i.jsx)(a.code,{children:"scrollRect"})," properties only when you set ",(0,i.jsx)(a.code,{children:"cacheAsBitmap"})," to ",(0,i.jsx)(a.code,{children:"true"})," . For more information about scrolling display object content, see Panning and scrolling display objects . For more information about setting an opaque background, see Setting an opaque background color ."]}),"\n",(0,i.jsxs)(a.p,{children:["For information on alpha channel masking, which requires you to set the ",(0,i.jsx)(a.code,{children:"cacheAsBitmap"})," property to ",(0,i.jsx)(a.code,{children:"true"})," , see Masking display objects ."]}),"\n",(0,i.jsx)(a.h2,{id:"when-to-enable-caching",children:"When to enable caching"}),"\n",(0,i.jsx)(a.p,{children:"Enabling caching for a display object creates a surface, which has several advantages, such as helping complex vector animations to render fast. There are several scenarios in which you will want to enable caching. It might seem as though you would always want to enable caching to improve the performance of your SWF files; however, there are situations in which enabling caching does not improve performance, or can even decrease it. This section describes scenarios in which caching should be used, and when to use regular display objects."}),"\n",(0,i.jsxs)(a.p,{children:["Overall performance of cached data depends on how complex the vector data of your instances are, how much of the data you change, and whether or not you set the ",(0,i.jsx)(a.code,{children:"opaqueBackground"})," property. If you are changing small regions, the difference between using a surface and using vector data could be negligible. You might want to test both scenarios with your work before you deploy the application."]}),"\n",(0,i.jsx)(a.h3,{id:"when-to-use-bitmap-caching",children:"When to use bitmap caching"}),"\n",(0,i.jsx)(a.p,{children:"The following are typical scenarios in which you might see significant benefits when you enable bitmap caching."}),"\n",(0,i.jsxs)(a.ul,{children:["\n",(0,i.jsxs)(a.li,{children:["Complex background image: An application that contains a detailed and complex background image of vector data (perhaps an image where you applied the trace bitmap command, or artwork that you created in Adobe Illustrator\xae). You might animate characters over the background, which slows the animation because the background needs to continuously regenerate the vector data. To improve performance, you can set the ",(0,i.jsx)(a.code,{children:"opaqueBackground"})," property of the background display object to ",(0,i.jsx)(a.code,{children:"true"})," . The background is rendered as a bitmap and can be redrawn quickly, so that your animation plays much faster."]}),"\n",(0,i.jsxs)(a.li,{children:["Scrolling text field: An application that displays a large amount of text in a scrolling text field. You can place the text field in a display object that you set as scrollable with scrolling bounds (the ",(0,i.jsx)(a.code,{children:"scrollRect"})," property). This enables fast pixel scrolling for the specified instance. When a user scrolls the display object instance, Flash Player or AIR shifts the scrolled pixels up and generates the newly exposed region instead of regenerating the entire text field."]}),"\n",(0,i.jsxs)(a.li,{children:["Windowing system: An application with a complex system of overlapping windows. Each window can be open or closed (for example, web browser windows). If you mark each window as a surface (by setting the ",(0,i.jsx)(a.code,{children:"cacheAsBitmap"})," property to ",(0,i.jsx)(a.code,{children:"true"})," ), each window is isolated and cached. Users can drag the windows so that they overlap each other, and each window doesn't need to regenerate the vector content."]}),"\n",(0,i.jsxs)(a.li,{children:["Alpha channel masking: When you are using alpha channel masking, you must set the ",(0,i.jsx)(a.code,{children:"cacheAsBitmap"})," property to ",(0,i.jsx)(a.code,{children:"true"})," . For more information, see ",(0,i.jsx)(a.a,{href:"/docs/development/display/display-programming/manipulating-display-objects/masking-display-objects",children:"Masking display objects"})," ."]}),"\n"]}),"\n",(0,i.jsx)(a.p,{children:"Enabling bitmap caching in all of these scenarios improves the responsiveness and interactivity of the application by optimizing the vector graphics."}),"\n",(0,i.jsxs)(a.p,{children:["In addition, whenever you apply a filter to a display object, ",(0,i.jsx)(a.code,{children:"cacheAsBitmap"})," is automatically set to ",(0,i.jsx)(a.code,{children:"true"})," , even if you explicitly set it to false . If you clear all the filters from the display object, the ",(0,i.jsx)(a.code,{children:"cacheAsBitmap"})," property returns to the value it was last set to."]}),"\n",(0,i.jsx)(a.h3,{id:"when-to-avoid-using-bitmap-caching",children:"When to avoid using bitmap caching"}),"\n",(0,i.jsx)(a.p,{children:"Using this feature in the wrong circumstances can negatively affect the performance of your SWF file. When you use bitmap caching, remember the following guidelines:"}),"\n",(0,i.jsxs)(a.ul,{children:["\n",(0,i.jsx)(a.li,{children:"Do not overuse surfaces (display objects with caching enabled). Each surface uses more memory than a regular display object, which means that you should only enable surfaces when you need to improve rendering performance."}),"\n",(0,i.jsx)(a.li,{children:"A cached bitmap can use significantly more memory than a regular display object. For example, if a Sprite instance on the Stage is 250 pixels by 250 pixels in size, when cached it might use 250 KB instead of 1 KB when it's a regular (un-cached) Sprite instance."}),"\n",(0,i.jsx)(a.li,{children:"Avoid zooming into cached surfaces. If you overuse bitmap caching, a large amount of memory is consumed (see previous bullet), especially if you zoom in on the content."}),"\n",(0,i.jsx)(a.li,{children:"Use surfaces for display object instances that are largely static (non-animating). You can drag or move the instance, but the contents of the instance should not animate or change a lot. (Animation or changing content are more likely with a MovieClip instance containing animation or a Video instance.) For example, if you rotate or transform an instance, the instance changes between the surface and vector data, which is difficult to process and negatively affects your SWF file."}),"\n",(0,i.jsx)(a.li,{children:"If you mix surfaces with vector data, it increases the amount of processing that Flash Player and AIR (and sometimes the computer) need to do. Group surfaces together as much as possible\u2014for example, when you create windowing applications."}),"\n",(0,i.jsx)(a.li,{children:"Do not cache objects whose graphics change frequently. Every time you scale, skew, rotate the display object, change the alpha or color transform, move child display objects, or draw using the graphics property, the bitmap cache is redrawn. If this happens every frame, the runtime must draw the object into a bitmap and then copy that bitmap onto the stage\u2014which results in extra work compared to just drawing the uncached object to the stage. The performance tradeoff of caching versus update frequency depends on the complexity and size of the display object and can only be determined by testing the specific content."}),"\n"]}),"\n",(0,i.jsx)(a.h2,{id:"enabling-bitmap-caching",children:"Enabling bitmap caching"}),"\n",(0,i.jsxs)(a.p,{children:["To enable bitmap caching for a display object, you set its ",(0,i.jsx)(a.code,{children:"cacheAsBitmap"})," property to ",(0,i.jsx)(a.code,{children:"true"})," :"]}),"\n",(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-actionscript",children:"mySprite.cacheAsBitmap = true;\n"})}),"\n",(0,i.jsxs)(a.p,{children:["After you set the ",(0,i.jsx)(a.code,{children:"cacheAsBitmap"})," property to ",(0,i.jsx)(a.code,{children:"true"})," , you might notice that the display object automatically pixel-snaps to whole coordinates. When you test the SWF file, you should notice that any animation performed on a complex vector image renders much faster."]}),"\n",(0,i.jsxs)(a.p,{children:["A surface (cached bitmap) is not created, even if ",(0,i.jsx)(a.code,{children:"cacheAsBitmap"})," is set to ",(0,i.jsx)(a.code,{children:"true"})," , if one or more of the following occurs:"]}),"\n",(0,i.jsxs)(a.ul,{children:["\n",(0,i.jsx)(a.li,{children:"The bitmap is greater than 2880 pixels in height or width."}),"\n",(0,i.jsx)(a.li,{children:"The bitmap fails to allocate (because of an out-of-memory error)."}),"\n"]}),"\n",(0,i.jsx)(a.h3,{id:"cached-bitmap-transform-matrices",children:"Cached bitmap transform matrices"}),"\n",(0,i.jsxs)(a.p,{children:["In AIR applications for mobile devices, you should set the ",(0,i.jsx)(a.code,{children:"cacheAsBitmapMatrix"})," property whenever you set the ",(0,i.jsx)(a.code,{children:"cacheAsBitmap"})," property. Setting this property allows you to apply a wider range of transformations to the display object without triggering rerendering."]}),"\n",(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-actionscript",children:"mySprite.cacheAsBitmap = true;\nmySprite.cacheAsBitmapMatrix = new Matrix();\n"})}),"\n",(0,i.jsx)(a.p,{children:"When you set this matrix property, you can apply the following additional transformation to the display object without recaching the object:"}),"\n",(0,i.jsxs)(a.ul,{children:["\n",(0,i.jsx)(a.li,{children:"Move or translate without pixel-snapping"}),"\n",(0,i.jsx)(a.li,{children:"Rotate"}),"\n",(0,i.jsx)(a.li,{children:"Scale"}),"\n",(0,i.jsx)(a.li,{children:"Skew"}),"\n",(0,i.jsx)(a.li,{children:"Change alpha (between 0 and 100% transparency)"}),"\n"]}),"\n",(0,i.jsx)(a.p,{children:"These transformations are applied directly to the cached bitmap."})]})}function d(e={}){const{wrapper:a}={...(0,o.R)(),...e.components};return a?(0,i.jsx)(a,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},28453:(e,a,t)=>{t.d(a,{R:()=>s,x:()=>c});var n=t(96540);const i={},o=n.createContext(i);function s(e){const a=n.useContext(o);return n.useMemo((function(){return"function"==typeof e?e(a):{...a,...e}}),[a,e])}function c(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),n.createElement(o.Provider,{value:a},e.children)}}}]);