"use strict";(self.webpackChunkairsdk_dev=self.webpackChunkairsdk_dev||[]).push([[50622],{19360:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"development/display/filtering-display-objects/creating-and-applying-filters","title":"Creating and applying filters","description":"Filters allow you to apply a range of effects to bitmap and display objects,","source":"@site/docs/development/display/filtering-display-objects/creating-and-applying-filters.md","sourceDirName":"development/display/filtering-display-objects","slug":"/development/display/filtering-display-objects/creating-and-applying-filters","permalink":"/docs/development/display/filtering-display-objects/creating-and-applying-filters","draft":false,"unlisted":false,"editUrl":"https://github.com/airsdk/airsdk.dev/edit/main/docs/development/display/filtering-display-objects/creating-and-applying-filters.md","tags":[],"version":"current","frontMatter":{},"sidebar":"mainSidebar","previous":{"title":"Convolution filter","permalink":"/docs/development/display/filtering-display-objects/convolution-filter"},"next":{"title":"Displacement map filter","permalink":"/docs/development/display/filtering-display-objects/displacement-map-filter"}}');var n=i(74848),a=i(28453);const o={},s="Creating and applying filters",l={},d=[{value:"Creating a filter",id:"creating-a-filter",level:2},{value:"Applying a filter",id:"applying-a-filter",level:2},{value:"Applying a filter to a display object",id:"applying-a-filter-to-a-display-object",level:4},{value:"Removing filters from a display object",id:"removing-filters-from-a-display-object",level:4},{value:"Applying a filter to a BitmapData object",id:"applying-a-filter-to-a-bitmapdata-object",level:4},{value:"How filters work",id:"how-filters-work",level:2},{value:"Potential issues for working with filters",id:"potential-issues-for-working-with-filters",level:2},{value:"Filters and bitmap caching",id:"filters-and-bitmap-caching",level:4},{value:"Changing filters at run time",id:"changing-filters-at-run-time",level:4},{value:"Adding an additional filter",id:"adding-an-additional-filter",level:4},{value:"Removing one filter from a set of filters",id:"removing-one-filter-from-a-set-of-filters",level:4},{value:"Determining a filter&#39;s index",id:"determining-a-filters-index",level:4},{value:"Filters and object transformations",id:"filters-and-object-transformations",level:4},{value:"Filters and Bitmap objects",id:"filters-and-bitmap-objects",level:4}];function c(e){const t={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h4:"h4",header:"header",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.header,{children:(0,n.jsx)(t.h1,{id:"creating-and-applying-filters",children:"Creating and applying filters"})}),"\n",(0,n.jsxs)(t.p,{children:["Filters allow you to apply a range of effects to bitmap and display objects,\nranging from drop shadows to bevels and blurs. Each filter is defined as a\nclass, so applying filters involves creating instances of filter objects, which\nis no different from constructing any other object. Once you've created an\ninstance of a filter object, it can easily be applied to a display object by\nusing the object's ",(0,n.jsx)(t.code,{children:"filters"})," property, or in the case of a BitmapData object, by\nusing the ",(0,n.jsx)(t.code,{children:"applyFilter()"})," method."]}),"\n",(0,n.jsx)(t.h2,{id:"creating-a-filter",children:"Creating a filter"}),"\n",(0,n.jsx)(t.p,{children:"To create a filter object, simply call the constructor method of your selected\nfilter class. For example, to create a DropShadowFilter object, use the\nfollowing code:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{children:"import flash.filters.DropShadowFilter;\nvar myFilter:DropShadowFilter = new DropShadowFilter();\n"})}),"\n",(0,n.jsxs)(t.p,{children:["Although not shown here, the ",(0,n.jsx)(t.code,{children:"DropShadowFilter()"})," constructor (like all the\nfilter classes' constructors) accepts several optional parameters that can be\nused to customize the appearance of the filter effect."]}),"\n",(0,n.jsx)(t.h2,{id:"applying-a-filter",children:"Applying a filter"}),"\n",(0,n.jsx)(t.p,{children:"Once you've constructed a filter object, you can apply it to a display object or\na BitmapData object; how you apply the filter depends on the object to which\nyou're applying it."}),"\n",(0,n.jsx)(t.h4,{id:"applying-a-filter-to-a-display-object",children:"Applying a filter to a display object"}),"\n",(0,n.jsxs)(t.p,{children:["When you apply filter effects to a display object, you apply them through the\n",(0,n.jsx)(t.code,{children:"filters"})," property. The ",(0,n.jsx)(t.code,{children:"filters"})," property of a display object is an Array\ninstance, whose elements are the filter objects applied to the display object.\nTo apply a single filter to a display object, create the filter instance, add it\nto an Array instance, and assign that Array object to the display object's\n",(0,n.jsx)(t.code,{children:"filters"})," property:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{children:"import flash.display.Bitmap;\nimport flash.display.BitmapData;\nimport flash.filters.DropShadowFilter;\n\n// Create a bitmapData object and render it to screen\nvar myBitmapData:BitmapData = new BitmapData(100,100,false,0xFFFF3300);\nvar myDisplayObject:Bitmap = new Bitmap(myBitmapData);\naddChild(myDisplayObject);\n\n// Create a DropShadowFilter instance.\nvar dropShadow:DropShadowFilter = new DropShadowFilter();\n\n// Create the filters array, adding the filter to the array by passing it as\n// a parameter to the Array() constructor.\nvar filtersArray:Array = new Array(dropShadow);\n\n// Assign the filters array to the display object to apply the filter.\nmyDisplayObject.filters = filtersArray;\n"})}),"\n",(0,n.jsxs)(t.p,{children:["If you want to assign multiple filters to the object, simply add all the filters\nto the Array instance before assigning it to the ",(0,n.jsx)(t.code,{children:"filters"})," property. You can add\nmultiple objects to an Array by passing them as parameters to its constructor.\nFor example, this code applies a bevel filter and a glow filter to the\npreviously created display object:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{children:"import flash.filters.BevelFilter;\nimport flash.filters.GlowFilter;\n\n// Create the filters and add them to an array.\nvar bevel:BevelFilter = new BevelFilter();\nvar glow:GlowFilter = new GlowFilter();\nvar filtersArray:Array = new Array(bevel, glow);\n\n// Assign the filters array to the display object to apply the filter.\nmyDisplayObject.filters = filtersArray;\n"})}),"\n",(0,n.jsxs)(t.p,{children:["When you're creating the array containing the filters, you can create it using\nthe ",(0,n.jsx)(t.code,{children:"new Array()"})," constructor (as shown in the previous examples) or you can use\nArray literal syntax, wrapping the filters in square brackets (",(0,n.jsx)(t.code,{children:"[]"}),"). For\ninstance, this line of code:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{children:"var filters:Array = new Array(dropShadow, blur);\n"})}),"\n",(0,n.jsx)(t.p,{children:"does the same thing as this line of code:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{children:"var filters:Array = [dropShadow, blur];\n"})}),"\n",(0,n.jsx)(t.p,{children:"If you apply multiple filters to display objects, they are applied in a\ncumulative, sequential manner. For example, if a filters array has two elements,\na bevel filter added first and a drop shadow filter added second, the drop\nshadow filter is applied to both the bevel filter and the display object. This\nis because of the drop shadow filter's second position in the filters array. If\nyou want to apply filters in a noncumulative manner, apply each filter to a new\ncopy of the display object."}),"\n",(0,n.jsxs)(t.p,{children:["If you're only assigning one or a few filters to a display object, you can\ncreate the filter instance and assign it to the object in a single statement.\nFor example, the following line of code applies a blur filter to a display\nobject called ",(0,n.jsx)(t.code,{children:"myDisplayObject"}),":"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{children:"myDisplayObject.filters = [new BlurFilter()];\n"})}),"\n",(0,n.jsxs)(t.p,{children:["The previous code creates an Array instance using Array literal syntax (square\nbraces), creates a BlurFilter instance as an element in the Array, and assigns\nthat Array to the ",(0,n.jsx)(t.code,{children:"filters"})," property of the display object named\n",(0,n.jsx)(t.code,{children:"myDisplayObject"}),"."]}),"\n",(0,n.jsx)(t.h4,{id:"removing-filters-from-a-display-object",children:"Removing filters from a display object"}),"\n",(0,n.jsxs)(t.p,{children:["Removing all filters from a display object is as simple as assigning a null\nvalue to the ",(0,n.jsx)(t.code,{children:"filters"})," property:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{children:"myDisplayObject.filters = null;\n"})}),"\n",(0,n.jsxs)(t.p,{children:["If you've applied multiple filters to an object and want to remove only one of\nthe filters, you must go through several steps to change the ",(0,n.jsx)(t.code,{children:"filters"})," property\narray. For more information, see\n",(0,n.jsx)(t.a,{href:"/docs/development/display/filtering-display-objects/creating-and-applying-filters#potential-issues-for-working-with-filters",children:"Potential issues for working with filters"}),"."]}),"\n",(0,n.jsx)(t.h4,{id:"applying-a-filter-to-a-bitmapdata-object",children:"Applying a filter to a BitmapData object"}),"\n",(0,n.jsxs)(t.p,{children:["Applying a filter to a BitmapData object requires the use of the BitmapData\nobject's ",(0,n.jsx)(t.code,{children:"applyFilter()"})," method:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{children:"var rect:Rectangle = new Rectangle();\nvar origin:Point = new Point();\nmyBitmapData.applyFilter(sourceBitmapData, rect, origin, new BlurFilter());\n"})}),"\n",(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.code,{children:"applyFilter()"})," method applies a filter to a source BitmapData object,\nproducing a new, filtered image. This method does not modify the original source\nimage; instead, the result of the filter being applied to the source image is\nstored in the BitmapData instance on which the ",(0,n.jsx)(t.code,{children:"applyFilter()"})," method is called."]}),"\n",(0,n.jsx)(t.h2,{id:"how-filters-work",children:"How filters work"}),"\n",(0,n.jsx)(t.p,{children:"Display object filtering works by caching a copy of the original object as a\ntransparent bitmap."}),"\n",(0,n.jsx)(t.p,{children:"Once a filter has been applied to a display object, the runtime caches the\nobject as a bitmap for as long as the object has a valid filter list. This\nsource bitmap is then used as the original image for all subsequently applied\nfilter effects."}),"\n",(0,n.jsx)(t.p,{children:"Each display object usually contains two bitmaps: one with the original\nunfiltered source display object and another for the final image after\nfiltering. The final image is used when rendering. As long as the display object\ndoes not change, the final image does not need updating."}),"\n",(0,n.jsx)(t.h2,{id:"potential-issues-for-working-with-filters",children:"Potential issues for working with filters"}),"\n",(0,n.jsx)(t.p,{children:"There are several potential sources of confusion or trouble to keep in mind when\nyou're working with filters."}),"\n",(0,n.jsx)(t.h4,{id:"filters-and-bitmap-caching",children:"Filters and bitmap caching"}),"\n",(0,n.jsxs)(t.p,{children:["To apply a filter to a display object, bitmap caching must be enabled for that\nobject. When you apply a filter to a display object whose ",(0,n.jsx)(t.code,{children:"cacheAsBitmap"}),"\nproperty is set to ",(0,n.jsx)(t.code,{children:"false"}),", the object's ",(0,n.jsx)(t.code,{children:"cacheAsBitmap"})," property is\nautomatically set to ",(0,n.jsx)(t.code,{children:"true"}),". If you later remove all the filters from the\ndisplay object, the ",(0,n.jsx)(t.code,{children:"cacheAsBitmap"})," property is reset to the last value it was\nset to."]}),"\n",(0,n.jsx)(t.h4,{id:"changing-filters-at-run-time",children:"Changing filters at run time"}),"\n",(0,n.jsxs)(t.p,{children:["If a display object already has one or more filters applied to it, you can't\nchange the set of filters by adding additional filters to or removing filters\nfrom the ",(0,n.jsx)(t.code,{children:"filters"})," property array. Instead, to add to or change the set of\nfilters being applied, you must make your changes to a separate array, then\nassign that array to the filters property of the display object for the filters\nto be applied to the object. The simplest way to do this is to read the\n",(0,n.jsx)(t.code,{children:"filters"})," property array into an Array variable and make your modifications to\nthis temporary array. You then reassign this array back to the ",(0,n.jsx)(t.code,{children:"filters"}),"\nproperty of the display object. In more complex cases, you might need to keep a\nseparate master array of filters. You make any changes to that master filter\narray, and reassign the master array to the display object's ",(0,n.jsx)(t.code,{children:"filters"})," property\nafter each change."]}),"\n",(0,n.jsx)(t.h4,{id:"adding-an-additional-filter",children:"Adding an additional filter"}),"\n",(0,n.jsxs)(t.p,{children:["The following code demonstrates the process of adding an additional filter to a\ndisplay object that already has one or more filters applied to it. Initially, a\nglow filter is applied to the display object named ",(0,n.jsx)(t.code,{children:"myDisplayObject"})," ; later,\nwhen the display object is clicked, the ",(0,n.jsx)(t.code,{children:"addFilters()"})," function is called. In:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{children:"import flash.events.MouseEvent;\nimport flash.filters.*;\n\nmyDisplayObject.filters = [new GlowFilter()];\n\nfunction addFilters(event:MouseEvent):void\n{\n    // Make a copy of the filters array.\n    var filtersCopy:Array = myDisplayObject.filters;\n\n    // Make desired changes to the filters (in this case, adding filters).\n    filtersCopy.push(new BlurFilter());\n    filtersCopy.push(new DropShadowFilter());\n\n    // Apply the changes by reassigning the array to the filters property.\n    myDisplayObject.filters = filtersCopy;\n}\n\nmyDisplayObject.addEventListener(MouseEvent.CLICK, addFilters);\n"})}),"\n",(0,n.jsx)(t.h4,{id:"removing-one-filter-from-a-set-of-filters",children:"Removing one filter from a set of filters"}),"\n",(0,n.jsxs)(t.p,{children:["If a display object has multiple filters applied to it, and you want to remove\none of the filters while the other filters continue to be applied to the object,\nyou copy the filters into a temporary array, remove the unwanted filter from\nthat array, and reassign the temporary array to the display object's ",(0,n.jsx)(t.code,{children:"filters"}),"\nproperty. Several ways to remove one or more elements from any array are\ndescribed in\n",(0,n.jsx)(t.a,{href:"/docs/development/core-actionscript-classes/working-with-arrays/indexed-arrays#retrieving-values-and-removing-array-elements",children:"Retrieving values and removing array elements"}),"."]}),"\n",(0,n.jsxs)(t.p,{children:["The most straightforward situation is to remove the top-most filter on the\nobject (the last filter applied to the object). You use the Array class's\n",(0,n.jsx)(t.code,{children:"pop()"})," method to remove the filter from the array:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{children:'// Example of removing the top-most filter from a display object\n// named "filteredObject".\n\nvar tempFilters:Array = filteredObject.filters;\n\n// Remove the last element from the Array (the top-most filter).\ntempFilters.pop();\n\n// Apply the new set of filters to the display object.\nfilteredObject.filters = tempFilters;\n'})}),"\n",(0,n.jsxs)(t.p,{children:["Similarly, to remove the bottom-most filter (the first one applied to the\nobject) you use the same code, substituting the Array class's ",(0,n.jsx)(t.code,{children:"shift()"})," method\nin place of the ",(0,n.jsx)(t.code,{children:"pop()"})," method."]}),"\n",(0,n.jsxs)(t.p,{children:["To remove a filter from the middle of an array of filters (assuming that the\narray has more than two filters) you can use the ",(0,n.jsx)(t.code,{children:"splice()"})," method. You must\nknow the index (the position in the array) of the filter you want to remove. For\nexample, the following code removes the second filter (the filter at index 1)\nfrom a display object:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{children:'// Example of removing a filter from the middle of a stack of filters\n// applied to a display object named "filteredObject".\n\nvar tempFilters:Array = filteredObject.filters;\n\n// Remove the second filter from the array. It\'s the item at index 1\n// because Array indexes start from 0.\n// The first "1" indicates the index of the filter to remove; the\n// second "1" indicates how many elements to remove.\ntempFilters.splice(1, 1);\n\n// Apply the new set of filters to the display object.\nfilteredObject.filters = tempFilters;\n'})}),"\n",(0,n.jsx)(t.h4,{id:"determining-a-filters-index",children:"Determining a filter's index"}),"\n",(0,n.jsx)(t.p,{children:"You need to know which filter to remove from the array, so that you know the\nindex of the filter. You must either know (by virtue of the way the application\nis designed), or calculate the index of the filter to remove."}),"\n",(0,n.jsxs)(t.p,{children:["The best approach is to design your application so that the filter you want to\nremove is always in the same position in the set of filters. For example, if you\nhave a single display object with a convolution filter and a drop-shadow filter\napplied to it (in that order), and you want to remove the drop-shadow filter but\nkeep the convolution filter, the filter is in a known position (the top-most\nfilter) so that you can know ahead of time which Array method to use (in this\ncase ",(0,n.jsx)(t.code,{children:"Array.pop()"})," to remove the drop-shadow filter)."]}),"\n",(0,n.jsx)(t.p,{children:"If the filter you want to remove is always a certain type, but not necessarily\nalways in the same position in the set of filters, you can check the data type\nof each filter in the array to determine which one to remove. For example, the\nfollowing code determines which of a set of filters is a glow filter, and\nremoves that filter from the set."}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{children:"// Example of removing a glow filter from a set of filters, where the\n// filter you want to remove is the only GlowFilter instance applied\n// to the filtered object.\n\nvar tempFilters:Array = filteredObject.filters;\n\n// Loop through the filters to find the index of the GlowFilter instance.\nvar glowIndex:int;\nvar numFilters:int = tempFilters.length;\nfor (var i:int = 0; i < numFilters; i++)\n{\n    if (tempFilters[i] is GlowFilter)\n    {\n        glowIndex = i;\n        break;\n    }\n}\n\n// Remove the glow filter from the array.\ntempFilters.splice(glowIndex, 1);\n\n// Apply the new set of filters to the display object.\nfilteredObject.filters = tempFilters;\n"})}),"\n",(0,n.jsxs)(t.p,{children:["In a more complex case, such as if the filter to remove is selected at runtime,\nthe best approach is to keep a separate, persistent copy of the filter array\nthat serves as the master list of filters. Any time you make a change to the set\nof filters, change the master list then apply that filter array as the ",(0,n.jsx)(t.code,{children:"filters"}),"\nproperty of the display object."]}),"\n",(0,n.jsx)(t.p,{children:"For example, in the following code listing, multiple convolution filters are\napplied to a display object to create different visual effects, and at a later\npoint in the application one of those filters is removed while the others are\nretained. In this case, the code keeps a master copy of the filters array, as\nwell as a reference to the filter to remove. Finding and removing the specific\nfilter is similar to the preceding approach, except that instead of making a\ntemporary copy of the filters array, the master copy is manipulated and then\napplied to the display object."}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{children:"// Example of removing a filter from a set of\n// filters, where there may be more than one\n// of that type of filter applied to the filtered\n// object, and you only want to remove one.\n\n// A master list of filters is stored in a separate,\n// persistent Array variable.\nvar masterFilterList:Array;\n\n// At some point, you store a reference to the filter you\n// want to remove.\nvar filterToRemove:ConvolutionFilter;\n\n// ... assume the filters have been added to masterFilterList,\n// which is then assigned as the filteredObject.filters:\nfilteredObject.filters = masterFilterList;\n\n// ... later, when it's time to remove the filter, this code gets called:\n\n// Loop through the filters to find the index of masterFilterList.\nvar removeIndex:int = -1;\nvar numFilters:int = masterFilterList.length;\nfor (var i:int = 0; i < numFilters; i++)\n{\n    if (masterFilterList[i] == filterToRemove)\n    {\n        removeIndex = i;\n        break;\n    }\n}\n\nif (removeIndex >= 0)\n{\n    // Remove the filter from the array.\n    masterFilterList.splice(removeIndex, 1);\n\n    // Apply the new set of filters to the display object.\n    filteredObject.filters = masterFilterList;\n}\n"})}),"\n",(0,n.jsxs)(t.p,{children:["In this approach (when you're comparing a stored filter reference to the items\nin the filters array to determine which filter to remove), you ",(0,n.jsx)(t.em,{children:"must"})," keep a\nseparate copy of the filters array\u2014the code does not work if you compare the\nstored filter reference to the elements in a temporary array copied from the\ndisplay object's ",(0,n.jsx)(t.code,{children:"filters"})," property. This is because internally, when you assign\nan array to the ",(0,n.jsx)(t.code,{children:"filters"})," property, the runtime makes a copy of each filter\nobject in the array. Those copies (rather than the original objects) are applied\nto the display object, and when you read the ",(0,n.jsx)(t.code,{children:"filters"})," property into a temporary\narray, the temporary array contains references to the copied filter objects\nrather than references to the original filter objects. Consequently, if in the\npreceding example you try to determine the index of ",(0,n.jsx)(t.code,{children:"filterToRemove"})," by\ncomparing it to the filters in a temporary filters array, no match is found."]}),"\n",(0,n.jsx)(t.h4,{id:"filters-and-object-transformations",children:"Filters and object transformations"}),"\n",(0,n.jsx)(t.p,{children:"No filtered region\u2014a drop shadow, for example\u2014outside of a display object's\nbounding box rectangle is considered to be part of the surface for the purposes\nof hit detection (determining if an instance overlaps or intersects with another\ninstance). Because the DisplayObject class's hit detection methods are\nvector-based, you cannot perform a hit detection on the bitmap result. For\nexample, if you apply a bevel filter to a button instance, hit detection is not\navailable on the beveled portion of the instance."}),"\n",(0,n.jsxs)(t.p,{children:["Scaling, rotating, and skewing are not supported by filters; if the filtered\ndisplay object itself is scaled (if ",(0,n.jsx)(t.code,{children:"scaleX"})," and ",(0,n.jsx)(t.code,{children:"scaleY"})," are not 100%), the\nfilter effect does not scale with the instance. This means that the original\nshape of the instance rotates, scales, or skews; however, the filter does not\nrotate, scale, or skew with the instance."]}),"\n",(0,n.jsx)(t.p,{children:"You can animate an instance with a filter to create realistic effects, or nest\ninstances and use the BitmapData class to animate filters to achieve this\neffect."}),"\n",(0,n.jsx)(t.h4,{id:"filters-and-bitmap-objects",children:"Filters and Bitmap objects"}),"\n",(0,n.jsxs)(t.p,{children:["When you apply any filter to a BitmapData object, the ",(0,n.jsx)(t.code,{children:"cacheAsBitmap"})," property\nis automatically set to ",(0,n.jsx)(t.code,{children:"true"}),". In this way, the filter is actually applied to\nthe copy of the object rather than to the original."]}),"\n",(0,n.jsx)(t.p,{children:"This copy is then placed on the main display (over the original object) as close\nas possible to the nearest pixel. If the bounds of the original bitmap change,\nthe filtered copy bitmap is recreated from the original, rather than being\nstretched or distorted."}),"\n",(0,n.jsxs)(t.p,{children:["If you clear all filters for a display object, the ",(0,n.jsx)(t.code,{children:"cacheAsBitmap"})," property is\nreset to what it was before the filter was applied."]})]})}function h(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(c,{...e})}):c(e)}},28453:(e,t,i)=>{i.d(t,{R:()=>o,x:()=>s});var r=i(96540);const n={},a=r.createContext(n);function o(e){const t=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:o(e.components),r.createElement(a.Provider,{value:t},e.children)}}}]);