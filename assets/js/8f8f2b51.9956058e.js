"use strict";(self.webpackChunkairsdk_dev=self.webpackChunkairsdk_dev||[]).push([[65305],{28453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>c});var a=n(96540);const o={},s=a.createContext(o);function i(e){const t=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),a.createElement(s.Provider,{value:t},e.children)}},90718:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>r,contentTitle:()=>c,default:()=>u,frontMatter:()=>i,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"development/files-and-data/working-with-local-sql-databases-in-air/using-synchronous-and-asynchronous-database-operations/understanding-the-asynchronous-execution-model","title":"Understanding the asynchronous execution model","description":"One common concern about using asynchronous execution mode is the assumption","source":"@site/docs/development/files-and-data/working-with-local-sql-databases-in-air/using-synchronous-and-asynchronous-database-operations/understanding-the-asynchronous-execution-model.md","sourceDirName":"development/files-and-data/working-with-local-sql-databases-in-air/using-synchronous-and-asynchronous-database-operations","slug":"/development/files-and-data/working-with-local-sql-databases-in-air/using-synchronous-and-asynchronous-database-operations/understanding-the-asynchronous-execution-model","permalink":"/docs/development/files-and-data/working-with-local-sql-databases-in-air/using-synchronous-and-asynchronous-database-operations/understanding-the-asynchronous-execution-model","draft":false,"unlisted":false,"editUrl":"https://github.com/airsdk/airsdk.dev/edit/main/docs/development/files-and-data/working-with-local-sql-databases-in-air/using-synchronous-and-asynchronous-database-operations/understanding-the-asynchronous-execution-model.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"mainSidebar","previous":{"title":"Using synchronous database operations","permalink":"/docs/development/files-and-data/working-with-local-sql-databases-in-air/using-synchronous-and-asynchronous-database-operations/using-synchronous-database-operations"},"next":{"title":"Using encryption with SQL databases","permalink":"/docs/development/files-and-data/working-with-local-sql-databases-in-air/using-encryption-with-sql-databases"}}');var o=n(74848),s=n(28453);const i={sidebar_position:2},c="Understanding the asynchronous execution model",r={},d=[];function h(e){const t={a:"a",code:"code",h1:"h1",header:"header",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.header,{children:(0,o.jsx)(t.h1,{id:"understanding-the-asynchronous-execution-model",children:"Understanding the asynchronous execution model"})}),"\n",(0,o.jsxs)(t.p,{children:["One common concern about using asynchronous execution mode is the assumption\nthat you can't start executing a\n",(0,o.jsx)(t.a,{href:"https://airsdk.dev/reference/actionscript/3.0/flash/data/SQLStatement.html",children:"SQLStatement"}),"\ninstance if another SQLStatement is currently executing against the same\ndatabase connection. In fact, this assumption isn't correct. While a\nSQLStatement instance is executing you can't change the ",(0,o.jsx)(t.code,{children:"text"})," property of the\nstatement. However, if you use a separate SQLStatement instance for each\ndifferent SQL statement that you want to execute, you can call the ",(0,o.jsx)(t.code,{children:"execute()"}),"\nmethod of a SQLStatement while another SQLStatement instance is still executing,\nwithout causing an error."]}),"\n",(0,o.jsxs)(t.p,{children:["Internally, when you're executing database operations using asynchronous\nexecution mode, each database connection (each\n",(0,o.jsx)(t.a,{href:"https://airsdk.dev/reference/actionscript/3.0/flash/data/SQLConnection.html",children:"SQLConnection"}),"\ninstance) has its own queue or list of operations that it is instructed to\nperform. The runtime executes each operation in sequence, in the order they are\nadded to the queue. When you create a SQLStatement instance and call its\n",(0,o.jsx)(t.code,{children:"execute()"})," method, that statement execution operation is added to the queue for\nthe connection. If no operation is currently executing on that SQLConnection\ninstance, the statement begins executing in the background. Suppose that within\nthe same block of code you create another SQLStatement instance and also call\nthat method's ",(0,o.jsx)(t.code,{children:"execute()"})," method. That second statement execution operation is\nadded to the queue behind the first statement. As soon as the first statement\nfinishes executing, the runtime moves to the next operation in the queue. The\nprocessing of subsequent operations in the queue happens in the background, even\nwhile the ",(0,o.jsx)(t.code,{children:"result"})," event for the first operation is being dispatched in the main\napplication code. The following code demonstrates this technique:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{children:"// Using asynchronous execution mode\nvar stmt1:SQLStatement = new SQLStatement();\nstmt1.sqlConnection = conn;\n\n// ... Set statement text and parameters, and register event listeners ...\n\nstmt1.execute();\n\n// At this point stmt1's execute() operation is added to conn's execution queue.\n\nvar stmt2:SQLStatement = new SQLStatement();\nstmt2.sqlConnection = conn;\n\n// ... Set statement text and parameters, and register event listeners ...\n\nstmt2.execute();\n\n// At this point stmt2's execute() operation is added to conn's execution queue.\n// When stmt1 finishes executing, stmt2 will immediately begin executing\n// in the background.\n"})}),"\n",(0,o.jsxs)(t.p,{children:["There is an important side effect of the database automatically executing\nsubsequent queued statements. If a statement depends on the outcome of another\noperation, you can't add the statement to the queue (in other words, you can't\ncall its ",(0,o.jsx)(t.code,{children:"execute()"})," method) until the first operation completes. This is\nbecause once you've called the second statement's ",(0,o.jsx)(t.code,{children:"execute()"})," method, you can't\nchange the statement's ",(0,o.jsx)(t.code,{children:"text"})," or ",(0,o.jsx)(t.code,{children:"parameters"})," properties. In that case you must\nwait for the event indicating that the first operation completes before starting\nthe next operation. For example, if you want to execute a statement in the\ncontext of a transaction, the statement execution depends on the operation of\nopening the transaction. After calling the ",(0,o.jsx)(t.code,{children:"SQLConnection.begin()"})," method to\nopen the transaction, you need to wait for the SQLConnection instance to\ndispatch its ",(0,o.jsx)(t.code,{children:"begin"})," event. Only then can you call the SQLStatement instance's\n",(0,o.jsx)(t.code,{children:"execute()"})," method. In this example the simplest way to organize the application\nto ensure that the operations are executed properly is to create a method that's\nregistered as a listener for the ",(0,o.jsx)(t.code,{children:"begin"})," event. The code to call the\n",(0,o.jsx)(t.code,{children:"SQLStatement.execute()"})," method is placed within that listener method."]})]})}function u(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(h,{...e})}):h(e)}}}]);