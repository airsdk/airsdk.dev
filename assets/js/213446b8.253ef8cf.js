"use strict";(self.webpackChunkairsdk_dev=self.webpackChunkairsdk_dev||[]).push([[38409],{28453:(e,n,r)=>{r.d(n,{R:()=>i,x:()=>o});var s=r(96540);const t={},a=s.createContext(t);function i(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),s.createElement(a.Provider,{value:n},e.children)}},52342:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>l,frontMatter:()=>i,metadata:()=>s,toc:()=>h});const s=JSON.parse('{"id":"development/client-system-interaction/using-workers-for-concurrency/communicating-between-workers","title":"Communicating between workers","description":"Although workers run their code in separate execution threads, they wouldn\'t","source":"@site/docs/development/client-system-interaction/using-workers-for-concurrency/communicating-between-workers.md","sourceDirName":"development/client-system-interaction/using-workers-for-concurrency","slug":"/development/client-system-interaction/using-workers-for-concurrency/communicating-between-workers","permalink":"/docs/development/client-system-interaction/using-workers-for-concurrency/communicating-between-workers","draft":false,"unlisted":false,"editUrl":"https://github.com/airsdk/airsdk.dev/edit/main/docs/development/client-system-interaction/using-workers-for-concurrency/communicating-between-workers.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"mainSidebar","previous":{"title":"Creating and managing workers","permalink":"/docs/development/client-system-interaction/using-workers-for-concurrency/creating-and-managing-workers"},"next":{"title":"Printing","permalink":"/docs/development/client-system-interaction/printing/"}}');var t=r(74848),a=r(28453);const i={sidebar_position:3},o="Communicating between workers",c={},h=[{value:"Passing data with a shared property",id:"passing-data-with-a-shared-property",level:2},{value:"Passing data with a MessageChannel",id:"passing-data-with-a-messagechannel",level:2},{value:"Sharing data using a shareable ByteArray",id:"sharing-data-using-a-shareable-bytearray",level:2},{value:"Shared references and copied values",id:"shared-references-and-copied-values",level:2},{value:"Additional data-sharing techniques",id:"additional-data-sharing-techniques",level:2},{value:"See also",id:"see-also",level:4}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"communicating-between-workers",children:"Communicating between workers"})}),"\n",(0,t.jsx)(n.p,{children:"Although workers run their code in separate execution threads, they wouldn't\noffer any benefit if they were completely isolated from each other.\nCommunication between workers ultimately means passing data between workers.\nThere are three main mechanisms for getting data from one worker to another."}),"\n",(0,t.jsx)(n.p,{children:"When deciding which of these data-sharing techniques is appropriate for a\nparticular data-passing need, consider the two main ways they differ. One\ndifference between them is with whether there is an event to notify the receiver\nthat new data is available or whether the receiving worker must check for\nupdates. Another difference between these data-sharing techniques has to do with\nhow the data is actually passed. In some cases the receiving worker gets is a\ncopy of the shared data, which means that more objects are created taking more\nmemory and cpu cycles. In other cases the workers access objects that reference\nthe same underlying system memory, which means fewer objects are created and\nless memory is used overall. These differences are outlined here:"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Communication technique"}),(0,t.jsx)(n.th,{children:"Dispatches event when receiving data"}),(0,t.jsx)(n.th,{children:"Shares memory between workers"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Worker shared properties"}),(0,t.jsx)(n.td,{children:"No"}),(0,t.jsx)(n.td,{children:"No, objects are copies not references"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"MessageChannel"}),(0,t.jsx)(n.td,{children:"Yes"}),(0,t.jsx)(n.td,{children:"No, objects are copies not references"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Shareable ByteArray"}),(0,t.jsx)(n.td,{children:"No"}),(0,t.jsx)(n.td,{children:"Yes, memory is shared"})]})]})]}),"\n",(0,t.jsx)(n.h2,{id:"passing-data-with-a-shared-property",children:"Passing data with a shared property"}),"\n",(0,t.jsxs)(n.p,{children:["The most basic way to share data between workers is to use a shared property.\nEach worker maintains an internal dictionary of shared property values. The\nproperties are stored with String key names to distinguish between the\nproperties. To store an object on a worker as a shared property, call the Worker\nobject's ",(0,t.jsx)(n.code,{children:"setSharedProperty()"})," method with two arguments, the key name and the\nvalue to store:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'// code running in the parent worker\nbgWorker.setSharedProperty("sharedPropertyName", someObject);\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Once the shared property has been set, the value can be read by calling the\nWorker object's ",(0,t.jsx)(n.code,{children:"getSharedProperty()"})," method, passing in the key name:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'// code running in the background worker\nreceivedProperty = Worker.current.getSharedProperty("sharedPropertyName");\n'})}),"\n",(0,t.jsxs)(n.p,{children:["There is no restriction on which worker reads or sets the property value. For\nexample, code in a background worker can call its ",(0,t.jsx)(n.code,{children:"setSharedProperty()"})," method\nto store a value. Code running in the parent worker can then use\n",(0,t.jsx)(n.code,{children:"getSharedProperty()"})," to receive the data."]}),"\n",(0,t.jsxs)(n.p,{children:["The value that's passed to the ",(0,t.jsx)(n.code,{children:"setSharedProperty()"})," method can be almost any\ntype of object. When you call the ",(0,t.jsx)(n.code,{children:"getSharedProperty()"})," method, the object\nthat's returned is a copy of the object passed in to ",(0,t.jsx)(n.code,{children:"setSharedProperty()"})," and\nnot a reference to the same object, except in a few special cases. The specifics\nof how data is shared are explained in\n",(0,t.jsx)(n.a,{href:"#shared-references-and-copied-values",children:"Shared references and copied values"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["The biggest advantage of using a shared property to pass data between workers is\nthat it's available even before the worker is running. You can call a background\nWorker object's ",(0,t.jsx)(n.code,{children:"setSharedProperty()"})," method to set a shared property even\nbefore the worker is running. When the parent worker calls the Worker's\n",(0,t.jsx)(n.code,{children:"start()"})," method, the runtime calls the child worker's main class's constructor.\nAny shared properties that were set before ",(0,t.jsx)(n.code,{children:"start()"})," was called are available\nfor code in the child worker to read."]}),"\n",(0,t.jsx)(n.h2,{id:"passing-data-with-a-messagechannel",children:"Passing data with a MessageChannel"}),"\n",(0,t.jsxs)(n.p,{children:["A message channel provides a one-way data-passing link between two workers.\nUsing a MessageChannel object to pass data between workers has one key\nadvantage. When you send a message (an object) using a message channel, the\nMessageChannel object dispatches a ",(0,t.jsx)(n.code,{children:"channelMessage"})," event. Code in the receiving\nworker can listen for that event to know when data is available. That way the\nreceiving worker doesn't need to continuously check for data updates."]}),"\n",(0,t.jsxs)(n.p,{children:["A message channel is associated with only two workers, a sender and a receiver.\nTo create a MessageChannel object, call the sending Worker object's\n",(0,t.jsx)(n.code,{children:"createMessageChannel()"})," method, passing the receiving worker as an argument:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"// In the sending worker swf\nvar sendChannel:MessageChannel;\nsendChannel = Worker.current.createMessageChannel(receivingWorker);\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Both workers need to have access to the MessageChannel object. The simplest way\nto do this is to pass the MessageChannel object using the ",(0,t.jsx)(n.code,{children:"setSharedProperty()"}),"\nmethod:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'receivingWorker.setSharedProperty("incomingChannel", sendChannel);\n'})}),"\n",(0,t.jsxs)(n.p,{children:["In the receiving worker, register a listener for the MessageChannel object's\n",(0,t.jsx)(n.code,{children:"channelMessage"})," event. This event is dispatched when the sending worker sends\ndata through the message channel."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'// In the receiving worker swf\nvar incomingChannel:MessageChannel;\nincomingChannel = Worker.current.getSharedProperty("incomingChannel");\nincomingChannel.addEventListener(Event.CHANNEL_MESSAGE, handleIncomingMessage);\n'})}),"\n",(0,t.jsxs)(n.p,{children:["To actually send data, in the sending worker call the MessageChannel object's\n",(0,t.jsx)(n.code,{children:"send()"})," method:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'// In the sending worker swf\nsendChannel.send("This is a message");\n'})}),"\n",(0,t.jsxs)(n.p,{children:["In the receiving worker, the MessageChannel calls the ",(0,t.jsx)(n.code,{children:"channelMessage"})," event\nhandler. The receiving worker can then get the data by calling the\nMessageChannel object's ",(0,t.jsx)(n.code,{children:"receive()"})," method."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"private function handleIncomingMessage(event:Event):void\n{\n\t  var message:String = incomingChannel.receive() as String;\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The object returned by the receive method has the same data type as the object\nthat was passed in to the ",(0,t.jsx)(n.code,{children:"send()"})," method. The received object is a copy of the\nobject passed in by the sender and not a reference to the object in the sending\nworker, unless it is one of a few data types, as described in\n",(0,t.jsx)(n.a,{href:"#shared-references-and-copied-values",children:"Shared references and copied values"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"sharing-data-using-a-shareable-bytearray",children:"Sharing data using a shareable ByteArray"}),"\n",(0,t.jsxs)(n.p,{children:["When an object is passed between two workers, the receiving worker gets a new\nobject that's a copy of the original one. The two objects are stored in\ndifferent locations in the system's memory. Consequently, each copy of the\nobject that's received increases the total memory used by the runtime. In\naddition, any changes that you make to an object in one worker do not affect the\ncopy in the other worker. For more details about how data is copied, see\n",(0,t.jsx)(n.a,{href:"#shared-references-and-copied-values",children:"Shared references and copied values"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["By default, a ByteArray object uses the same behavior. If you pass a ByteArray\ninstance to a Worker object's ",(0,t.jsx)(n.code,{children:"setSharedProperty()"})," method or a MessageChannel\nobject's ",(0,t.jsx)(n.code,{children:"send()"})," method, the runtime creates a new ByteArray in the computer's\nmemory and the receiving worker gets a ByteArray instance that's a reference to\nthat new ByteArray. However, you can change this behavior for a ByteArray object\nby setting its ",(0,t.jsx)(n.code,{children:"shareable"})," property to ",(0,t.jsx)(n.code,{children:"true"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"When a shareable ByteArray object is passed from one worker to another, the\nByteArray instance in the receiving worker is a reference to the same underlying\noperating system memory that's used by the ByteArray instance in the sending\nworker. When code in one worker changes the contents of the byte array, those\nchanges are immediately available in other workers that have access to that\nshared byte array."}),"\n",(0,t.jsx)(n.p,{children:"Because workers execute their code simultaneously, it's possible for two workers\nto attempt to access the same bytes in a byte array at the same time. This could\nlead to data loss or corruption. There are several apis that you can use to\nmanage access to shared resources and avoid those issues."}),"\n",(0,t.jsx)(n.p,{children:"The ByteArray class has methods that allow you to validate and change the byte\narray's contents in a single operation:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.a,{href:"https://airsdk.dev/reference/actionscript/3.0/flash/utils/ByteArray.html#atomicCompareAndSwapIntAt()",children:"atomicCompareAndSwapIntAt() method"})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.a,{href:"https://airsdk.dev/reference/actionscript/3.0/flash/utils/ByteArray.html#atomicCompareAndSwapLength()",children:"atomicCompareAndSwapLength() method"})}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"In addition, the flash.concurrent package includes classes that provide access\ncontrol for working with shared resources:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.a,{href:"https://airsdk.dev/reference/actionscript/3.0/flash/concurrent/Mutex.html",children:"Mutex class"})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.a,{href:"https://airsdk.dev/reference/actionscript/3.0/flash/concurrent/Condition.html",children:"Condition class"})}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"shared-references-and-copied-values",children:"Shared references and copied values"}),"\n",(0,t.jsxs)(n.p,{children:["In the normal case, when you call ",(0,t.jsx)(n.code,{children:"Worker.setSharedProperty()"})," or\n",(0,t.jsx)(n.code,{children:"MessageChannel.send()"}),", the object that's passed to the receiving worker is\npassed by serializing it in AMF format. This has a few consequences:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["The object that's created in the receiving worker when it's\n",(0,t.jsx)(n.code,{children:"getSharedProperty()"})," method is called is deserialized from the AMF bytes. It\nis a copy of the original object, not a reference to the object. Any changes\nthat are made to the object in either worker are not changed in the copy in\nthe other worker."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["Objects that can't be serialized in AMF format such as display objects can't\nbe passed to a worker using ",(0,t.jsx)(n.code,{children:"Worker.setSharedProperty()"})," or\n",(0,t.jsx)(n.code,{children:"MessageChannel.send()"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["In order for a custom class to be deserialized properly, the class definition\nmust be registered using the ",(0,t.jsx)(n.code,{children:"flash.net.registerClassAlias()"})," function or\n",(0,t.jsx)(n.code,{children:"[RemoteClass]"})," metadata. The same alias must be used for both worker's\nversions of the class."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"There are five special cases of objects that are truly shared rather than copied\nbetween workers:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Worker objects"}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"MessageChannel objects"}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["shareable byte array (a ByteArray object whose ",(0,t.jsx)(n.code,{children:"shareable"})," property is ",(0,t.jsx)(n.code,{children:"true"}),")"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Mutex objects"}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Condition objects"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["When you pass an instance of one of these objects using the\n",(0,t.jsx)(n.code,{children:"Worker.setSharedProperty()"})," method or ",(0,t.jsx)(n.code,{children:"MessageChannel.send()"})," method, each\nworker has a reference to the same underlying object. Changes made to an\ninstance in one worker are immediately available in other workers. In addition,\nif you pass the same instance of one of these objects to a worker more than\nonce, the runtime doesn't create a new copy of the object in the receiving\nworker. Instead, the same reference is re-used."]}),"\n",(0,t.jsx)(n.h2,{id:"additional-data-sharing-techniques",children:"Additional data-sharing techniques"}),"\n",(0,t.jsx)(n.p,{children:"In addition to the worker-specific mechanisms for passing data, workers can also\nexchange data using any of the existing apis that support sharing data between\ntwo swf applications, such as the following:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"local shared objects"}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"writing data to a file in one worker and reading from the file in another\nworker"}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"storing data to and reading data from a SQLite database"}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"When you share a resource between two or more workers, you generally need to\navoid having multiple workers accessing the resource at the same time. For\nexample, having multiple workers access a file on the local file system could\ncause data loss or corruption and may not be supported by the operating system."}),"\n",(0,t.jsx)(n.p,{children:"To guard against concurrent access problems, use the Mutex and Condition classes\nin the flash.concurrent package to provide access control for working with\nshared resources."}),"\n",(0,t.jsx)(n.p,{children:"Unlike other data-sharing mechanisms, the SQLite database engine is designed for\nconcurrent access and has its own transaction support built in. Multiple workers\ncan access a SQLite database without risk of corrupting the data. Because the\nworkers use different SQLConnection instances, each worker accesses the database\nin a separate transaction. Simultaneous data manipulation operations do not\naffect the integrity of the data."}),"\n",(0,t.jsx)(n.h4,{id:"see-also",children:"See also"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.a,{href:"/docs/development/files-and-data/working-with-local-sql-databases-in-air/",children:"Working with local SQL databases in AIR"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.a,{href:"https://airsdk.dev/reference/actionscript/3.0/flash/concurrent/package-detail.html",children:"flash.concurrent package"})})]})}function l(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}}}]);