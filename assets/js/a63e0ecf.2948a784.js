"use strict";(self.webpackChunkairsdk_dev=self.webpackChunkairsdk_dev||[]).push([[67652],{28453:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>c});var i=s(96540);const t={},r=i.createContext(t);function a(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),i.createElement(r.Provider,{value:n},e.children)}},38001:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"development/display/display-programming/display-object-example-sprite-arranger","title":"Display object example: SpriteArranger","description":"The SpriteArranger sample application builds upon the Geometric Shapes sample","source":"@site/docs/development/display/display-programming/display-object-example-sprite-arranger.md","sourceDirName":"development/display/display-programming","slug":"/development/display/display-programming/display-object-example-sprite-arranger","permalink":"/docs/development/display/display-programming/display-object-example-sprite-arranger","draft":false,"unlisted":false,"editUrl":"https://github.com/airsdk/airsdk.dev/edit/main/docs/development/display/display-programming/display-object-example-sprite-arranger.md","tags":[],"version":"current","sidebarPosition":10,"frontMatter":{"sidebar_position":10},"sidebar":"mainSidebar","previous":{"title":"Loading display content dynamically","permalink":"/docs/development/display/display-programming/loading-display-content-dynamically"},"next":{"title":"Overview","permalink":"/docs/development/display/working-with-geometry/"}}');var t=s(74848),r=s(28453);const a={sidebar_position:10},c="Display object example: SpriteArranger",d={},l=[{value:"Defining the SpriteArranger classes",id:"defining-the-spritearranger-classes",level:2},{value:"The DrawingCanvas class",id:"the-drawingcanvas-class",level:4},{value:"The GeometricSprite class and its subclasses",id:"the-geometricsprite-class-and-its-subclasses",level:4},{value:"Adding display objects to the canvas",id:"adding-display-objects-to-the-canvas",level:2},{value:"Clicking and dragging display objects",id:"clicking-and-dragging-display-objects",level:2},{value:"Rearranging display object layering",id:"rearranging-display-object-layering",level:2}];function o(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"display-object-example-spritearranger",children:"Display object example: SpriteArranger"})}),"\n",(0,t.jsxs)(n.p,{children:["The SpriteArranger sample application builds upon the Geometric Shapes sample\napplication described separately in ",(0,t.jsx)(n.em,{children:"Learning ActionScript 3.0"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"The SpriteArranger sample application illustrates a number of concepts for\ndealing with display objects:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Extending display object classes"}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Adding objects to the display list"}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Layering display objects and working with display object containers"}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Responding to display object events"}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Using properties and methods of display objects"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["To get the application files for this sample, see\n",(0,t.jsx)(n.a,{href:"https://github.com/joshtynjala/flash-platform-as3-dev-guide-examples/releases/tag/original",children:(0,t.jsx)(n.em,{children:"FlashPlatformAS3DevGuideExamples.zip"})}),".\nThe SpriteArranger application files can be found in the folder\nExamples/SpriteArranger. The application consists of the following files:"]}),"\n",(0,t.jsxs)("table",{children:[(0,t.jsx)("thead",{children:(0,t.jsxs)("tr",{children:[(0,t.jsx)("th",{children:(0,t.jsx)("p",{children:"File"})}),(0,t.jsx)("th",{children:(0,t.jsx)("p",{children:"Description"})})]})}),(0,t.jsxs)("tbody",{children:[(0,t.jsxs)("tr",{children:[(0,t.jsxs)("td",{children:[(0,t.jsx)("p",{children:"SpriteArranger.mxml"}),(0,t.jsx)("p",{children:"or"}),(0,t.jsx)("p",{children:"SpriteArranger.fla"})]}),(0,t.jsx)("td",{children:(0,t.jsx)("p",{children:"The main\napplication file in Flash (FLA) or Flex (MXML)."})})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{children:(0,t.jsx)("p",{children:"com/example/programmingas3/SpriteArranger/CircleSprite.as"})}),(0,t.jsx)("td",{children:(0,t.jsx)("p",{children:"A class\ndefining a type of Sprite object that renders a circle\non-screen."})})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{children:(0,t.jsx)("p",{children:"com/example/programmingas3/SpriteArranger/DrawingCanvas.as"})}),(0,t.jsx)("td",{children:(0,t.jsx)("p",{children:"A class\ndefining the canvas, which is a display object container that contains\nGeometricSprite objects."})})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{children:(0,t.jsx)("p",{children:"com/example/programmingas3/SpriteArranger/SquareSprite.as"})}),(0,t.jsx)("td",{children:(0,t.jsx)("p",{children:"A class\ndefining a type of Sprite object that renders a square\non-screen."})})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{children:(0,t.jsx)("p",{children:"com/example/programmingas3/SpriteArranger/TriangleSprite.as"})}),(0,t.jsx)("td",{children:(0,t.jsx)("p",{children:"A class\ndefining a type of Sprite object that renders a triangle\non-screen."})})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{children:(0,t.jsx)("p",{children:"com/example/programmingas3/SpriteArranger/GeometricSprite.as"})}),(0,t.jsx)("td",{children:(0,t.jsx)("p",{children:"A class that\nextends the Sprite object, used to define an on-screen shape. The\nCircleSprite, SquareSprite, and TriangleSprite each extend this\nclass."})})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{children:(0,t.jsx)("p",{children:"com/example/programmingas3/geometricshapes/IGeometricShape.as"})}),(0,t.jsx)("td",{children:(0,t.jsx)("p",{children:"The base\ninterface defining methods to be implemented by all geometric shape\nclasses."})})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{children:(0,t.jsx)("p",{children:"com/example/programmingas3/geometricshapes/IPolygon.as"})}),(0,t.jsx)("td",{children:(0,t.jsx)("p",{children:"An interface\ndefining methods to be implemented by geometric shape classes that have\nmultiple sides."})})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{children:(0,t.jsx)("p",{children:"com/example/programmingas3/geometricshapes/RegularPolygon.as"})}),(0,t.jsx)("td",{children:(0,t.jsx)("p",{children:"A type of\ngeometric shape that has sides of equal length positioned symmetrically\naround the shape's center."})})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{children:(0,t.jsx)("p",{children:"com/example/programmingas3/geometricshapes/Circle.as"})}),(0,t.jsx)("td",{children:(0,t.jsx)("p",{children:"A type of\ngeometric shape that defines a circle."})})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{children:(0,t.jsx)("p",{children:"com/example/programmingas3/geometricshapes/EquilateralTriangle.as"})}),(0,t.jsx)("td",{children:(0,t.jsx)("p",{children:"A subclass of\nRegularPolygon that defines a triangle with all sides the same\nlength."})})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{children:(0,t.jsx)("p",{children:"com/example/programmingas3/geometricshapes/Square.as"})}),(0,t.jsx)("td",{children:(0,t.jsx)("p",{children:"A subclass of\nRegularPolygon defining a rectangle with all four sides the same\nlength."})})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{children:(0,t.jsx)("p",{children:"com/example/programmingas3/geometricshapes/GeometricShapeFactory.as"})}),(0,t.jsx)("td",{children:(0,t.jsx)("p",{children:'A class\ncontaining a "factory method" for creating shapes given a shape type and\nsize.'})})]})]})]}),"\n",(0,t.jsx)(n.h2,{id:"defining-the-spritearranger-classes",children:"Defining the SpriteArranger classes"}),"\n",(0,t.jsx)(n.p,{children:'The SpriteArranger application lets the user add a variety of display objects to\nthe on-screen "canvas."'}),"\n",(0,t.jsx)(n.p,{children:"The DrawingCanvas class defines a drawing area, a type of display object\ncontainer, to which the user can add on-screen shapes. These on-screen shapes\nare instances of one of the subclasses of the GeometricSprite class."}),"\n",(0,t.jsx)(n.h4,{id:"the-drawingcanvas-class",children:"The DrawingCanvas class"}),"\n",(0,t.jsx)(n.p,{children:"In Flex, all child display objects added to a Container object must be of a\nclass that descends from the mx.core.UIComponent class. This application adds an\ninstance of the DrawingCanvas class as a child of an mx.containers.VBox object,\nas defined in MXML code in the SpriteArranger.mxml file. This inheritance is\ndefined in the DrawingCanvas class declaration, as follows:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"public class DrawingCanvas extends UIComponent\n"})}),"\n",(0,t.jsx)(n.p,{children:"The UIComponent class inherits from the DisplayObject, DisplayObjectContainer,\nand Sprite classes, and the code in the DrawingCanvas class uses methods and\nproperties of those classes."}),"\n",(0,t.jsx)(n.p,{children:"The DrawingCanvas class extends the Sprite class, and this inheritance is\ndefined in the DrawingCanvas class declaration, as follows:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"public class DrawingCanvas extends Sprite\n"})}),"\n",(0,t.jsx)(n.p,{children:"The Sprite class is a subclass of the DisplayObjectContainer and DisplayObject\nclasses, and the DrawingCanvas class uses methods and properties of those\nclasses."}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"DrawingCanvas()"})," constructor method sets up a Rectangle object, ",(0,t.jsx)(n.code,{children:"bounds"}),",\nwhich is property that is later used in drawing the outline of the canvas. It\nthen calls the ",(0,t.jsx)(n.code,{children:"initCanvas()"})," method, as follows:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"this.bounds = new Rectangle(0, 0, w, h);\ninitCanvas(fillColor, lineColor);\n"})}),"\n",(0,t.jsxs)(n.p,{children:["AS the following example shows, the ",(0,t.jsx)(n.code,{children:"initCanvas()"})," method defines various\nproperties of the DrawingCanvas object, which were passed as arguments to the\nconstructor function:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"this.lineColor = lineColor;\nthis.fillColor = fillColor;\nthis.width = 500;\nthis.height = 200;\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"initCanvas()"})," method then calls the ",(0,t.jsx)(n.code,{children:"drawBounds()"})," method, which draws the\ncanvas using the DrawingCanvas class's ",(0,t.jsx)(n.code,{children:"graphics"})," property. The ",(0,t.jsx)(n.code,{children:"graphics"}),"\nproperty is inherited from the Shape class."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"this.graphics.clear();\nthis.graphics.lineStyle(1.0, this.lineColor, 1.0);\nthis.graphics.beginFill(this.fillColor, 1.0);\nthis.graphics.drawRect(bounds.left - 1,\n                        bounds.top - 1,\n                        bounds.width + 2,\n                        bounds.height + 2);\nthis.graphics.endFill();\n"})}),"\n",(0,t.jsx)(n.p,{children:"The following additional methods of the DrawingCanvas class are invoked based on\nuser interactions with the application:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"addShape()"})," and ",(0,t.jsx)(n.code,{children:"describeChildren()"})," methods, which are described in\n",(0,t.jsx)(n.a,{href:"/docs/development/display/display-programming/display-object-example-sprite-arranger#adding-display-objects-to-the-canvas",children:"Adding display objects to the canvas"})]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"moveToBack()"}),", ",(0,t.jsx)(n.code,{children:"moveDown()"}),", ",(0,t.jsx)(n.code,{children:"moveToFront()"}),", and ",(0,t.jsx)(n.code,{children:"moveUp()"})," methods,\nwhich are described in\n",(0,t.jsx)(n.a,{href:"/docs/development/display/display-programming/display-object-example-sprite-arranger#rearranging-display-object-layering",children:"Rearranging display object layering"})]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"onMouseUp()"})," method, which is described in\n",(0,t.jsx)(n.a,{href:"/docs/development/display/display-programming/display-object-example-sprite-arranger#clicking-and-dragging-display-objects",children:"Clicking and dragging display objects"})]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"the-geometricsprite-class-and-its-subclasses",children:"The GeometricSprite class and its subclasses"}),"\n",(0,t.jsx)(n.p,{children:"Each display object the user can add to the canvas is an instance of one of the\nfollowing subclasses of the GeometricSprite class:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"CircleSprite"}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"SquareSprite"}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"TriangleSprite"}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"The GeometricSprite class extends the flash.display.Sprite class:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"public class GeometricSprite extends Sprite\n"})}),"\n",(0,t.jsx)(n.p,{children:"The GeometricSprite class includes a number of properties common to all\nGeometricSprite objects. These are set in the constructor function based on\nparameters passed to the function. For example:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"this.size = size;\nthis.lineColor = lColor;\nthis.fillColor = fColor;\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"geometricShape"})," property of the GeometricSprite class defines an\nIGeometricShape interface, which defines the mathematical properties, but not\nthe visual properties, of the shape. The classes that implement the\nIGeometricShape interface are defined in the GeometricShapes sample application\ndescribed in ",(0,t.jsx)(n.em,{children:"Learning ActionScript 3.0"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["The GeometricSprite class defines the ",(0,t.jsx)(n.code,{children:"drawShape()"}),' method, which is further\nrefined in the override definitions in each subclass of GeometricSprite. For\nmore information, see the "Adding display objects to the canvas" section, which\nfollows.']}),"\n",(0,t.jsx)(n.p,{children:"The GeometricSprite class also provides the following methods:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"onMouseDown()"})," and ",(0,t.jsx)(n.code,{children:"onMouseUp()"})," methods, which are described in\n",(0,t.jsx)(n.a,{href:"/docs/development/display/display-programming/display-object-example-sprite-arranger#clicking-and-dragging-display-objects",children:"Clicking and dragging display objects"})]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"showSelected()"})," and ",(0,t.jsx)(n.code,{children:"hideSelected()"})," methods, which are described in\n",(0,t.jsx)(n.a,{href:"/docs/development/display/display-programming/display-object-example-sprite-arranger#clicking-and-dragging-display-objects",children:"Clicking and dragging display objects"})]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"adding-display-objects-to-the-canvas",children:"Adding display objects to the canvas"}),"\n",(0,t.jsxs)(n.p,{children:["When the user clicks the Add Shape button, the application calls the\n",(0,t.jsx)(n.code,{children:"addShape()"})," method of the DrawingCanvas class. It instantiates a new\nGeometricSprite by calling the appropriate constructor function of one of the\nGeometricSprite subclasses, as the following example shows:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'public function addShape(shapeName:String, len:Number):void\n{\n    var newShape:GeometricSprite;\n    switch (shapeName)\n    {\n        case "Triangle":\n            newShape = new TriangleSprite(len);\n            break;\n\n        case "Square":\n            newShape = new SquareSprite(len);\n            break;\n\n        case "Circle":\n            newShape = new CircleSprite(len);\n            break;\n    }\n    newShape.alpha = 0.8;\n    this.addChild(newShape);\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Each constructor method calls the ",(0,t.jsx)(n.code,{children:"drawShape()"})," method, which uses the\n",(0,t.jsx)(n.code,{children:"graphics"})," property of the class (inherited from the Sprite class) to draw the\nappropriate vector graphic. For example, the ",(0,t.jsx)(n.code,{children:"drawShape()"})," method of the\nCircleSprite class includes the following code:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"this.graphics.clear();\nthis.graphics.lineStyle(1.0, this.lineColor, 1.0);\nthis.graphics.beginFill(this.fillColor, 1.0);\nvar radius:Number = this.size / 2;\nthis.graphics.drawCircle(radius, radius, radius);\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The second to last line of the ",(0,t.jsx)(n.code,{children:"addShape()"})," function sets the ",(0,t.jsx)(n.code,{children:"alpha"})," property\nof the display object (inherited from the DisplayObject class), so that each\ndisplay object added to the canvas is slightly transparent, letting the user see\nthe objects behind it."]}),"\n",(0,t.jsxs)(n.p,{children:["The final line of the ",(0,t.jsx)(n.code,{children:"addChild()"})," method adds the new display object to the\nchild list of the instance of the DrawingCanvas class, which is already on the\ndisplay list. This causes the new display object to appear on the Stage."]}),"\n",(0,t.jsxs)(n.p,{children:["The interface for the application includes two text fields, ",(0,t.jsx)(n.code,{children:"selectedSpriteTxt"}),"\nand ",(0,t.jsx)(n.code,{children:"outputTxt"}),". The text properties of these text fields are updated with\ninformation about the GeometricSprite objects that have been added to the canvas\nor selected by the user. The GeometricSprite class handles this\ninformation-reporting task by overriding the ",(0,t.jsx)(n.code,{children:"toString()"})," method, as follows:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"public override function toString():String\n{\n"})}),"\n",(0,t.jsx)(n.p,{children:'return this.shapeType + " of size " + this.size + " at " + this.x + ", " + this.y;'}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"shapeType"})," property is set to the appropriate value in the constructor\nmethod of each GeometricSprite subclass. For example, the ",(0,t.jsx)(n.code,{children:"toString()"})," method\nmight return the following value for a CircleSprite instance recently added to\nthe DrawingCanvas instance:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"Circle of size 50 at 0, 0\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"describeChildren()"})," method of the DrawingCanvas class loops through the\ncanvas's child list, using the ",(0,t.jsx)(n.code,{children:"numChildren"})," property (inherited from the\nDisplayObjectContainer class) to set the limit of the ",(0,t.jsx)(n.code,{children:"for"})," loop. It generates a\nstring listing each child, as follows:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'var desc:String = "";\nvar child:DisplayObject;\nfor (var i:int=0; i < this.numChildren; i++)\n{\n    child = this.getChildAt(i);\n    desc += i + ": " + child + \'\\n\';\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["The resulting string is used to set the ",(0,t.jsx)(n.code,{children:"text"})," property of the ",(0,t.jsx)(n.code,{children:"outputTxt"})," text\nfield."]}),"\n",(0,t.jsx)(n.h2,{id:"clicking-and-dragging-display-objects",children:"Clicking and dragging display objects"}),"\n",(0,t.jsxs)(n.p,{children:["When the user clicks on a GeometricSprite instance, the application calls the\n",(0,t.jsx)(n.code,{children:"onMouseDown()"})," event handler. As the following shows, this event handler is set\nto listen for mouse down events in the constructor function of the\nGeometricSprite class:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"this.addEventListener(MouseEvent.MOUSE_DOWN, onMouseDown);\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"onMouseDown()"})," method then calls the ",(0,t.jsx)(n.code,{children:"showSelected()"})," method of the\nGeometricSprite object. If it is the first time this method has been called for\nthe object, the method creates a new Shape object named ",(0,t.jsx)(n.code,{children:"selectionIndicator"})," and\nit uses the ",(0,t.jsx)(n.code,{children:"graphics"})," property of the Shape object to draw a red highlight\nrectangle, as follows:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"this.selectionIndicator = new Shape();\nthis.selectionIndicator.graphics.lineStyle(1.0, 0xFF0000, 1.0);\nthis.selectionIndicator.graphics.drawRect(-1, -1, this.size + 1, this.size + 1);\nthis.addChild(this.selectionIndicator);\n"})}),"\n",(0,t.jsxs)(n.p,{children:["If this is not the first time the ",(0,t.jsx)(n.code,{children:"onMouseDown()"})," method is called, the method\nsimply sets the ",(0,t.jsx)(n.code,{children:"selectionIndicator"})," shape's ",(0,t.jsx)(n.code,{children:"visible"})," property (inherited from\nthe DisplayObject class), as follows:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"this.selectionIndicator.visible = true;\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"hideSelected()"})," method hides the ",(0,t.jsx)(n.code,{children:"selectionIndicator"})," shape of the\npreviously selected object by setting its ",(0,t.jsx)(n.code,{children:"visible"})," property to ",(0,t.jsx)(n.code,{children:"false"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"onMouseDown()"})," event handler method also calls the ",(0,t.jsx)(n.code,{children:"startDrag()"})," method\n(inherited from the Sprite class), which includes the following code:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"var boundsRect:Rectangle = this.parent.getRect(this.parent);\nboundsRect.width -= this.size;\nboundsRect.height -= this.size;\nthis.startDrag(false, boundsRect);\n"})}),"\n",(0,t.jsxs)(n.p,{children:["This lets the user drag the selected object around the canvas, within the\nboundaries set by the ",(0,t.jsx)(n.code,{children:"boundsRect"})," rectangle."]}),"\n",(0,t.jsxs)(n.p,{children:["When the user releases the mouse button, the ",(0,t.jsx)(n.code,{children:"mouseUp"})," event is dispatched. The\nconstructor method of the DrawingCanvas sets up the following event listener:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"this.addEventListener(MouseEvent.MOUSE_UP, onMouseUp);\n"})}),"\n",(0,t.jsx)(n.p,{children:"This event listener is set for the DrawingCanvas object, rather than for the\nindividual GeometricSprite objects. This is because when the GeometricSprite\nobject is dragged, it could end up behind another display object (another\nGeometricSprite object) when the mouse is released. The display object in the\nforeground would receive the mouse up event but the display object the user is\ndragging would not. Adding the listener to the DrawingCanvas object ensures that\nthe event is always handled."}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"onMouseUp()"})," method calls the ",(0,t.jsx)(n.code,{children:"onMouseUp()"})," method of the GeometricSprite\nobject, which in turn calls the ",(0,t.jsx)(n.code,{children:"stopDrag()"})," method of the GeometricSprite\nobject."]}),"\n",(0,t.jsx)(n.h2,{id:"rearranging-display-object-layering",children:"Rearranging display object layering"}),"\n",(0,t.jsxs)(n.p,{children:["The user interface for the application includes buttons labeled Move Back, Move\nDown, Move Up, and Move to Front. When the user clicks one of these buttons, the\napplication calls the corresponding method of the DrawingCanvas class:\n",(0,t.jsx)(n.code,{children:"moveToBack()"}),", ",(0,t.jsx)(n.code,{children:"moveDown()"}),", ",(0,t.jsx)(n.code,{children:"moveUp()"}),", or ",(0,t.jsx)(n.code,{children:"moveToFront()"}),". For example, the\n",(0,t.jsx)(n.code,{children:"moveToBack()"})," method includes the following code:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"public function moveToBack(shape:GeometricSprite):void\n{\n    var index:int = this.getChildIndex(shape);\n    if (index > 0)\n    {\n        this.setChildIndex(shape, 0);\n    }\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The method uses the ",(0,t.jsx)(n.code,{children:"setChildIndex()"})," method (inherited from the\nDisplayObjectContainer class) to position the display object in index position 0\nin the child list of the DrawingCanvas instance (",(0,t.jsx)(n.code,{children:"this"}),")."]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"moveDown()"})," method works similarly, except that it decrements the index\nposition of the display object by 1 in the child list of the DrawingCanvas\ninstance:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"public function moveDown(shape:GeometricSprite):void\n{\n    var index:int = this.getChildIndex(shape);\n    if (index > 0)\n    {\n        this.setChildIndex(shape, index - 1);\n    }\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"moveUp()"})," and ",(0,t.jsx)(n.code,{children:"moveToFront()"})," methods work similarly to the ",(0,t.jsx)(n.code,{children:"moveToBack()"}),"\nand ",(0,t.jsx)(n.code,{children:"moveDown()"})," methods."]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(o,{...e})}):o(e)}}}]);