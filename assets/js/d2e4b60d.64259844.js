"use strict";(self.webpackChunkairsdk_dev=self.webpackChunkairsdk_dev||[]).push([[19602],{5760:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/eh_stage_parent_Node-03608d91740098707a5c787a81b48d72.png"},16225:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/eh_displaylistVhierarchy-a7f1bfb78c05ec36cd9102e084ab02f4.png"},28453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>r});var s=n(96540);const o={},a=s.createContext(o);function i(e){const t=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),s.createElement(a.Provider,{value:t},e.children)}},71516:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>h,contentTitle:()=>r,default:()=>l,frontMatter:()=>i,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"development/core-actionscript-classes/handling-events/the-event-flow","title":"The event flow","description":"Flash Player or AIR dispatches event objects whenever an event occurs. If the","source":"@site/docs/development/core-actionscript-classes/handling-events/the-event-flow.md","sourceDirName":"development/core-actionscript-classes/handling-events","slug":"/development/core-actionscript-classes/handling-events/the-event-flow","permalink":"/docs/development/core-actionscript-classes/handling-events/the-event-flow","draft":false,"unlisted":false,"editUrl":"https://github.com/airsdk/airsdk.dev/edit/main/docs/development/core-actionscript-classes/handling-events/the-event-flow.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"mainSidebar","previous":{"title":"How ActionScript 3.0 event handling differs from earlier versions","permalink":"/docs/development/core-actionscript-classes/handling-events/how-actionscript-3.0-event-handling-differs-from-earlier-versions"},"next":{"title":"Event objects","permalink":"/docs/development/core-actionscript-classes/handling-events/event-objects"}}');var o=n(74848),a=n(28453);const i={sidebar_position:3},r="The event flow",h={},c=[];function d(e){const t={code:"code",em:"em",h1:"h1",header:"header",img:"img",p:"p",...(0,a.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.header,{children:(0,o.jsx)(t.h1,{id:"the-event-flow",children:"The event flow"})}),"\n",(0,o.jsx)(t.p,{children:"Flash Player or AIR dispatches event objects whenever an event occurs. If the\nevent target is not on the display list, Flash Player or AIR dispatches the\nevent object directly to the event target. For example, Flash Player dispatches\nthe progress event object directly to a URLStream object. If the event target is\non the display list, however, Flash Player dispatches the event object into the\ndisplay list, and the event object travels through the display list to the event\ntarget."}),"\n",(0,o.jsxs)(t.p,{children:["The ",(0,o.jsx)(t.em,{children:"event flow"})," describes how an event object moves through the display list.\nThe display list is organized in a hierarchy that can be described as a tree. At\nthe top of the display list hierarchy is the Stage, which is a special display\nobject container that serves as the root of the display list. The Stage is\nrepresented by the flash.display.Stage class and can only be accessed through a\ndisplay object. Every display object has a property named ",(0,o.jsx)(t.code,{children:"stage"})," that refers to\nthe Stage for that application."]}),"\n",(0,o.jsxs)(t.p,{children:["When Flash Player or AIR dispatches an event object for a display list-related\nevent, that event object makes a round-trip journey from the Stage to the\n",(0,o.jsx)(t.em,{children:"target node"}),". The DOM Events Specification defines the target node as the node\nrepresenting the event target. In other words, the target node is the display\nlist object where the event occurred. For example, if a user clicks on a display\nlist object named ",(0,o.jsx)(t.code,{children:"child1"}),", Flash Player or AIR will dispatch an event object\nusing ",(0,o.jsx)(t.code,{children:"child1"})," as the target node."]}),"\n",(0,o.jsx)(t.p,{children:"The event flow is conceptually divided into three parts. The first part is\ncalled the capture phase; this phase comprises all of the nodes from the Stage\nto the parent of the target node. The second part is called the target phase,\nwhich consists solely of the target node. The third part is called the bubbling\nphase. The bubbling phase comprises the nodes encountered on the return trip\nfrom the parent of the target node back to the Stage."}),"\n",(0,o.jsx)(t.p,{children:"The names of the phases make more sense if you conceive of the display list as a\nvertical hierarchy with the Stage at the top, as shown in the following diagram:"}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.img,{src:n(16225).A+"",width:"318",height:"193"})}),"\n",(0,o.jsxs)(t.p,{children:["If a user clicks on ",(0,o.jsx)(t.code,{children:"Child1 Node"}),", Flash Player or AIR dispatches an event\nobject into the event flow. As the following image shows, the object's journey\nstarts at ",(0,o.jsx)(t.code,{children:"Stage"}),", moves down to ",(0,o.jsx)(t.code,{children:"Parent Node"}),", then moves to ",(0,o.jsx)(t.code,{children:"Child1 Node"}),', and\nthen "bubbles" back up to ',(0,o.jsx)(t.code,{children:"Stage"}),", moving through ",(0,o.jsx)(t.code,{children:"Parent Node"})," again on its\njourney back to ",(0,o.jsx)(t.code,{children:"Stage"}),"."]}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.img,{src:n(5760).A+"",width:"380",height:"238"})}),"\n",(0,o.jsxs)(t.p,{children:["In this example, the capture phase comprises ",(0,o.jsx)(t.code,{children:"Stage"})," and ",(0,o.jsx)(t.code,{children:"Parent Node"})," during\nthe initial downward journey. The target phase comprises the time spent at\n",(0,o.jsx)(t.code,{children:"Child1 Node"}),". The bubbling phase comprises ",(0,o.jsx)(t.code,{children:"Parent Node"})," and ",(0,o.jsx)(t.code,{children:"Stage"})," as they\nare encountered during the upward journey back to the root node."]}),"\n",(0,o.jsx)(t.p,{children:"The event flow contributes to a more powerful event-handling system than that\npreviously available to ActionScript programmers. In previous versions of\nActionScript, the event flow does not exist, which means that event listeners\ncan be added only to the object that generates the event. In ActionScript 3.0,\nyou can add event listeners not only to a target node, but also to any node\nalong the event flow."}),"\n",(0,o.jsx)(t.p,{children:"The ability to add event listeners along the event flow is useful when a user\ninterface component comprises more than one object. For example, a button object\noften contains a text object that serves as the button's label. Without the\nability to add a listener to the event flow, you would have to add a listener to\nboth the button object and the text object to ensure that you receive\nnotification about click events that occur anywhere on the button. The existence\nof the event flow, however, allows you to place a single event listener on the\nbutton object that handles click events that occur either on the text object or\non the areas of the button object that are not obscured by the text object."}),"\n",(0,o.jsxs)(t.p,{children:["Not every event object, however, participates in all three phases of the event\nflow. Some types of events, such as the ",(0,o.jsx)(t.code,{children:"enterFrame"})," and ",(0,o.jsx)(t.code,{children:"init"})," event types, are\ndispatched directly to the target node and participate in neither the capture\nphase nor the bubbling phase. Other events may target objects that are not on\nthe display list, such as events dispatched to an instance of the Socket class.\nThese event objects will also flow directly to the target object, without\nparticipating in the capture and bubbling phases."]}),"\n",(0,o.jsx)(t.p,{children:"To find out how a particular event type behaves, you can either check the API\ndocumentation or examine the event object's properties. Examining the event\nobject's properties is described in the following section."})]})}function l(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}}}]);