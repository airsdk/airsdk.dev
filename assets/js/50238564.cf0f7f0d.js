"use strict";(self.webpackChunkairsdk_dev=self.webpackChunkairsdk_dev||[]).push([[48358],{5629:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>h,contentTitle:()=>r,default:()=>l,frontMatter:()=>o,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"development/display/working-with-bitmaps/bitmap-example-animated-spinning-moon","title":"Bitmap example: Animated spinning moon","description":"The Animated spinning moon example demonstrates techniques for working with","source":"@site/docs/development/display/working-with-bitmaps/bitmap-example-animated-spinning-moon.md","sourceDirName":"development/display/working-with-bitmaps","slug":"/development/display/working-with-bitmaps/bitmap-example-animated-spinning-moon","permalink":"/docs/development/display/working-with-bitmaps/bitmap-example-animated-spinning-moon","draft":false,"unlisted":false,"editUrl":"https://github.com/airsdk/airsdk.dev/edit/main/docs/development/display/working-with-bitmaps/bitmap-example-animated-spinning-moon.md","tags":[],"version":"current","frontMatter":{},"sidebar":"mainSidebar","previous":{"title":"Basics of working with bitmaps","permalink":"/docs/development/display/working-with-bitmaps/basics-of-working-with-bitmaps"},"next":{"title":"Compressing bitmap data","permalink":"/docs/development/display/working-with-bitmaps/compressing-bitmap-data"}}');var a=n(74848),s=n(28453);const o={},r="Bitmap example: Animated spinning moon",h={},c=[{value:"Loading an external image as bitmap data",id:"loading-an-external-image-as-bitmap-data",level:2},{value:"Creating animation by copying pixels",id:"creating-animation-by-copying-pixels",level:2},{value:"Creating the spherical appearance",id:"creating-the-spherical-appearance",level:2},{value:"Creating a bitmap image by setting pixel values",id:"creating-a-bitmap-image-by-setting-pixel-values",level:2}];function d(e){const t={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"bitmap-example-animated-spinning-moon",children:"Bitmap example: Animated spinning moon"})}),"\n",(0,a.jsx)(t.p,{children:"The Animated spinning moon example demonstrates techniques for working with\nBitmap objects and bitmap image data (BitmapData objects). The example creates\nan animation of a spinning, spherical moon using a flat image of the moon's\nsurface as the raw image data. The following techniques are demonstrated:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:"Loading an external image and accessing its raw image data"}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:"Creating animation by repeatedly copying pixels from different parts of a\nsource image"}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:"Creating a bitmap image by setting pixel values"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:["To get the application files for this sample, see\n",(0,a.jsx)(t.a,{href:"https://github.com/joshtynjala/flash-platform-as3-dev-guide-examples/releases/tag/original",children:(0,a.jsx)(t.em,{children:"FlashPlatformAS3DevGuideExamples.zip"})}),".\nThe Animated spinning moon application files can be found in the\nSamples/SpinningMoon folder. The application consists of the following files:"]}),"\n",(0,a.jsxs)("table",{children:[(0,a.jsx)("thead",{children:(0,a.jsxs)("tr",{children:[(0,a.jsx)("th",{children:(0,a.jsx)("p",{children:"File"})}),(0,a.jsx)("th",{children:(0,a.jsx)("p",{children:"Description"})})]})}),(0,a.jsxs)("tbody",{children:[(0,a.jsxs)("tr",{children:[(0,a.jsxs)("td",{children:[(0,a.jsx)("p",{children:"SpinningMoon.mxml"}),(0,a.jsx)("p",{children:"or"}),(0,a.jsx)("p",{children:"SpinningMoon.fla"})]}),(0,a.jsx)("td",{children:(0,a.jsx)("p",{children:"The main\napplication file in Flex (MXML) or Flash (FLA)."})})]}),(0,a.jsxs)("tr",{children:[(0,a.jsx)("td",{children:(0,a.jsx)("p",{children:"com/example/programmingas3/moon/MoonSphere.as"})}),(0,a.jsx)("td",{children:(0,a.jsx)("p",{children:"Class that\nperforms the functionality of loading, displaying, and animating the\nmoon."})})]}),(0,a.jsxs)("tr",{children:[(0,a.jsx)("td",{children:(0,a.jsx)("p",{children:"moonMap.png"})}),(0,a.jsx)("td",{children:(0,a.jsx)("p",{children:"Image file\ncontaining a photograph of the moon's surface, which is loaded and used\nto create the animated, spinning moon."})})]})]})]}),"\n",(0,a.jsx)(t.h2,{id:"loading-an-external-image-as-bitmap-data",children:"Loading an external image as bitmap data"}),"\n",(0,a.jsxs)(t.p,{children:["The first main task this sample performs is loading an external image file,\nwhich is a photograph of the moon's surface. The loading operation is handled by\ntwo methods in the MoonSphere class: the ",(0,a.jsx)(t.code,{children:"MoonSphere()"})," constructor, where the\nloading process is initiated, and the ",(0,a.jsx)(t.code,{children:"imageLoadComplete()"})," method, which is\ncalled when the external image is completely loaded."]}),"\n",(0,a.jsxs)(t.p,{children:["Loading an external image is similar to loading an external SWF; both use an\ninstance of the flash.display.Loader class to perform the loading operation. The\nactual code in the ",(0,a.jsx)(t.code,{children:"MoonSphere()"})," method that starts loading the image is as\nfollows:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:'var imageLoader:Loader = new Loader();\nimageLoader.contentLoaderInfo.addEventListener(Event.COMPLETE, imageLoadComplete);\nimageLoader.load(new URLRequest("moonMap.png"));\n'})}),"\n",(0,a.jsxs)(t.p,{children:["The first line declares the Loader instance named ",(0,a.jsx)(t.code,{children:"imageLoader"}),". The third line\nactually starts the loading process by calling the Loader object's ",(0,a.jsx)(t.code,{children:"load()"}),"\nmethod, passing a URLRequest instance representing the URL of the image to load.\nThe second line sets up the event listener that will be triggered when the image\nhas completely loaded. Notice that the ",(0,a.jsx)(t.code,{children:"addEventListener()"})," method is not called\non the Loader instance itself; instead, it's called on the Loader object's\n",(0,a.jsx)(t.code,{children:"contentLoaderInfo"})," property. The Loader instance itself doesn't dispatch events\nrelating to the content being loaded. Its ",(0,a.jsx)(t.code,{children:"contentLoaderInfo"})," property, however,\ncontains a reference to the LoaderInfo object that's associated with the content\nbeing loaded into the Loader object (the external image in this case). That\nLoaderInfo object does provide several events relating to the progress and\ncompletion of loading the external content, including the ",(0,a.jsx)(t.code,{children:"complete"})," event\n(",(0,a.jsx)(t.code,{children:"Event.COMPLETE"}),") that will trigger a call to the ",(0,a.jsx)(t.code,{children:"imageLoadComplete()"})," method\nwhen the image has completely loaded."]}),"\n",(0,a.jsxs)(t.p,{children:["While starting the external image loading is an important part of the process,\nit's equally important to know what to do when it finishes loading. As shown in\nthe code above, the ",(0,a.jsx)(t.code,{children:"imageLoadComplete()"})," function is called when the image is\nloaded. That function does several things with the loaded image data, described\nsubsequently. However, to use the image data, it needs to access that data. When\na Loader object is used to load an external image, the loaded image becomes a\nBitmap instance, which is attached as a child display object of the Loader\nobject. In this case, the Loader instance is available to the event listener\nmethod as part of the event object that's passed to the method as a parameter.\nThe first lines of the ",(0,a.jsx)(t.code,{children:"imageLoadComplete()"})," method are as follows:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:"private function imageLoadComplete(event:Event):void\n{\n    textureMap = event.target.content.bitmapData;\n    ...\n}\n"})}),"\n",(0,a.jsxs)(t.p,{children:["Notice that the event object parameter is named ",(0,a.jsx)(t.code,{children:"event"}),", and it's an instance of\nthe Event class. Every instance of the Event class has a ",(0,a.jsx)(t.code,{children:"target"})," property,\nwhich refers to the object triggering the event (in this case, the LoaderInfo\ninstance on which the ",(0,a.jsx)(t.code,{children:"addEventListener()"})," method was called, as described\npreviously). The LoaderInfo object, in turn, has a ",(0,a.jsx)(t.code,{children:"content"})," property that (once\nthe loading process is complete) contains the Bitmap instance with the loaded\nbitmap image. If you want to display the image directly on the screen, you can\nattach this Bitmap instance (",(0,a.jsx)(t.code,{children:"event.target.content"}),") to a display object\ncontainer. (You could also attach the Loader object to a display object\ncontainer). However, in this sample, the loaded content is used as a source of\nraw image data rather than being displayed on the screen. Consequently, the\nfirst line of the ",(0,a.jsx)(t.code,{children:"imageLoadComplete()"})," method reads the ",(0,a.jsx)(t.code,{children:"bitmapData"})," property\nof the loaded Bitmap instance (",(0,a.jsx)(t.code,{children:"event.target.content.bitmapData"}),") and stores it\nin the instance variable named ",(0,a.jsx)(t.code,{children:"textureMap"}),", which is used as a source of the\nimage data to create the animation of the rotating moon. This is described next."]}),"\n",(0,a.jsx)(t.h2,{id:"creating-animation-by-copying-pixels",children:"Creating animation by copying pixels"}),"\n",(0,a.jsx)(t.p,{children:"A basic definition of animation is the illusion of motion, or change, created by\nchanging an image over time. In this sample, the goal is to create the illusion\nof a spherical moon rotating around its vertical axis. However, for the purposes\nof the animation, you can ignore the spherical distortion aspect of the sample.\nConsider the actual image that's loaded and used as the source of the moon image\ndata:"}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{src:n(19677).A+"",width:"790",height:"198"})}),"\n",(0,a.jsx)(t.p,{children:"As you can see, the image is not one or several spheres; it's a rectangular\nphotograph of the surface of the moon. Because the photo was taken exactly at\nthe moon's equator, the parts of the image that are closer to the top and bottom\nof the image are stretched and distorted. To remove the distortion from the\nimage and make it appear spherical, we will use a displacement map filter, as\ndescribed later. However, because this source image is a rectangle, to create\nthe illusion that the sphere is rotating, the code simply needs to slide the\nmoon surface photo horizontally."}),"\n",(0,a.jsx)(t.p,{children:"Notice that the image actually contains two copies of the moon surface\nphotograph next to each other. This image is the source image from which image\ndata is copied repeatedly to create the appearance of motion. By having two\ncopies of the image next to each other, a continuous, uninterrupted scrolling\neffect can more easily be created. Let's walk through the process of the\nanimation step-by-step to see how this works."}),"\n",(0,a.jsxs)(t.p,{children:["The process actually involves two separate ActionScript objects. First, there is\nthe loaded source image, which in the code is represented by the BitmapData\ninstance named ",(0,a.jsx)(t.code,{children:"textureMap"}),". As described previously, ",(0,a.jsx)(t.code,{children:"textureMap"})," is populated\nwith image data as soon as the external image loads, using this code:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:"textureMap = event.target.content.bitmapData;\n"})}),"\n",(0,a.jsxs)(t.p,{children:["The content of ",(0,a.jsx)(t.code,{children:"textureMap"})," is the rectangle moon image. In addition, to create\nthe animated rotation, the code uses a Bitmap instance named ",(0,a.jsx)(t.code,{children:"sphere"}),", which is\nthe actual display object that shows the moon image onscreen. Like ",(0,a.jsx)(t.code,{children:"textureMap"}),",\nthe ",(0,a.jsx)(t.code,{children:"sphere"})," object is created and populated with its initial image data in the\n",(0,a.jsx)(t.code,{children:"imageLoadComplete()"})," method, using the following code:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:"sphere = new Bitmap();\nsphere.bitmapData = new BitmapData(textureMap.width / 2, textureMap.height);\nsphere.bitmapData.copyPixels(textureMap,\n                            new Rectangle(0, 0, sphere.width, sphere.height),\n                            new Point(0, 0));\n"})}),"\n",(0,a.jsxs)(t.p,{children:["As the code shows, ",(0,a.jsx)(t.code,{children:"sphere"})," is instantiated. Its ",(0,a.jsx)(t.code,{children:"bitmapData"})," property (the raw\nimage data that is displayed by ",(0,a.jsx)(t.code,{children:"sphere"}),") is created with the same height and\nhalf the width of ",(0,a.jsx)(t.code,{children:"textureMap"}),". In other words, the content of ",(0,a.jsx)(t.code,{children:"sphere"})," will be\nthe size of one moon photo (since the ",(0,a.jsx)(t.code,{children:"textureMap"})," image contains two moon\nphotos side-by-side). Next the ",(0,a.jsx)(t.code,{children:"bitmapData"})," property is filled with image data\nusing its ",(0,a.jsx)(t.code,{children:"copyPixels()"})," method. The parameters in the ",(0,a.jsx)(t.code,{children:"copyPixels()"})," method\ncall indicate several things:"]}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:["The first parameter indicates that the image data is copied from ",(0,a.jsx)(t.code,{children:"textureMap"}),"."]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:["The second parameter, a new Rectangle instance, specifies from which part of\n",(0,a.jsx)(t.code,{children:"textureMap"})," the image snapshot should be taken; in this case the snapshot is\na rectangle starting from the top left corner of ",(0,a.jsx)(t.code,{children:"textureMap"})," (indicated by\nthe first two ",(0,a.jsx)(t.code,{children:"Rectangle()"})," parameters: ",(0,a.jsx)(t.code,{children:"0, 0"}),") and the rectangle snapshot's\nwidth and height match the ",(0,a.jsx)(t.code,{children:"width"})," and ",(0,a.jsx)(t.code,{children:"height"})," properties of ",(0,a.jsx)(t.code,{children:"sphere"}),"."]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:["The third parameter, a new Point instance with x and y values of ",(0,a.jsx)(t.code,{children:"0"}),", defines\nthe destination of the pixel data\u2014in this case, the top-left corner (0, 0) of\n",(0,a.jsx)(t.code,{children:"sphere.bitmapData"}),"."]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:["Represented visually, the code copies the pixels from ",(0,a.jsx)(t.code,{children:"textureMap"})," outlined in\nthe following image and pastes them onto ",(0,a.jsx)(t.code,{children:"sphere"}),". In other words, the\nBitmapData content of ",(0,a.jsx)(t.code,{children:"sphere"})," is the portion of ",(0,a.jsx)(t.code,{children:"textureMap"})," highlighted here:"]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{src:n(26350).A+"",width:"790",height:"198"})}),"\n",(0,a.jsxs)(t.p,{children:["Remember, however, that this is just the initial state of ",(0,a.jsx)(t.code,{children:"sphere"})," \u2014the first\nimage content that's copied onto ",(0,a.jsx)(t.code,{children:"sphere"}),"."]}),"\n",(0,a.jsxs)(t.p,{children:["With the source image loaded and ",(0,a.jsx)(t.code,{children:"sphere"})," created, the final task performed by\nthe ",(0,a.jsx)(t.code,{children:"imageLoadComplete()"})," method is to set up the animation. The animation is\ndriven by a Timer instance named ",(0,a.jsx)(t.code,{children:"rotationTimer"}),", which is created and started\nby the following code:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:"var rotationTimer:Timer = new Timer(15);\nrotationTimer.addEventListener(TimerEvent.TIMER, rotateMoon);\nrotationTimer.start();\n"})}),"\n",(0,a.jsxs)(t.p,{children:["The code first creates the Timer instance named ",(0,a.jsx)(t.code,{children:"rotationTimer"})," ; the parameter\npassed to the ",(0,a.jsx)(t.code,{children:"Timer()"})," constructor indicates that ",(0,a.jsx)(t.code,{children:"rotationTimer"})," should\ntrigger its ",(0,a.jsx)(t.code,{children:"timer"})," event every 15 milliseconds. Next, the ",(0,a.jsx)(t.code,{children:"addEventListener()"}),"\nmethod is called, specifying that when the ",(0,a.jsx)(t.code,{children:"timer"})," event (",(0,a.jsx)(t.code,{children:"TimerEvent.TIMER"}),")\noccurs, the method ",(0,a.jsx)(t.code,{children:"rotateMoon()"})," is called. Finally, the timer is actually\nstarted by calling its ",(0,a.jsx)(t.code,{children:"start()"})," method."]}),"\n",(0,a.jsxs)(t.p,{children:["Because of the way ",(0,a.jsx)(t.code,{children:"rotationTimer"})," is defined, approximately every 15\nmilliseconds Flash Player calls the ",(0,a.jsx)(t.code,{children:"rotateMoon()"})," method in the MoonSphere\nclass, which is where the animation of the moon happens. The source code of the\n",(0,a.jsx)(t.code,{children:"rotateMoon()"})," method is as follows:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:"private function rotateMoon(event:TimerEvent):void\n{\n    sourceX += 1;\n    if (sourceX > textureMap.width / 2)\n    {\n        sourceX = 0;\n    }\n\n    sphere.Data.copyPixels(textureMap,\n                            new Rectangle(sourceX, 0, sphere.width, sphere.height),\n                            new Point(0, 0));\n\n    event.updateAfterEvent();\n}\n"})}),"\n",(0,a.jsx)(t.p,{children:"The code does three things:"}),"\n",(0,a.jsxs)(t.ol,{children:["\n",(0,a.jsxs)(t.li,{children:["The value of the variable ",(0,a.jsx)(t.code,{children:"sourceX"})," (initially set to 0) increments by 1."]}),"\n"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:"    sourceX += 1;\n"})}),"\n",(0,a.jsxs)(t.p,{children:["As you'll see, ",(0,a.jsx)(t.code,{children:"sourceX"})," is used to determine the location in ",(0,a.jsx)(t.code,{children:"textureMap"}),"\nfrom which the pixels will be copied onto ",(0,a.jsx)(t.code,{children:"sphere"})," so this code has the\neffect of moving the rectangle one pixel to the right on ",(0,a.jsx)(t.code,{children:"textureMap"}),". Going\nback to the visual representation, after several cycles of animation the\nsource rectangle will have moved several pixels to the right, like this:"]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{src:n(65243).A+"",width:"790",height:"198"})}),"\n",(0,a.jsx)(t.p,{children:"After several more cycles, the rectangle will have moved even farther:"}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{src:n(52652).A+"",width:"790",height:"198"})}),"\n",(0,a.jsxs)(t.p,{children:["This gradual, steady shift in the location from which the pixels are copied\nis the key to the animation. By slowly and continuously moving the source\nlocation to the right, the image that is displayed on the screen in ",(0,a.jsx)(t.code,{children:"sphere"}),"\nappears to continuously slide to the left. This is the reason why the source\nimage (",(0,a.jsx)(t.code,{children:"textureMap"}),") needs to have two copies of the moon surface photo.\nBecause the rectangle is continually moving to the right, most of the time\nit is not over one single moon photo but rather overlaps the two moon\nphotos."]}),"\n",(0,a.jsxs)(t.ol,{start:"2",children:["\n",(0,a.jsxs)(t.li,{children:["With the source rectangle slowly moving to the right, there is one problem.\nEventually the rectangle will reach the right edge of ",(0,a.jsx)(t.code,{children:"textureMap"})," and it\nwill run out of moon photo pixels to copy onto ",(0,a.jsx)(t.code,{children:"sphere"}),":"]}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{src:n(92129).A+"",width:"790",height:"198"})}),"\n",(0,a.jsx)(t.p,{children:"The next lines of code address this issue:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:"if (sourceX >= textureMap.width / 2)\n{\n    sourceX = 0;\n}\n"})}),"\n",(0,a.jsxs)(t.p,{children:["The code checks if ",(0,a.jsx)(t.code,{children:"sourceX"})," (the left edge of the rectangle) has reached\nthe middle of ",(0,a.jsx)(t.code,{children:"textureMap"}),". If so, it resets ",(0,a.jsx)(t.code,{children:"sourceX"})," back to 0, moving it\nback to the left edge of ",(0,a.jsx)(t.code,{children:"textureMap"})," and starting the cycle over again:"]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{src:n(17299).A+"",width:"790",height:"198"})}),"\n",(0,a.jsxs)(t.ol,{start:"3",children:["\n",(0,a.jsxs)(t.li,{children:["With the appropriate ",(0,a.jsx)(t.code,{children:"sourceX"})," value calculated, the final step in creating\nthe animation is to actually copy the new source rectangle pixels onto\n",(0,a.jsx)(t.code,{children:"sphere"}),". The code that does this is very similar to the code that initially\npopulated ",(0,a.jsx)(t.code,{children:"sphere"})," (described previously); the only difference is that in\nthis case, in the ",(0,a.jsx)(t.code,{children:"new Rectangle()"})," constructor call, the left edge of the\nrectangle is placed at ",(0,a.jsx)(t.code,{children:"sourceX"}),":"]}),"\n"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:"sphere.bitmapData.copyPixels(textureMap,\n                        new Rectangle(sourceX, 0, sphere.width, sphere.height),\n                        new Point(0, 0));\n"})}),"\n",(0,a.jsxs)(t.p,{children:["Remember that this code is called repeatedly, every 15 milliseconds. As the\nsource rectangle's location is continuously shifted, and the pixels are copied\nonto ",(0,a.jsx)(t.code,{children:"sphere"}),", the appearance on the screen is that the moon photo image\nrepresented by ",(0,a.jsx)(t.code,{children:"sphere"})," continuously slides. In other words, the moon appears to\nrotate continuously."]}),"\n",(0,a.jsx)(t.h2,{id:"creating-the-spherical-appearance",children:"Creating the spherical appearance"}),"\n",(0,a.jsx)(t.p,{children:"The moon, of course, is a sphere and not a rectangle. Consequently, the sample\nneeds to take the rectangular moon surface photo, as it continuously animates,\nand convert it into a sphere. This involves two separate steps: a mask is used\nto hide all the content except for a circular region of the moon surface photo,\nand a displacement map filter is used to distort the appearance of the moon\nphoto to make it look three-dimensional."}),"\n",(0,a.jsx)(t.p,{children:"First, a circle-shaped mask is used to hide all the content of the MoonSphere\nobject except for the sphere created by the filter. The following code creates\nthe mask as a Shape instance and applies it as the mask of the MoonSphere\ninstance:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:"moonMask = new Shape();\nmoonMask.graphics.beginFill(0);\nmoonMask.graphics.drawCircle(0, 0, radius);\nthis.addChild(moonMask);\nthis.mask = moonMask;\n"})}),"\n",(0,a.jsxs)(t.p,{children:["Note that since MoonSphere is a display object (it is based on the Sprite\nclass), the mask can be applied directly to the MoonSphere instance using its\ninherited ",(0,a.jsx)(t.code,{children:"mask"})," property."]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{src:n(38106).A+"",width:"216",height:"216"})}),"\n",(0,a.jsx)(t.p,{children:"Simply hiding parts of the photo using a circle-shaped mask isn't enough to\ncreate a realistic-looking rotating-sphere effect. Because of the way the photo\nof the moon's surface was taken, its dimensions aren't proportional; the\nportions of the image that are more toward the top or bottom of the image are\nmore distorted and stretched compared to the portions in the equator. To distort\nthe appearance of the moon photo to make it look three-dimensional, we'll use a\ndisplacement map filter."}),"\n",(0,a.jsx)(t.p,{children:'A displacement map filter is a type of filter that is used to distort an image.\nIn this case, the moon photo will be "distorted" to make it look more realistic,\nby squeezing the top and bottom of the image horizontally, while leaving the\nmiddle unchanged. Assuming the filter operates on a square-shaped portion of the\nphoto, squeezing the top and bottom but not the middle will turn the square into\na circle. A side effect of animating this distorted image is that the middle of\nthe image seems to move farther in actual pixel distance than the areas close to\nthe top and bottom, which creates the illusion that the circle is actually a\nthree-dimensional object (a sphere).'}),"\n",(0,a.jsxs)(t.p,{children:["The following code is used to create the displacement map filter, named\n",(0,a.jsx)(t.code,{children:"displaceFilter"}),":"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:"var displaceFilter:DisplacementMapFilter;\ndisplaceFilter = new DisplacementMapFilter(fisheyeLens,\n                                new Point(radius, 0),\n                                BitmapDataChannel.RED,\n                                BitmapDataChannel.GREEN,\n                                radius, 0);\n"})}),"\n",(0,a.jsxs)(t.p,{children:["The first parameter, ",(0,a.jsx)(t.code,{children:"fisheyeLens"}),", is known as the map image; in this case it\nis a BitmapData object that is created programmatically. The creation of that\nimage is described in\n",(0,a.jsx)(t.a,{href:"/docs/development/display/working-with-bitmaps/bitmap-example-animated-spinning-moon#creating-a-bitmap-image-by-setting-pixel-values",children:"Creating a bitmap image by setting pixel values"}),".\nThe other parameters describe the position in the filtered image at which the\nfilter should be applied, which color channels will be used to control the\ndisplacement effect, and to what extent they will affect the displacement. Once\nthe displacement map filter is created, it is applied to ",(0,a.jsx)(t.code,{children:"sphere"}),", still within\nthe ",(0,a.jsx)(t.code,{children:"imageLoadComplete()"})," method:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:"sphere.filters = [displaceFilter];\n"})}),"\n",(0,a.jsx)(t.p,{children:"The final image, with mask and displacement map filter applied, looks like this:"}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{src:n(49062).A+"",width:"216",height:"216"})}),"\n",(0,a.jsx)(t.p,{children:"With every cycle of the rotating moon animation, the BitmapData content of\nsphere is overwritten by a new snapshot of the source image data. However, the\nfilter does not need to be re-applied each time. This is because the filter is\napplied to the Bitmap instance (the display object) rather than to the bitmap\ndata (the raw pixel information). Remember, the Bitmap instance is not the\nactual bitmap data; it is a display object that displays the bitmap data on the\nscreen. To use an analogy, a Bitmap instance is like the slide projector that is\nused to display photographic slides on a screen, and a BitmapData object is like\nthe actual photographic slide that can be presented through a slide projector. A\nfilter can be applied directly to a BitmapData object, which would be comparable\nto drawing directly onto a photographic slide to alter the image. A filter can\nalso be applied to any display object, including a Bitmap instance; this would\nbe like placing a filter in front of the slide projector's lens to distort the\noutput shown on the screen (without altering the original slide at all). Because\nthe raw bitmap data is accessible through a Bitmap instance's bitmapData\nproperty, the filter could have been applied directly to the raw bitmap data.\nHowever, in this case, it makes sense to apply the filter to the Bitmap display\nobject rather than to the bitmap data."}),"\n",(0,a.jsxs)(t.p,{children:["For detailed information about using the displacement map filter in\nActionScript, see\n",(0,a.jsx)(t.a,{href:"/docs/development/display/filtering-display-objects/",children:"Filtering display objects"}),"."]}),"\n",(0,a.jsx)(t.h2,{id:"creating-a-bitmap-image-by-setting-pixel-values",children:"Creating a bitmap image by setting pixel values"}),"\n",(0,a.jsxs)(t.p,{children:["One important aspect of a displacement map filter is that it actually involves\ntwo images. One image, the source image, is the image that is actually altered\nby the filter. In this sample, the source image is the Bitmap instance named\n",(0,a.jsx)(t.code,{children:"sphere"}),". The other image used by the filter is known as the map image. The map\nimage is not actually displayed on the screen. Instead, the color of each of its\npixels is used as an input to the displacement function\u2014the color of the pixel\nat a certain x, y coordinate in the map image determines how much displacement\n(physical shift in position) is applied to the pixel at that x, y coordinate in\nthe source image."]}),"\n",(0,a.jsx)(t.p,{children:"Consequently, to use the displacement map filter to create a sphere effect, the\nsample needs the appropriate map image\u2014one that has a gray background and a\ncircle that's filled with a gradient of a single color (red) going horizontally\nfrom dark to light, as shown here:"}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{src:n(18327).A+"",width:"200",height:"200"})}),"\n",(0,a.jsxs)(t.p,{children:["Because only one map image and filter are used in this sample, the map image is\nonly created once, in the ",(0,a.jsx)(t.code,{children:"imageLoadComplete()"})," method (in other words, when the\nexternal image finishes loading). The map image, named ",(0,a.jsx)(t.code,{children:"fisheyeLens"}),", is created\nby calling the MoonSphere class's ",(0,a.jsx)(t.code,{children:"createFisheyeMap()"})," method:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:"var fisheyeLens:BitmapData = createFisheyeMap(radius);\n"})}),"\n",(0,a.jsxs)(t.p,{children:["Inside the ",(0,a.jsx)(t.code,{children:"createFisheyeMap()"})," method, the map image is actually drawn one\npixel at a time using the BitmapData class's ",(0,a.jsx)(t.code,{children:"setPixel()"})," method. The complete\ncode for the ",(0,a.jsx)(t.code,{children:"createFisheyeMap()"})," method is listed here, followed by a\nstep-by-step discussion of how it works:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:"private function createFisheyeMap(radius:int):BitmapData\n{\n    var diameter:int = 2 * radius;\n\n    var result:BitmapData = new BitmapData(diameter,\n                                        diameter,\n                                        false,\n                                        0x808080);\n\n    // Loop through the pixels in the image one by one\n    for (var i:int = 0; i < diameter; i++)\n    {\n        for (var j:int = 0; j < diameter; j++)\n        {\n            // Calculate the x and y distances of this pixel from\n            // the center of the circle (as a percentage of the radius).\n            var pctX:Number = (i - radius) / radius;\n            var pctY:Number = (j - radius) / radius;\n\n            // Calculate the linear distance of this pixel from\n            // the center of the circle (as a percentage of the radius).\n            var pctDistance:Number = Math.sqrt(pctX * pctX + pctY * pctY);\n\n            // If the current pixel is inside the circle,\n            // set its color.\n            if (pctDistance < 1)\n            {\n                // Calculate the appropriate color depending on the\n                // distance of this pixel from the center of the circle.\n                var red:int;\n                var green:int;\n                var blue:int;\n                var rgb:uint;\n                red = 128 * (1 + 0.75 * pctX * pctX * pctX / (1 - pctY * pctY));\n                green = 0;\n                blue = 0;\n                rgb = (red << 16 | green << 8 | blue);\n                // Set the pixel to the calculated color.\n                result.setPixel(i, j, rgb);\n            }\n        }\n    }\n    return result;\n}\n"})}),"\n",(0,a.jsxs)(t.p,{children:["First, when the method is called it receives a parameter, ",(0,a.jsx)(t.code,{children:"radius"}),", indicating\nthe radius of the circle-shaped image to create. Next, the code creates the\nBitmapData object on which the circle will be drawn. That object, named\n",(0,a.jsx)(t.code,{children:"result"}),", is eventually passed back as the return value of the method. As shown\nin the following code snippet, the ",(0,a.jsx)(t.code,{children:"result"})," BitmapData instance is created with\na width and height as big as the diameter of the circle, without transparency\n(",(0,a.jsx)(t.code,{children:"false"})," for the third parameter), and pre-filled with the color ",(0,a.jsx)(t.code,{children:"0x808080"}),"\n(middle gray):"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:"var result:BitmapData = new BitmapData(diameter,\n                                    diameter,\n                                    false,\n                                    0x808080);\n"})}),"\n",(0,a.jsxs)(t.p,{children:["Next, the code uses two loops to iterate over each pixel of the image. The outer\nloop goes through each column of the image from left to right (using the\nvariable ",(0,a.jsx)(t.code,{children:"i"})," to represent the horizontal position of the pixel currently being\nmanipulated), while the inner loop goes through each pixel of the current column\nfrom top to bottom (with the variable ",(0,a.jsx)(t.code,{children:"j"})," representing the vertical position of\nthe current pixel). The code for the loops (with the inner loop's contents\nomitted) is shown here:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:"for (var i:int = 0; i < diameter; i++)\n{\n    for (var j:int = 0; j < diameter; j++)\n    {\n        ...\n    }\n}\n"})}),"\n",(0,a.jsx)(t.p,{children:"As the loops cycle through the pixels one by one, at each pixel a value (the\ncolor value of that pixel in the map image) is calculated. This process involves\nfour steps:"}),"\n",(0,a.jsxs)(t.ol,{children:["\n",(0,a.jsxs)(t.li,{children:["The code calculates the distance of the current pixel from the center of the\ncircle along the x axis (",(0,a.jsx)(t.code,{children:"i - radius"}),"). That value is divided by the radius\nto make it a percentage of the radius rather than an absolute distance\n(",(0,a.jsx)(t.code,{children:"(i - radius) / radius"}),"). That percentage value is stored in a variable\nnamed ",(0,a.jsx)(t.code,{children:"pctX"}),", and the equivalent value for the y axis is calculated and\nstored in the variable ",(0,a.jsx)(t.code,{children:"pctY"}),", as shown in this code:"]}),"\n"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:"var pctX:Number = (i - radius) / radius;\nvar pctY:Number = (j - radius) / radius;\n"})}),"\n",(0,a.jsxs)(t.ol,{start:"2",children:["\n",(0,a.jsxs)(t.li,{children:["Using a standard trigonometric formula, the Pythagorean theorem, the linear\ndistance between the center of the circle and the current point is\ncalculated from ",(0,a.jsx)(t.code,{children:"pctX"})," and ",(0,a.jsx)(t.code,{children:"pctY"}),". That value is stored in a variable named\n",(0,a.jsx)(t.code,{children:"pctDistance"}),", as shown here:"]}),"\n"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:"var pctDistance:Number = Math.sqrt(pctX * pctX + pctY * pctY);\n"})}),"\n",(0,a.jsxs)(t.ol,{start:"3",children:["\n",(0,a.jsx)(t.li,{children:"Next, the code checks whether the distance percentage is less than 1\n(meaning 100% of the radius, or in other words, if the pixel being\nconsidered is within the radius of the circle). If the pixel falls inside\nthe circle, it is assigned a calculated color value (omitted here, but\ndescribed in step 4); if not, nothing further happens with that pixel so its\ncolor is left as the default middle gray:"}),"\n"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:"if (pctDistance < 1)\n{\n    ...\n}\n"})}),"\n",(0,a.jsxs)(t.ol,{start:"4",children:["\n",(0,a.jsx)(t.li,{children:"For those pixels that fall inside the circle, a color value is calculated\nfor the pixel. The final color will be a shade of red ranging from black (0%\nred) at the left edge of the circle to bright (100%) red at the right edge\nof the circle. The color value is initially calculated in three parts (red,\ngreen, and blue), as shown here:"}),"\n"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:"red = 128 * (1 + 0.75 * pctX * pctX * pctX / (1 - pctY * pctY));\ngreen = 0;\nblue = 0;\n"})}),"\n",(0,a.jsxs)(t.p,{children:["Notice that only the red portion of the color (the variable ",(0,a.jsx)(t.code,{children:"red"}),") actually\nhas a value. The green and blue values (the variables ",(0,a.jsx)(t.code,{children:"green"})," and ",(0,a.jsx)(t.code,{children:"blue"}),")\nare shown here for clarity, but could be omitted. Since the purpose of this\nmethod is to create a circle that contains a red gradient, no green or blue\nvalues are needed."]}),"\n",(0,a.jsx)(t.p,{children:"Once the three individual color values are determined, they are combined\ninto a single integer color value using a standard bit-shifting algorithm,\nshown in this code:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:"rgb = (red << 16 | green << 8 | blue);\n"})}),"\n",(0,a.jsxs)(t.p,{children:["Finally, with the color value calculated, that value is actually assigned to\nthe current pixel using the ",(0,a.jsx)(t.code,{children:"setPixel()"})," method of the ",(0,a.jsx)(t.code,{children:"result"})," BitmapData\nobject, shown here:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:"result.setPixel(i, j, rgb);\n"})})]})}function l(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},17299:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/bt_moon_example_map_2_0_popup-bfd40899b81bab7955f60b375dd58006.png"},18327:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/bt_moon_displacement_map_image-d33ecabe392a0c1b1f43fdcde214a91b.png"},19677:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/bt_moon_example_map_1_popup-9494b1bccf37ad7a9818bffe542813ad.png"},26350:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/bt_moon_example_map_2_popup-bfd40899b81bab7955f60b375dd58006.png"},28453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>r});var i=n(96540);const a={},s=i.createContext(a);function o(e){const t=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),i.createElement(s.Provider,{value:t},e.children)}},38106:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/bt_moon_masked_but_not_filtered-f2e6d4f0920baddcb74586ec74cd4b96.png"},49062:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/bt_moon_masked_and_filtered-309acc2c2feb7d72ff180a5ce311b5e4.png"},52652:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/bt_moon_example_map_4_popup-09509778651078a7a9886058063fc819.png"},65243:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/bt_moon_example_map_3_popup-0c3504a85ca0191dba2e1eb3f9fe9959.png"},92129:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/bt_moon_example_map_5_popup-a5239b1085c903f377b8f8116d7befbb.png"}}]);