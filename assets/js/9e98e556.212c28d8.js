"use strict";(self.webpackChunkairsdk_dev=self.webpackChunkairsdk_dev||[]).push([[68193],{28453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>o});var r=n(96540);const i={},a=r.createContext(i);function s(e){const t=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),r.createElement(a.Provider,{value:t},e.children)}},45940:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"development/networking-and-communication/xml-signature-validation-in-air/implementing-the-iuridereferencer-interface","title":"Implementing the IURIDereferencer interface","description":"To validate an XML signature, you must provide an implementation of the","source":"@site/docs/development/networking-and-communication/xml-signature-validation-in-air/implementing-the-iuridereferencer-interface.md","sourceDirName":"development/networking-and-communication/xml-signature-validation-in-air","slug":"/development/networking-and-communication/xml-signature-validation-in-air/implementing-the-iuridereferencer-interface","permalink":"/docs/development/networking-and-communication/xml-signature-validation-in-air/implementing-the-iuridereferencer-interface","draft":false,"unlisted":false,"editUrl":"https://github.com/airsdk/airsdk.dev/edit/main/docs/development/networking-and-communication/xml-signature-validation-in-air/implementing-the-iuridereferencer-interface.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"mainSidebar","previous":{"title":"About XML signatures","permalink":"/docs/development/networking-and-communication/xml-signature-validation-in-air/about-xml-signatures"},"next":{"title":"Client system interaction","permalink":"/docs/development/client-system-interaction/"}}');var i=n(74848),a=n(28453);const s={sidebar_position:3},o="Implementing the IURIDereferencer interface",l={},c=[{value:"Dereferencing URIs in enveloped signatures",id:"dereferencing-uris-in-enveloped-signatures",level:2},{value:"Dereferencing URIs in enveloping and detached signatures",id:"dereferencing-uris-in-enveloping-and-detached-signatures",level:2},{value:"Computing digest values for external resources",id:"computing-digest-values-for-external-resources",level:3},{value:"Dereferencing URIs in detached signatures referencing external data",id:"dereferencing-uris-in-detached-signatures-referencing-external-data",level:2}];function d(e){const t={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"implementing-the-iuridereferencer-interface",children:"Implementing the IURIDereferencer interface"})}),"\n",(0,i.jsx)(t.p,{children:"To validate an XML signature, you must provide an implementation of the\nIURIDereferencer interface. The implementation is responsible for resolving the\nURIs within the Reference elements of an XML signature document and returning\nthe data so that the digest can be computed. The computed digest is compared\nwith the digest in the signature to determine if the referenced data has been\naltered since the signature was created."}),"\n",(0,i.jsx)(t.p,{children:"Note: HTML-based AIR applications must import a SWF library containing an\nActionScript implementation in order to validate XML signatures. The\nIURIDereferencer interface cannot be implemented in JavaScript."}),"\n",(0,i.jsxs)(t.p,{children:["The IURIDerefencer interface has a single method, ",(0,i.jsx)(t.code,{children:"dereference(uri:String)"}),",\nthat must be implemented. The XMLSignatureValidator object calls this method for\neach reference in the signature. The method must return the data in a ByteArray\nobject."]}),"\n",(0,i.jsxs)(t.p,{children:["In most cases, you will also need to add properties or methods that allow your\ndereferencer object to locate the referenced data. For example, if the signed\ndata is located in the same document as the signature, you could add a member\nvariable that provides a reference to the XML document. The ",(0,i.jsx)(t.code,{children:"dereference()"}),"\nmethod can then use this variable, along with the URI, to locate the referenced\ndata. Likewise, if the signed data is located in a directory of the local file\nsystem, the ",(0,i.jsx)(t.code,{children:"dereference()"})," method might need a property providing the path to\nthat directory in order to resolve the referenced files."]}),"\n",(0,i.jsx)(t.p,{children:"The XMLSignatureValidator relies entirely on the dereferencer for interpreting\nURI strings. The standard rules for dereferencing URIs are given in the section\n4.3.3 of the W3C Recommendation for XML Signature Syntax and Processing."}),"\n",(0,i.jsx)(t.h2,{id:"dereferencing-uris-in-enveloped-signatures",children:"Dereferencing URIs in enveloped signatures"}),"\n",(0,i.jsx)(t.p,{children:"When an enveloped XML signature is generated, the signature elements are\ninserted into the signed data. For example, if you signed the following message\nusing an enveloped signature structure:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"<message>\n\t<data>...</data>\n</message>\n"})}),"\n",(0,i.jsx)(t.p,{children:"The resulting signed document will look like this:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:'<message>\n\t<data>...</data>\n\t<Signature xmlns="http://www.w3.org/2000/09/xmldsig#">\n\t\t<SignedInfo>\n\t\t\t<CanonicalizationMethod Algorithm="http://www.w3.org/TR/2001/REC-xml-c14n-20010315"/>\n\t\t\t<SignatureMethod Algorithm="http://www.w3.org/2000/09/xmldsig#rsa-sha1"/>\n\t\t\t<Reference URI="">\n\t\t\t\t<Transforms>\n\t\t\t\t\t<Transform Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature"/>\n\t\t\t\t</Transforms>\n\t\t\t\t<DigestMethod Algorithm="http://www.w3.org/2001/04/xmlenc#sha256"/>\n\t\t\t\t<DigestValue>yv6...Z0Y=</DigestValue>\n\t\t\t</Reference>\n\t\t</SignedInfo>\n\t\t<SignatureValue>cCY...LQ==</SignatureValue>\n\t\t<KeyInfo>\n\t\t\t<X509Data>\n\t\t\t\t<X509Certificate>MII...4e</X509Certificate>\n\t\t\t</X509Data>\n\t\t</KeyInfo>\n\t</Signature>\n</message>\n'})}),"\n",(0,i.jsx)(t.p,{children:"Notice that the signature contains a single Reference element with an empty\nstring as its URI. An empty string in this context refers to the root of the\ndocument."}),"\n",(0,i.jsx)(t.p,{children:"Also notice that the transform algorithm specifies that an enveloped signature\ntransform has been applied. When an enveloped signature transform has been\napplied, the XMLSignatureValidator automatically removes the signature from the\ndocument before computing the digest. This means that the dereferencer does not\nneed to remove the Signature element when returning the data."}),"\n",(0,i.jsx)(t.p,{children:"The following example illustrates a dereferencer for enveloped signatures:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:'package\n{\n\timport flash.events.ErrorEvent;\n\timport flash.events.EventDispatcher;\n\timport flash.security.IURIDereferencer;\n\timport flash.utils.ByteArray;\n\timport flash.utils.IDataInput;\n\n\tpublic class EnvelopedDereferencer\n\t\textends EventDispatcher implements IURIDereferencer\n\t{\n\t\tprivate var signedMessage:XML;\n\n\t\tpublic function EnvelopedDereferencer( signedMessage:XML )\n\t\t{\n\t\t\tthis.signedMessage = signedMessage;\n\t\t}\n\n\t\tpublic function dereference( uri:String ):IDataInput\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tif( uri.length != 0 )\n\t\t\t\t{\n\t\t\t\t\tthrow( new Error("Unsupported signature type.") );\n\t\t\t\t}\n\t\t\t\tvar data:ByteArray = new ByteArray();\n\t\t\t\tdata.writeUTFBytes( signedMessage.toXMLString() );\n\t\t\t\tdata.position = 0;\n\t\t\t}\n\t\t\tcatch (e:Error)\n\t\t\t\t{\n\t\t\t\tvar error:ErrorEvent =\n\t\t\t\t\tnew ErrorEvent("Ref error " + uri + " ", false, false, e.message);\n\t\t\t\tthis.dispatchEvent(error);\n\t\t\t\tdata = null;\n\t\t\t\tthrow new Error("Reference not resolvable: " + uri + ", " + e.message);\n\t\t\t}\n\t\t\tfinally\n\t\t\t{\n\t\t\t\treturn data;\n\t\t\t}\n\t\t}\n\t}\n}\n'})}),"\n",(0,i.jsxs)(t.p,{children:["This dereferencer class uses a constructor function with a parameter,\n",(0,i.jsx)(t.code,{children:"signedMessage"}),", to make the enveloped signature document available to the\n",(0,i.jsx)(t.code,{children:"dereference()"})," method. Since the reference in an enveloped signature always\nrefers to the root of the signed data, the ",(0,i.jsx)(t.code,{children:"dereferencer()"})," method writes the\ndocument into a byte array and returns it."]}),"\n",(0,i.jsx)(t.h2,{id:"dereferencing-uris-in-enveloping-and-detached-signatures",children:"Dereferencing URIs in enveloping and detached signatures"}),"\n",(0,i.jsx)(t.p,{children:"When the signed data is located in the same document as the signature itself,\nthe URIs in the references typically use XPath or XPointer syntax to address the\nelements that are signed. The W3C Recommendation for XML Signature Syntax and\nProcessing only recommends this syntax, so you should base your implementation\non the signatures you expect to encounter (and add sufficient error checking to\ngracefully handle unsupported syntax)."}),"\n",(0,i.jsx)(t.p,{children:'The signature of an AIR application is an example of an enveloping signature.\nThe files in the application are listed in a Manifest element. The Manifest\nelement is addressed in the Reference URI attribute using the string,\n"#PackageContents", which refers to the Id of the Manifest element:'}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:'<Signature xmlns="http://www.w3.org/2000/09/xmldsig#" Id="PackageSignature">\n\t<SignedInfo>\n\t\t<CanonicalizationMethod Algorithm="http://www.w3.org/TR/2001/REC-xml-c14n-20010315"/>\n\t\t<SignatureMethod Algorithm="http://www.w3.org/TR/xmldsig-core#rsa-sha1"/>\n\t\t<Reference URI="#PackageContents">\n\t\t\t<Transforms>\n\t\t\t\t<Transform Algorithm="http://www.w3.org/TR/2001/REC-xml-c14n-20010315"/>\n\t\t\t</Transforms>\n\t\t\t<DigestMethod Algorithm="http://www.w3.org/2001/04/xmlenc#sha256"/>\n\t\t\t<DigestValue>ZMGqQdaRKQc1HirIRsDpeBDlaElS+pPotdziIAyAYDk=</DigestValue>\n\t\t</Reference>\n\t</SignedInfo>\n\t<SignatureValue Id="PackageSignatureValue">cQK...7Zg==</SignatureValue>\n\t<KeyInfo>\n\t\t<X509Data>\n\t\t\t<X509Certificate>MII...T4e</X509Certificate>\n\t\t</X509Data>\n\t</KeyInfo>\n\t<Object>\n\t<Manifest Id="PackageContents">\n\t\t<Reference URI="mimetype">\n\t\t\t<DigestMethod Algorithm="http://www.w3.org/2001/04/xmlenc#sha256">\n\t\t\t</DigestMethod>\n\t\t\t<DigestValue>0/oCb84THKMagtI0Dy0KogEu92TegdesqRr/clXct1c=</DigestValue>\n\t\t</Reference>\n\t\t<Reference URI="META-INF/AIR/application.xml">\n\t\t\t<DigestMethod Algorithm="http://www.w3.org/2001/04/xmlenc#sha256">\n\t\t\t</DigestMethod>\n\t\t\t<DigestValue>P9MqtqSdqcqnFgeoHCJysLQu4PmbUW2JdAnc1WLq8h4=</DigestValue>\n\t\t</Reference>\n\t\t<Reference URI="XMLSignatureValidation.swf">\n\t\t\t<DigestMethod Algorithm="http://www.w3.org/2001/04/xmlenc#sha256">\n\t\t\t</DigestMethod>\n\t\t\t<DigestValue>OliRHRAgc9qt3Dk0m0Bi53Ur5ur3fAweIFwju74rFgE=</DigestValue>\n\t\t</Reference>\n\t</Manifest>\n\t</Object>\n</Signature>\n'})}),"\n",(0,i.jsxs)(t.p,{children:["A dereferencer for validating this signature must take the URI string\ncontaining, ",(0,i.jsx)(t.code,{children:'"#PackageContents"'}),' from the Reference element, and return the\nManifest element in a ByteArray object. The "#" symbol refers to the value of an\nelement Id attribute.']}),"\n",(0,i.jsx)(t.p,{children:"The following example implements a dereferencer for validating AIR application\nsignatures. The implementation is kept simple by relying on the known structure\nof an AIR signature. A general-purpose dereferencer could be significantly more\ncomplex."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:'package\n{\n\timport flash.events.ErrorEvent;\n\timport flash.security.IURIDereferencer;\n\timport flash.utils.ByteArray;\n\timport flash.utils.IDataInput;\n\n\tpublic class AIRSignatureDereferencer implements IURIDereferencer {\n\t\tprivate const XML_SIG_NS:Namespace =\n\t\t\tnew Namespace( "http://www.w3.org/2000/09/xmldsig#" );\n\t\tprivate var airSignature:XML;\n\n\t\tpublic function AIRSignatureDereferencer( airSignature:XML ) {\n\t\t\tthis.airSignature = airSignature;\n\t\t}\n\n\t\tpublic function dereference( uri:String ):IDataInput {\n\t\t\tvar data:ByteArray = null;\n\t\t\ttry\n\t\t\t{\n\t\t\t\tif( uri != "#PackageContents" )\n\t\t\t\t{\n\t\t\t\t\tthrow( new Error("Unsupported signature type.") );\n\t\t\t\t}\n\t\t\t\tvar manifest:XMLList =\n\t\t\t\t\tairSignature.XML_SIG_NS::Object.XML_SIG_NS::Manifest;\n\t\t\t\tdata = new ByteArray();\n\t\t\t\tdata.writeUTFBytes( manifest.toXMLString());\n\t\t\t\tdata.position = 0;\n\t\t\t}\n\t\t\tcatch (e:Error)\n\t\t\t{\n\t\t\t\tdata = null;\n\t\t\t\tthrow new Error("Reference not resolvable: " + uri + ", " + e.message);\n\t\t\t}\n\t\t\tfinally\n\t\t\t{\n\t\t\t\treturn data;\n\t\t\t}\n\n\t\t}\n\t}\n}\n'})}),"\n",(0,i.jsx)(t.p,{children:"When you verify this type of signature, only the data in the Manifest element is\nvalidated. The actual files in the package are not checked at all. To check the\npackage files for tampering, you must read the files, compute the SHA256 digest\nand compare the result to digest recorded in the manifest. The\nXMLSignatureValidator does not automatically check such secondary references."}),"\n",(0,i.jsx)(t.p,{children:"Note: This example is provided only to illustrate the signature validation\nprocess. There is little use in an AIR application validating its own signature.\nIf the application has already been tampered with, the tampering agent could\nsimply remove the validation check."}),"\n",(0,i.jsx)(t.h3,{id:"computing-digest-values-for-external-resources",children:"Computing digest values for external resources"}),"\n",(0,i.jsx)(t.p,{children:"AIR does not include built-in functions for computing SHA256 digests, but the\nFlex SDK does include a SHA256 utility class. The SDK also includes the Base64\nencoder utility class that is helpful for comparing the computed digest to the\ndigest stored in a signature."}),"\n",(0,i.jsx)(t.p,{children:"The following example function reads and validates the files in an AIR package\nmanifest:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:'import mx.utils.Base64Encoder;\nimport mx.utils.SHA256;\n\nprivate function verifyManifest( sigFile:File, manifest:XML ):Boolean\n{\n\tvar result:Boolean = true;\n\tvar message:String = \'\';\n\tvar nameSpace:Namespace = manifest.namespace();\n\n\tif( manifest.nameSpace::Reference.length() <= 0 )\n\t{\n\t\tresult = false;\n\t\tmessage = "Nothing to validate.";\n\t}\n\tfor each (var reference:XML in manifest.nameSpace::Reference)\n\t{\n\t\tvar file:File = sigFile.parent.parent.resolvePath( reference.@URI );\n\t\tvar stream:FileStream = new FileStream();\n\t\tstream.open(file, FileMode.READ);\n\t\tvar fileData:ByteArray = new ByteArray();\n\t\tstream.readBytes( fileData, 0, stream.bytesAvailable );\n\n\t\tvar digestHex:String = SHA256.computeDigest( fileData );\n\t\t//Convert hexidecimal string to byte array\n\t\tvar digest:ByteArray = new ByteArray();\n\t\tfor( var c:int = 0; c < digestHex.length; c += 2 ){\n\t\t\tvar byteChar:String = digestHex.charAt(c) + digestHex.charAt(c+1);\n\t\t\tdigest.writeByte( parseInt( byteChar, 16 ));\n\t\t}\n\t\tdigest.position = 0;\n\n\t\tvar base64Encoder:Base64Encoder = new Base64Encoder();\n\t\tbase64Encoder.insertNewLines = false;\n\t\tbase64Encoder.encodeBytes( digest, 0, digest.bytesAvailable );\n\t\tvar digestBase64:String = base64Encoder.toString();\n\t\tif( digestBase64 == reference.nameSpace::DigestValue )\n\t\t{\n\t\t\tresult = result && true;\n\t\t\tmessage += "   " + reference.@URI + " verified.\\n";\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult = false;\n\t\t\tmessage += " ---- " + reference.@URI + " has been modified!\\n";\n\t\t}\n\t\tbase64Encoder.reset();\n\t}\n\ttrace( message );\n\treturn result;\n}\n'})}),"\n",(0,i.jsx)(t.p,{children:"The function loops through all the references in the Manifest element. For each\nreference, the SHA256 digest is computed, encoded in base64 format, and compared\nto the digest in the manifest. The URIs in an AIR package refer to paths\nrelative to the application directory. The paths are resolved based on the\nlocation of the signature file, which is always in the META-INF subdirectory\nwithin the application directory. Note that the Flex SHA256 class returns the\ndigest as a string of hexadecimal characters. This string must be converted into\na ByteArray containing the bytes represented by the hexadecimal string."}),"\n",(0,i.jsx)(t.p,{children:"To use the mx.utils.SHA256 and Base64Encoder classes in Flash CS4, you can\neither locate and copy these classes into your application development directory\nor compile a library SWF containing the classes using the Flex SDK."}),"\n",(0,i.jsx)(t.h2,{id:"dereferencing-uris-in-detached-signatures-referencing-external-data",children:"Dereferencing URIs in detached signatures referencing external data"}),"\n",(0,i.jsx)(t.p,{children:"When a URI refers to an external resource, the data must be accessed and loaded\ninto a ByteArray object. If the URI contains an absolute URL, then it is simply\na matter of reading a file or requesting a URL. If, as is probably the more\ncommon case, the URI contains to a relative path, then your IURIDereferencer\nimplementation must include a way to resolve the paths to the signed files."}),"\n",(0,i.jsx)(t.p,{children:"The following example uses a File object initialized when the dereferencer\ninstance is constructed as the base for resolving signed files."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:'package\n{\n\timport flash.events.ErrorEvent;\n\timport flash.events.EventDispatcher;\n\timport flash.filesystem.File;\n\timport flash.filesystem.FileMode;\n\timport flash.filesystem.FileStream;\n\timport flash.security.IURIDereferencer;\n\timport flash.utils.ByteArray;\n\timport flash.utils.IDataInput;\n\tpublic class RelativeFileDereferencer\n\t\textends EventDispatcher implements IURIDereferencer\n\t{\n\t\tprivate var base:File;\n\n\t\tpublic function RelativeFileDereferencer( base:File )\n\t\t{\n\t\t\tthis.base = base;\n\t\t}\n\n\t\tpublic function dereference( uri:String ):IDataInput\n\t\t{\n\t\t\tvar data:ByteArray = null;\n\t\t\ttry{\n\t\t\t\tvar referent:File = this.base.resolvePath( uri );\n\t\t\t\tvar refStream:FileStream = new FileStream();\n\t\t\t\tdata = new ByteArray();\n\t\t\t\trefStream.open( referent, FileMode.READ );\n\n\t\t\t\trefStream.readBytes( data, 0, data.bytesAvailable );\n\n\t\t\t} catch ( e:Error ) {\n\t\t\t\tdata = null;\n\t\t\t\tthrow new Error("Reference not resolvable: " + referent.nativePath + ", " + e.message );\n\t\t\t} finally {\n\t\t\t\treturn data;\n\t\t\t}\n\t\t}\n\t}\n}\n'})}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"dereference()"})," function simply locates the file addressed by the reference\nURI, loads the file contents into a byte array, and returns the ByteArray\nobject."]}),"\n",(0,i.jsx)(t.p,{children:'Note: Before validating remote external references, consider whether your\napplication could be vulnerable to a "phone home" or similar type of attack by a\nmaliciously constructed signature document.'})]})}function h(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);