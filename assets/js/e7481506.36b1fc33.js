"use strict";(self.webpackChunkairsdk_dev=self.webpackChunkairsdk_dev||[]).push([[69251],{19855:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>l,frontMatter:()=>o,metadata:()=>s,toc:()=>h});const s=JSON.parse('{"id":"development/core-actionscript-classes/working-with-arrays/extending-the-array-class","title":"Extending the Array class","description":"The Array class is one of the few core classes that is not final, which means","source":"@site/docs/development/core-actionscript-classes/working-with-arrays/extending-the-array-class.md","sourceDirName":"development/core-actionscript-classes/working-with-arrays","slug":"/development/core-actionscript-classes/working-with-arrays/extending-the-array-class","permalink":"/docs/development/core-actionscript-classes/working-with-arrays/extending-the-array-class","draft":false,"unlisted":false,"editUrl":"https://github.com/airsdk/airsdk.dev/edit/main/docs/development/core-actionscript-classes/working-with-arrays/extending-the-array-class.md","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"sidebar_position":6},"sidebar":"mainSidebar","previous":{"title":"Cloning arrays","permalink":"/docs/development/core-actionscript-classes/working-with-arrays/cloning-arrays"},"next":{"title":"Arrays example: PlayList","permalink":"/docs/development/core-actionscript-classes/working-with-arrays/arrays-example-playlist"}}');var t=r(74848),a=r(28453);const o={sidebar_position:6},i="Extending the Array class",c={},h=[{value:"Declaring the subclass",id:"declaring-the-subclass",level:4},{value:"TypedArray constructor",id:"typedarray-constructor",level:4},{value:"TypedArray overridden methods",id:"typedarray-overridden-methods",level:4}];function d(e){const n={code:"code",em:"em",h1:"h1",h4:"h4",header:"header",img:"img",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"extending-the-array-class",children:"Extending the Array class"})}),"\n",(0,t.jsx)(n.p,{children:"The Array class is one of the few core classes that is not final, which means\nthat you can create your own subclass of Array. This section provides an example\nof how to create a subclass of Array and discusses some of the issues that can\narise during the process."}),"\n",(0,t.jsx)(n.p,{children:"As mentioned previously, arrays in ActionScript are not typed, but you can\ncreate a subclass of Array that accepts elements of only a specific data type.\nThe example in the following sections defines an Array subclass named TypedArray\nthat limits its elements to values of the data type specified in the first\nparameter. The TypedArray class is presented merely as an example of how to\nextend the Array class and may not be suitable for production purposes for\nseveral reasons. First, type checking occurs at run time rather than at compile\ntime. Second, when a TypedArray method encounters a mismatch, the mismatch is\nignored and no exception is thrown, although the methods can be easily modified\nto throw exceptions. Third, the class cannot prevent the use of the array access\noperator to insert values of any type into the array. Fourth, the coding style\nfavors simplicity over performance optimization."}),"\n",(0,t.jsx)(n.p,{children:"Note: You can use the technique described here to create a typed array. However,\na better approach is to use a Vector object. A Vector instance is a true typed\narray, and provides performance and other improvements over the Array class or\nany subclass. The purpose of this discussion is to demonstrate how to create an\nArray subclass."}),"\n",(0,t.jsx)(n.h4,{id:"declaring-the-subclass",children:"Declaring the subclass"}),"\n",(0,t.jsxs)(n.p,{children:["Use the ",(0,t.jsx)(n.code,{children:"extends"})," keyword to indicate that a class is a subclass of Array. A\nsubclass of Array should use the ",(0,t.jsx)(n.code,{children:"dynamic"})," attribute, just as the Array class\ndoes. Otherwise, your subclass will not function properly."]}),"\n",(0,t.jsx)(n.p,{children:"The following code shows the definition of the TypedArray class, which contains\na constant to hold the data type, a constructor method, and the four methods\nthat are capable of adding elements to the array. The code for each method is\nomitted in this example, but is delineated and explained fully in the sections\nthat follow:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"public dynamic class TypedArray extends Array\n{\n    private const dataType:Class;\n\n    public function TypedArray(...args) {}\n\n    AS3 override function concat(...args):Array {}\n\n    AS3 override function push(...args):uint {}\n\n    AS3 override function splice(...args) {}\n\n    AS3 override function unshift(...args):uint {}\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The four overridden methods all use the AS3 namespace instead of the ",(0,t.jsx)(n.code,{children:"public"}),"\nattribute because this example assumes that the compiler option ",(0,t.jsx)(n.code,{children:"-as3"})," is set to\n",(0,t.jsx)(n.code,{children:"true"})," and the compiler option ",(0,t.jsx)(n.code,{children:"-es"})," is set to ",(0,t.jsx)(n.code,{children:"false"}),". These are the default\nsettings for Adobe Flash Builder and for AdobeFlashProfessional."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.img,{src:r(81029).A+"",width:"17",height:"21"})," If you are an advanced developer who prefers to use\nprototype inheritance, you can make two minor changes to the TypedArray class to\nmake it compile with the compiler option ",(0,t.jsx)(n.code,{children:"-es"})," set to ",(0,t.jsx)(n.code,{children:"true"}),". First, remove all\noccurrences of the ",(0,t.jsx)(n.code,{children:"override"})," attribute and replace the AS3 namespace with the\n",(0,t.jsx)(n.code,{children:"public"})," attribute. Second, substitute ",(0,t.jsx)(n.code,{children:"Array.prototype"})," for all four\noccurrences of ",(0,t.jsx)(n.code,{children:"super"})," ",(0,t.jsx)(n.em,{children:"."})]}),"\n",(0,t.jsx)(n.h4,{id:"typedarray-constructor",children:"TypedArray constructor"}),"\n",(0,t.jsxs)(n.p,{children:["The subclass constructor poses an interesting challenge because the constructor\nmust accept a list of arguments of arbitrary length. The challenge is how to\npass the arguments on to the superconstructor to create the array. If you pass\nthe list of arguments as an array, the superconstructor considers it a single\nargument of type Array and the resulting array is always 1 element long. The\ntraditional way to handle pass-through argument lists is to use the\n",(0,t.jsx)(n.code,{children:"Function.apply()"})," method, which takes an array of arguments as its second\nparameter but converts it to a list of arguments when executing the function.\nUnfortunately, the ",(0,t.jsx)(n.code,{children:"Function.apply()"})," method cannot be used with constructors."]}),"\n",(0,t.jsx)(n.p,{children:"The only option left is to recreate the logic of the Array constructor in the\nTypedArray constructor. The following code shows the algorithm used in the Array\nclass constructor, which you can reuse in your Array subclass constructor:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'public dynamic class Array\n{\n    public function Array(...args)\n    {\n        var n:uint = args.length\n        if (n == 1 && (args[0] is Number))\n        {\n            var dlen:Number = args[0];\n            var ulen:uint = dlen;\n            if (ulen != dlen)\n            {\n                throw new RangeError("Array index is not a 32-bit unsigned integer ("+dlen+")");\n            }\n            length = ulen;\n        }\n        else\n        {\n            length = n;\n            for (var i:int=0; i < n; i++)\n            {\n                this[i] = args[i]\n            }\n        }\n    }\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["The TypedArray constructor shares most of the code from the Array constructor,\nwith only four changes to the code. First, the parameter list includes a new\nrequired parameter of type Class that allows specification of the array's data\ntype. Second, the data type passed to the constructor is assigned to the\n",(0,t.jsx)(n.code,{children:"dataType"})," variable. Third, in the ",(0,t.jsx)(n.code,{children:"else"})," statement, the value of the ",(0,t.jsx)(n.code,{children:"length"}),"\nproperty is assigned after the ",(0,t.jsx)(n.code,{children:"for"})," loop so that ",(0,t.jsx)(n.code,{children:"length"})," includes only\narguments that are the proper type. Fourth, the body of the ",(0,t.jsx)(n.code,{children:"for"})," loop uses the\noverridden version of the ",(0,t.jsx)(n.code,{children:"push()"})," method so that only arguments of the correct\ndata type are added to the array. The following example shows the TypedArray\nconstructor function:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'public dynamic class TypedArray extends Array\n{\n    private var dataType:Class;\n    public function TypedArray(typeParam:Class, ...args)\n    {\n        dataType = typeParam;\n        var n:uint = args.length\n        if (n == 1 && (args[0] is Number))\n        {\n            var dlen:Number = args[0];\n            var ulen:uint = dlen\n            if (ulen != dlen)\n            {\n                throw new RangeError("Array index is not a 32-bit unsigned integer ("+dlen+")")\n            }\n            length = ulen;\n        }\n        else\n        {\n            for (var i:int=0; i < n; i++)\n            {\n                // type check done in push()\n                this.push(args[i])\n            }\n            length = this.length;\n        }\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h4,{id:"typedarray-overridden-methods",children:"TypedArray overridden methods"}),"\n",(0,t.jsx)(n.p,{children:"The TypedArray class overrides the four methods of the Array class that are\ncapable of adding elements to an array. In each case, the overridden method adds\na type check that prevents the addition of elements that are not the correct\ndata type. Subsequently, each method calls the superclass version of itself."}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"push()"})," method iterates through the list of arguments with a ",(0,t.jsx)(n.code,{children:"for..in"})," loop\nand does a type check on each argument. Any argument that is not the correct\ntype is removed from the ",(0,t.jsx)(n.code,{children:"args"})," array with the ",(0,t.jsx)(n.code,{children:"splice()"})," method. After the\n",(0,t.jsx)(n.code,{children:"for..in"})," loop ends, the ",(0,t.jsx)(n.code,{children:"args"})," array contains values only of type ",(0,t.jsx)(n.code,{children:"dataType"}),".\nThe superclass version of ",(0,t.jsx)(n.code,{children:"push()"})," is then called with the updated ",(0,t.jsx)(n.code,{children:"args"})," array,\nas the following code shows:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"AS3 override function push(...args):uint\n{\n   for (var i:* in args)\n   {\n       if (!(args[i] is dataType))\n       {\n           args.splice(i,1);\n       }\n   }\n   return (super.push.apply(this, args));\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"concat()"})," method creates a temporary TypedArray named ",(0,t.jsx)(n.code,{children:"passArgs"})," to store\nthe arguments that pass the type check. This allows the reuse of the type check\ncode that exists in the ",(0,t.jsx)(n.code,{children:"push()"})," method. A ",(0,t.jsx)(n.code,{children:"for..in"})," loop iterates through the\n",(0,t.jsx)(n.code,{children:"args"})," array, and calls ",(0,t.jsx)(n.code,{children:"push()"})," on each argument. Because ",(0,t.jsx)(n.code,{children:"passArgs"})," is typed\nas TypedArray, the TypedArray version of ",(0,t.jsx)(n.code,{children:"push()"})," is executed. The ",(0,t.jsx)(n.code,{children:"concat()"}),"\nmethod then calls its own superclass version, as the following code shows:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"AS3 override function concat(...args):Array\n{\n    var passArgs:TypedArray = new TypedArray(dataType);\n    for (var i:* in args)\n    {\n        // type check done in push()\n        passArgs.push(args[i]);\n    }\n    return (super.concat.apply(this, passArgs));\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"splice()"})," method takes an arbitrary list of arguments, but the first two\narguments always refer to an index number and the number of elements to delete.\nThis is why the overridden ",(0,t.jsx)(n.code,{children:"splice()"})," method does type checking only for ",(0,t.jsx)(n.code,{children:"args"}),"\narray elements in index positions 2 or higher. One point of interest in the code\nis that there appears to be a recursive call to ",(0,t.jsx)(n.code,{children:"splice()"})," inside the ",(0,t.jsx)(n.code,{children:"for"}),"\nloop, but this is not a recursive call because ",(0,t.jsx)(n.code,{children:"args"})," is of type Array rather\nthan TypedArray, which means that the call to ",(0,t.jsx)(n.code,{children:"args.splice()"})," is a call to the\nsuperclass version of the method. After the ",(0,t.jsx)(n.code,{children:"for..in"})," loop concludes, the ",(0,t.jsx)(n.code,{children:"args"}),"\narray contains only values of the correct type in index positions 2 or higher,\nand ",(0,t.jsx)(n.code,{children:"splice()"})," calls its own superclass version, as shown in the following code:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"AS3 override function splice(...args):*\n{\n    if (args.length > 2)\n    {\n        for (var i:int=2; i< args.length; i++)\n        {\n            if (!(args[i] is dataType))\n            {\n                args.splice(i,1);\n            }\n        }\n    }\n    return (super.splice.apply(this, args));\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"unshift()"})," method, which adds elements to the beginning of an array, also\naccepts an arbitrary list of arguments. The overridden ",(0,t.jsx)(n.code,{children:"unshift()"})," method uses\nan algorithm very similar to that used by the ",(0,t.jsx)(n.code,{children:"push()"})," method, as shown in the\nfollowing example code:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"AS3 override function unshift(...args):uint\n{\n    for (var i:* in args)\n    {\n        if (!(args[i] is dataType))\n        {\n            args.splice(i,1);\n        }\n    }\n    return (super.unshift.apply(this, args));\n}\n"})})]})}function l(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},28453:(e,n,r)=>{r.d(n,{R:()=>o,x:()=>i});var s=r(96540);const t={},a=s.createContext(t);function o(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),s.createElement(a.Provider,{value:n},e.children)}},81029:(e,n,r)=>{r.d(n,{A:()=>s});const s=r.p+"assets/images/tip_help-3d4c326bf05518d713f5bf1c3f47bcde.png"}}]);