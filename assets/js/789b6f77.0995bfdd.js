"use strict";(self.webpackChunkairsdk_dev=self.webpackChunkairsdk_dev||[]).push([[68021],{28453:(e,r,n)=>{n.d(r,{R:()=>c,x:()=>i});var t=n(96540);const o={},s=t.createContext(o);function c(e){const r=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function i(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:c(e.components),t.createElement(s.Provider,{value:r},e.children)}},30890:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>a,contentTitle:()=>i,default:()=>d,frontMatter:()=>c,metadata:()=>t,toc:()=>h});const t=JSON.parse('{"id":"development/core-actionscript-classes/handling-errors/handling-synchronous-errors-in-an-application","title":"Handling synchronous errors in an application","description":"The most common error handling is synchronous error-handling logic, where you","source":"@site/docs/development/core-actionscript-classes/handling-errors/handling-synchronous-errors-in-an-application.md","sourceDirName":"development/core-actionscript-classes/handling-errors","slug":"/development/core-actionscript-classes/handling-errors/handling-synchronous-errors-in-an-application","permalink":"/docs/development/core-actionscript-classes/handling-errors/handling-synchronous-errors-in-an-application","draft":false,"unlisted":false,"editUrl":"https://github.com/airsdk/airsdk.dev/edit/main/docs/development/core-actionscript-classes/handling-errors/handling-synchronous-errors-in-an-application.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5},"sidebar":"mainSidebar","previous":{"title":"Working with the debugger versions of Flash runtimes","permalink":"/docs/development/core-actionscript-classes/handling-errors/working-with-the-debugger-versions-of-flash-runtimes"},"next":{"title":"Creating custom error classes","permalink":"/docs/development/core-actionscript-classes/handling-errors/creating-custom-error-classes"}}');var o=n(74848),s=n(28453);const c={sidebar_position:5},i="Handling synchronous errors in an application",a={},h=[{value:"Using try catch finally statements",id:"using-try-catch-finally-statements",level:2},{value:"The throw statement",id:"the-throw-statement",level:2},{value:"Displaying a simple error message",id:"displaying-a-simple-error-message",level:2},{value:"Rethrowing errors",id:"rethrowing-errors",level:2}];function l(e){const r={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(r.header,{children:(0,o.jsx)(r.h1,{id:"handling-synchronous-errors-in-an-application",children:"Handling synchronous errors in an application"})}),"\n",(0,o.jsxs)(r.p,{children:["The most common error handling is synchronous error-handling logic, where you\ninsert statements into your code to catch synchronous errors while an\napplication is running. This type of error handling lets your application notice\nand recover from run-time errors when functions fail. The logic for catching a\nsynchronous error includes ",(0,o.jsx)(r.code,{children:"try..catch..finally"})," statements, which literally try\nan operation, catch any error response from the Flash runtime, and finally\nexecute some other operation to handle the failed operation."]}),"\n",(0,o.jsx)(r.h2,{id:"using-try-catch-finally-statements",children:"Using try catch finally statements"}),"\n",(0,o.jsxs)(r.p,{children:["When you work with synchronous run-time errors, use the ",(0,o.jsx)(r.code,{children:"try..catch..finally"}),"\nstatements to catch errors. When a run-time error occurs, the Flash runtime\nthrows an exception, which means that it suspends normal execution and creates a\nspecial object of type Error. The Error object is then thrown to the first\navailable ",(0,o.jsx)(r.code,{children:"catch"})," block."]}),"\n",(0,o.jsxs)(r.p,{children:["The ",(0,o.jsx)(r.code,{children:"try"})," statement encloses statements that have the potential to create\nerrors. You always use the ",(0,o.jsx)(r.code,{children:"catch"})," statement with a ",(0,o.jsx)(r.code,{children:"try"})," statement. If an error\nis detected in one of the statements in the ",(0,o.jsx)(r.code,{children:"try"})," statement block, the ",(0,o.jsx)(r.code,{children:"catch"}),"\nstatements that are attached to that ",(0,o.jsx)(r.code,{children:"try"})," statement run."]}),"\n",(0,o.jsxs)(r.p,{children:["The ",(0,o.jsx)(r.code,{children:"finally"})," statement encloses statements that run whether an error occurs in\nthe ",(0,o.jsx)(r.code,{children:"try"})," block. If there is no error, the statements within the ",(0,o.jsx)(r.code,{children:"finally"})," block\nexecute after the ",(0,o.jsx)(r.code,{children:"try"})," block statements complete. If there is an error, the\nappropriate ",(0,o.jsx)(r.code,{children:"catch"})," statement executes first, followed by the statements in the\n",(0,o.jsx)(r.code,{children:"finally"})," block."]}),"\n",(0,o.jsxs)(r.p,{children:["The following code demonstrates the syntax for using the ",(0,o.jsx)(r.code,{children:"try..catch..finally"}),"\nstatements:"]}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{children:"try\n{\n    // some code that could throw an error\n}\ncatch (err:Error)\n{\n    // code to react to the error\n}\nfinally\n{\n    // Code that runs whether an error was thrown. This code can clean\n    // up after the error, or take steps to keep the application running.\n}\n"})}),"\n",(0,o.jsxs)(r.p,{children:["Each ",(0,o.jsx)(r.code,{children:"catch"})," statement identifies a specific type of exception that it handles.\nThe ",(0,o.jsx)(r.code,{children:"catch"})," statement can specify only error classes that are subclasses of the\nError class. Each ",(0,o.jsx)(r.code,{children:"catch"})," statement is checked in order. Only the first ",(0,o.jsx)(r.code,{children:"catch"}),"\nstatement that matches the type of error thrown runs. In other words, if you\nfirst check the higher-level Error class and then a subclass of the Error class,\nonly the higher-level Error class matches. The following code illustrates this\npoint:"]}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{children:'try\n{\n    throw new ArgumentError("I am an ArgumentError");\n}\ncatch (error:Error)\n{\n    trace("<Error> " + error.message);\n}\ncatch (error:ArgumentError)\n{\n    trace("<ArgumentError> " + error.message);\n}\n'})}),"\n",(0,o.jsx)(r.p,{children:"The previous code displays the following output:"}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{children:"<Error> I am an ArgumentError\n"})}),"\n",(0,o.jsx)(r.p,{children:"To correctly catch the ArgumentError, make sure that the most specific error\ntypes are listed first and the more generic error types are listed later, as the\nfollowing code shows:"}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{children:'try\n{\n    throw new ArgumentError("I am an ArgumentError");\n}\ncatch (error:ArgumentError)\n{\n    trace("<ArgumentError> " + error.message);\n}\ncatch (error:Error)\n{\n    trace("<Error> " + error.message);\n}\n'})}),"\n",(0,o.jsxs)(r.p,{children:["Several methods and properties in the ActionScript API throw run-time errors if\nthey encounter errors while they execute. For example, the ",(0,o.jsx)(r.code,{children:"close()"})," method in\nthe Sound class throws an IOError if the method is unable to close the audio\nstream, as demonstrated in the following code:"]}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{children:"var mySound:Sound = new Sound();\ntry\n{\n    mySound.close();\n}\ncatch (error:IOError)\n{\n    // Error #2029: This URLStream object does not have an open stream.\n}\n"})}),"\n",(0,o.jsxs)(r.p,{children:["As you become more familiar with the\n",(0,o.jsx)(r.a,{href:"https://airsdk.dev/reference/actionscript/3.0/index.html",children:"ActionScript 3.0 Reference for the Adobe Flash Platform"}),",\nyou'll notice which methods throw exceptions, as detailed in each method's\ndescription."]}),"\n",(0,o.jsx)(r.h2,{id:"the-throw-statement",children:"The throw statement"}),"\n",(0,o.jsxs)(r.p,{children:["Flash runtimes throw exceptions when they encounter errors in your running\napplication. In addition, you can explicitly throw exceptions yourself using the\n",(0,o.jsx)(r.code,{children:"throw"})," statement. When explicitly throwing errors, Adobe recommends that you\nthrow instances of the Error class or its subclasses. The following code\ndemonstrates a ",(0,o.jsx)(r.code,{children:"throw"})," statement that throws an instance of the Error class,\n",(0,o.jsx)(r.code,{children:"MyErr"}),", and eventually calls a function, ",(0,o.jsx)(r.code,{children:"myFunction()"}),", to respond after the\nerror is thrown:"]}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{children:'var MyError:Error = new Error("Encountered an error with the numUsers value", 99);\nvar numUsers:uint = 0;\ntry\n{\n    if (numUsers == 0)\n    {\n        trace("numUsers equals 0");\n    }\n}\ncatch (error:uint)\n{\n    throw MyError; // Catch unsigned integer errors.\n}\ncatch (error:int)\n{\n    throw MyError; // Catch integer errors.\n}\ncatch (error:Number)\n{\n    throw MyError; // Catch number errors.\n}\ncatch (error:*)\n{\n    throw MyError; // Catch any other error.\n}\nfinally\n{\n    myFunction(); // Perform any necessary cleanup here.\n}\n'})}),"\n",(0,o.jsxs)(r.p,{children:["Notice that the ",(0,o.jsx)(r.code,{children:"catch"})," statements are ordered so that the most specific data\ntypes are listed first. If the ",(0,o.jsx)(r.code,{children:"catch"})," statement for the Number data type is\nlisted first, neither the catch statement for the uint data type nor the catch\nstatement for the int data type is ever run."]}),"\n",(0,o.jsxs)(r.p,{children:["Note: In the Java programming language, each function that can throw an\nexception must declare this fact, listing the exception classes it can throw in\na ",(0,o.jsx)(r.code,{children:"throws"})," clause attached to the function declaration. ActionScript does not\nrequire you to declare the exceptions thrown by a function."]}),"\n",(0,o.jsx)(r.h2,{id:"displaying-a-simple-error-message",children:"Displaying a simple error message"}),"\n",(0,o.jsx)(r.p,{children:"One of the biggest benefits of the new exception and error event model is that\nit allows you to tell users when and why an action has failed. Your part is to\nwrite the code to display the message and offer options in response."}),"\n",(0,o.jsxs)(r.p,{children:["The following code shows a simple ",(0,o.jsx)(r.code,{children:"try..catch"})," statement to display the error in\na text field:"]}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{children:'package\n{\n    import flash.display.Sprite;\n    import flash.text.TextField;\n\n    public class SimpleError extends Sprite\n    {\n        public var employee:XML =\n            <EmpCode>\n                <costCenter>1234</costCenter>\n                <costCenter>1-234</costCenter>\n            </EmpCode>;\n\n        public function SimpleError()\n        {\n            try\n            {\n                if (employee.costCenter.length() != 1)\n                {\n                    throw new Error("Error, employee must have exactly one cost center assigned.");\n                }\n            }\n            catch (error:Error)\n            {\n                var errorMessage:TextField = new TextField();\n                errorMessage.autoSize = TextFieldAutoSize.LEFT;\n                errorMessage.textColor = 0xFF0000;\n                errorMessage.text = error.message;\n                addChild(errorMessage);\n            }\n        }\n    }\n}\n'})}),"\n",(0,o.jsx)(r.p,{children:"Using a wider range of error classes and built-in compiler errors, ActionScript\n3.0 offers more information than previous versions of ActionScript about why\nsomething has failed. This information enables you to build more stable\napplications with better error handling."}),"\n",(0,o.jsx)(r.h2,{id:"rethrowing-errors",children:"Rethrowing errors"}),"\n",(0,o.jsxs)(r.p,{children:["When you build applications, there are several occasions in which you need to\nrethrow an error if you are unable to handle the error properly. For example,\nthe following code shows a nested ",(0,o.jsx)(r.code,{children:"try..catch"})," block, which rethrows a custom\nApplicationError if the nested ",(0,o.jsx)(r.code,{children:"catch"})," block is unable to handle the error:"]}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{children:'try\n{\n    try\n    {\n        trace("<< try >>");\n        throw new ApplicationError("some error which will be rethrown");\n    }\n    catch (error:ApplicationError)\n    {\n        trace("<< catch >> " + error);\n        trace("<< throw >>");\n        throw error;\n    }\n    catch (error:Error)\n    {\n        trace("<< Error >> " + error);\n    }\n}\ncatch (error:ApplicationError)\n{\n    trace("<< catch >> " + error);\n}\n'})}),"\n",(0,o.jsx)(r.p,{children:"The output from the previous snippet would be the following:"}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{children:"<< try >>\n<< catch >> ApplicationError: some error which will be rethrown\n<< throw >>\n<< catch >> ApplicationError: some error which will be rethrown\n"})}),"\n",(0,o.jsxs)(r.p,{children:["The nested ",(0,o.jsx)(r.code,{children:"try"})," block throws a custom ApplicationError error that is caught by\nthe subsequent ",(0,o.jsx)(r.code,{children:"catch"})," block. This nested ",(0,o.jsx)(r.code,{children:"catch"})," block can try to handle the\nerror, and if unsuccessful, throw the ApplicationError object to the enclosing\n",(0,o.jsx)(r.code,{children:"try..catch"})," block."]})]})}function d(e={}){const{wrapper:r}={...(0,s.R)(),...e.components};return r?(0,o.jsx)(r,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}}}]);